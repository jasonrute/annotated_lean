<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2018 Mario Carneiro. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Author: Mario Carneiro</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  More partial recursive functions using a universal program;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  Rice&#x27;s theorem and the halting problem.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import computability.partrec_code</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open encodable denumerable</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  namespace nat.partrec</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  open computable roption</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  theorem merge&#x27; {f g}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17    (hf : nat.partrec f) (hg : nat.partrec g) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nat.partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nat.partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pfun.{0 0} nat nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pfun.{0 0} nat nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18    ∃ h, nat.partrec h ∧ ∀ a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} nat nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19      (∀ x ∈ h a, x ∈ f a ∨ x ∈ g a) ∧</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20      ((h a).dom ↔ (f a).dom ∨ (g a).dom) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.dom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.dom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.dom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, roption.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, roption.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, roption.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g
⊢ @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (f a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (g a)))
              (iff (@roption.dom.{0} nat (h a)) (or (@roption.dom.{0} nat (f a)) (@roption.dom.{0} nat (g a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22    rcases code.exists_code.1 hf with ⟨cf, rfl⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec.code.exists_code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {f : pfun.{0 0} nat nat}, iff (nat.partrec f) (@Exists.{1} nat.partrec.code (λ (c : nat.partrec.code), @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g
⊢ @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (f a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (g a)))
              (iff (@roption.dom.{0} nat (h a)) (or (@roption.dom.{0} nat (f a)) (@roption.dom.{0} nat (g a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='g : pfun.{0 0} nat nat,
hg : nat.partrec g,
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf)
⊢ @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (g a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or (@roption.dom.{0} nat (nat.partrec.code.eval cf a)) (@roption.dom.{0} nat (g a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23    rcases code.exists_code.1 hg with ⟨cg, rfl⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec.code.exists_code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {f : pfun.{0 0} nat nat}, iff (nat.partrec f) (@Exists.{1} nat.partrec.code (λ (c : nat.partrec.code), @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='g : pfun.{0 0} nat nat,
hg : nat.partrec g,
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf)
⊢ @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (g a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or (@roption.dom.{0} nat (nat.partrec.code.eval cf a)) (@roption.dom.{0} nat (g a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg)
⊢ @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or (@roption.dom.{0} nat (nat.partrec.code.eval cf a))
                    (@roption.dom.{0} nat (nat.partrec.code.eval cg a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24    have : nat.partrec (λ n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pfun.{0 0} nat nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg)
⊢ @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or (@roption.dom.{0} nat (nat.partrec.code.eval cf a))
                    (@roption.dom.{0} nat (nat.partrec.code.eval cg a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25      (nat.rfind_opt (λ k, cf.evaln k n &lt;|&gt; cg.evaln k n))) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.rfind_opt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='cf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_orelse.orelse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 543, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/alternative.lean&#x27;, &#x27;line&#x27;: 10, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 543, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, (nat → option.{0} α) → roption.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {f : Type → Type} [c : has_orelse.{0 0} f] {α : Type}, f α → f α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg)
⊢ @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or (@roption.dom.{0} nat (nat.partrec.code.eval cf a))
                    (@roption.dom.{0} nat (nat.partrec.code.eval cg a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26    partrec.nat_iff.1 (partrec.rfind_opt $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='partrec.nat_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='partrec.rfind_opt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 369, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {f : pfun.{0 0} nat nat}, iff (@partrec.{0 0} nat nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) f) (nat.partrec f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_4 : primcodable.{0} σ] {f : α → nat → option.{0} σ}, @computable₂.{0 0 0} α nat (option.{0} σ) _inst_1 (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.option.{0} σ _inst_4) f → @partrec.{0 0} α σ _inst_1 _inst_4 (λ (a : α), @nat.rfind_opt.{0} σ (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg)
⊢ @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or (@roption.dom.{0} nat (nat.partrec.code.eval cf a))
                    (@roption.dom.{0} nat (nat.partrec.code.eval cg a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27      primrec.option_orelse.to_comp.comp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='primrec.option_orelse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 621, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α], @primrec₂.{0 0 0} (option.{0} α) (option.{0} α) (option.{0} α) (@primcodable.option.{0} α _inst_1) (@primcodable.option.{0} α _inst_1) (@primcodable.option.{0} α _inst_1) (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg)
⊢ @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or (@roption.dom.{0} nat (nat.partrec.code.eval cf a))
                    (@roption.dom.{0} nat (nat.partrec.code.eval cg a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28        (code.evaln_prim.to_comp.comp $ (snd.pair (const cf)).pair fst)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='blue'><a title='cf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg)
⊢ @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or (@roption.dom.{0} nat (nat.partrec.code.eval cf a))
                    (@roption.dom.{0} nat (nat.partrec.code.eval cg a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29        (code.evaln_prim.to_comp.comp $ (snd.pair (const cg)).pair fst)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat.partrec.code.evaln_prim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='computable.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='computable.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 820, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 261, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@primrec.{0 0} (prod.{0 0} (prod.{0 0} nat nat.partrec.code) nat) (option.{0} nat) (@primcodable.prod.{0 0} (prod.{0 0} nat nat.partrec.code) nat (@primcodable.prod.{0 0} nat nat.partrec.code (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)) (@primcodable.of_denumerable.{0} nat denumerable.nat)) (@primcodable.option.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)) (λ (a : prod.{0 0} (prod.{0 0} nat nat.partrec.code) nat), nat.partrec.code.evaln (@prod.fst.{0 0} nat nat.partrec.code (@prod.fst.{0 0} (prod.{0 0} nat nat.partrec.code) nat a)) (@prod.snd.{0 0} nat nat.partrec.code (@prod.fst.{0 0} (prod.{0 0} nat nat.partrec.code) nat a)) (@prod.snd.{0 0} (prod.{0 0} nat nat.partrec.code) nat a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β], @computable.{0 0} (prod.{0 0} α β) β (@primcodable.prod.{0 0} α β _inst_1 _inst_2) _inst_2 (@prod.snd.{0 0} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_4 : primcodable.{0} σ] (s : σ), @computable.{0 0} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β], @computable.{0 0} (prod.{0 0} α β) α (@primcodable.prod.{0 0} α β _inst_1 _inst_2) _inst_1 (@prod.fst.{0 0} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg)
⊢ @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or (@roption.dom.{0} nat (nat.partrec.code.eval cf a))
                    (@roption.dom.{0} nat (nat.partrec.code.eval cg a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n)))
⊢ @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or (@roption.dom.{0} nat (nat.partrec.code.eval cf a))
                    (@roption.dom.{0} nat (nat.partrec.code.eval cg a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30    refine ⟨_, this, λ n, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec (λ (n : nat), @nat.rfind_opt.{0} nat (λ (k : nat), @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat (nat.partrec.code.evaln k cf n) (nat.partrec.code.evaln k cg n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n)))
⊢ @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or (@roption.dom.{0} nat (nat.partrec.code.eval cf a))
                    (@roption.dom.{0} nat (nat.partrec.code.eval cg a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat
⊢ and
    (∀ (x : nat),
       @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
         (@nat.rfind_opt.{0} nat
            (λ (k : nat),
               @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln k cf n)
                 (nat.partrec.code.evaln k cg n))) →
       or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
         (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)))
    (iff
       (@roption.dom.{0} nat
          (@nat.rfind_opt.{0} nat
             (λ (k : nat),
                @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                  nat
                  (nat.partrec.code.evaln k cf n)
                  (nat.partrec.code.evaln k cg n))))
       (or (@roption.dom.{0} nat (nat.partrec.code.eval cf n)) (@roption.dom.{0} nat (nat.partrec.code.eval cg n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31    suffices, refine ⟨this,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat
⊢ and
    (∀ (x : nat),
       @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
         (@nat.rfind_opt.{0} nat
            (λ (k : nat),
               @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln k cf n)
                 (nat.partrec.code.evaln k cg n))) →
       or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
         (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)))
    (iff
       (@roption.dom.{0} nat
          (@nat.rfind_opt.{0} nat
             (λ (k : nat),
                @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                  nat
                  (nat.partrec.code.evaln k cf n)
                  (nat.partrec.code.evaln k cg n))))
       (or (@roption.dom.{0} nat (nat.partrec.code.eval cf n)) (@roption.dom.{0} nat (nat.partrec.code.eval cg n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this : ?m_1
⊢ and
    (∀ (x : nat),
       @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
         (@nat.rfind_opt.{0} nat
            (λ (k : nat),
               @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln k cf n)
                 (nat.partrec.code.evaln k cg n))) →
       or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
         (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)))
    (iff
       (@roption.dom.{0} nat
          (@nat.rfind_opt.{0} nat
             (λ (k : nat),
                @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                  nat
                  (nat.partrec.code.evaln k cf n)
                  (nat.partrec.code.evaln k cg n))))
       (or (@roption.dom.{0} nat (nat.partrec.code.eval cf n)) (@roption.dom.{0} nat (nat.partrec.code.eval cg n))))

cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat
⊢ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32      ⟨λ h, (this _ ⟨h, rfl⟩).imp Exists.fst Exists.fst, _⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='Exists.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 549, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (x : nat), @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (@nat.rfind_opt.{0} nat (λ (k : nat), @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat (nat.partrec.code.evaln k cf n) (nat.partrec.code.evaln k cg n))) → or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n)) (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {b : Prop} {p : b → Prop}, @Exists.{0} b p → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this : ?m_1
⊢ and
    (∀ (x : nat),
       @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
         (@nat.rfind_opt.{0} nat
            (λ (k : nat),
               @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln k cf n)
                 (nat.partrec.code.evaln k cg n))) →
       or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
         (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)))
    (iff
       (@roption.dom.{0} nat
          (@nat.rfind_opt.{0} nat
             (λ (k : nat),
                @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                  nat
                  (nat.partrec.code.evaln k cf n)
                  (nat.partrec.code.evaln k cg n))))
       (or (@roption.dom.{0} nat (nat.partrec.code.eval cf n)) (@roption.dom.{0} nat (nat.partrec.code.eval cg n))))

cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat
⊢ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))
⊢ or (@roption.dom.{0} nat (nat.partrec.code.eval cf n)) (@roption.dom.{0} nat (nat.partrec.code.eval cg n)) →
  @roption.dom.{0} nat
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n)))

cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat
⊢ ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    { intro h, rw nat.rfind_opt_dom,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='nat.rfind_opt_dom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {f : nat → option.{0} α}, iff (@roption.dom.{0} α (@nat.rfind_opt.{0} α f)) (@Exists.{1} nat (λ (n : nat), @Exists.{1} α (λ (a : α), @has_mem.mem.{0 0} α (option.{0} α) (@option.has_mem.{0} α) a (f n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))
⊢ or (@roption.dom.{0} nat (nat.partrec.code.eval cf n)) (@roption.dom.{0} nat (nat.partrec.code.eval cg n)) →
  @roption.dom.{0} nat
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n)))

cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat
⊢ ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))
⊢ or (@roption.dom.{0} nat (nat.partrec.code.eval cf n)) (@roption.dom.{0} nat (nat.partrec.code.eval cg n)) →
  @roption.dom.{0} nat
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
h : or (@roption.dom.{0} nat (nat.partrec.code.eval cf n)) (@roption.dom.{0} nat (nat.partrec.code.eval cg n))
⊢ @roption.dom.{0} nat
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
h : or (@roption.dom.{0} nat (nat.partrec.code.eval cf n)) (@roption.dom.{0} nat (nat.partrec.code.eval cg n))
⊢ @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{1} nat
         (λ (a : nat),
            @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
              (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln n_1 cf n)
                 (nat.partrec.code.evaln n_1 cg n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34      simp [dom_iff_mem, code.evaln_complete] at h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='roption.dom_iff_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec.code.evaln_complete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 641, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {o : roption.{?l_1} α}, iff (@roption.dom.{?l_1} α o) (@Exists.{?l_1+1} α (λ (y : α), @has_mem.mem.{?l_1 ?l_1} α (roption.{?l_1} α) (@roption.has_mem.{?l_1} α) y o))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : nat.partrec.code} {n x : nat}, iff (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval c n)) (@Exists.{1} nat (λ (k : nat), @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) x (nat.partrec.code.evaln k c n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
h : or (@roption.dom.{0} nat (nat.partrec.code.eval cf n)) (@roption.dom.{0} nat (nat.partrec.code.eval cg n))
⊢ @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{1} nat
         (λ (a : nat),
            @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
              (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln n_1 cf n)
                 (nat.partrec.code.evaln n_1 cg n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
h :
  or
    (@Exists.{1} nat
       (λ (y : nat),
          @Exists.{1} nat
            (λ (k : nat), @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat y))))
    (@Exists.{1} nat
       (λ (y : nat),
          @Exists.{1} nat
            (λ (k : nat), @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat y))))
⊢ @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{1} nat
         (λ (a : nat),
            @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
              (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln n_1 cf n)
                 (nat.partrec.code.evaln n_1 cg n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35      rcases h with ⟨x, k, e⟩ | ⟨x, k, e⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='or (@Exists.{1} nat (λ (y : nat), @Exists.{1} nat (λ (k : nat), @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat y)))) (@Exists.{1} nat (λ (y : nat), @Exists.{1} nat (λ (k : nat), @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
h :
  or
    (@Exists.{1} nat
       (λ (y : nat),
          @Exists.{1} nat
            (λ (k : nat), @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat y))))
    (@Exists.{1} nat
       (λ (y : nat),
          @Exists.{1} nat
            (λ (k : nat), @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat y))))
⊢ @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{1} nat
         (λ (a : nat),
            @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
              (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln n_1 cf n)
                 (nat.partrec.code.evaln n_1 cg n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat x)
⊢ @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{1} nat
         (λ (a : nat),
            @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
              (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln n_1 cf n)
                 (nat.partrec.code.evaln n_1 cg n))))

cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{1} nat
         (λ (a : nat),
            @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
              (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln n_1 cf n)
                 (nat.partrec.code.evaln n_1 cg n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36      { refine ⟨k, x, _⟩, simp [e] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat x)
⊢ @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{1} nat
         (λ (a : nat),
            @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
              (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln n_1 cf n)
                 (nat.partrec.code.evaln n_1 cg n))))

cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{1} nat
         (λ (a : nat),
            @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
              (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln n_1 cf n)
                 (nat.partrec.code.evaln n_1 cg n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat x)
⊢ @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{1} nat
         (λ (a : nat),
            @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
              (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln n_1 cf n)
                 (nat.partrec.code.evaln n_1 cg n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat x)
⊢ @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) x
    (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
       (nat.partrec.code.evaln k cf n)
       (nat.partrec.code.evaln k cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{1} nat
         (λ (a : nat),
            @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
              (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln n_1 cf n)
                 (nat.partrec.code.evaln n_1 cg n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37      { refine ⟨k, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{1} nat
         (λ (a : nat),
            @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
              (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0})
                 nat
                 (nat.partrec.code.evaln n_1 cf n)
                 (nat.partrec.code.evaln n_1 cg n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ @Exists.{1} nat
    (λ (a : nat),
       @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
         (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38        cases cf.evaln k n with y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='cf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 543, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ @Exists.{1} nat
    (λ (a : nat),
       @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
         (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ @Exists.{1} nat
    (λ (a : nat),
       @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
         (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (@option.none.{0} nat)
            (nat.partrec.code.evaln k cg n)))

case option.some
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x),
y : nat
⊢ @Exists.{1} nat
    (λ (a : nat),
       @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
         (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (@option.some.{0} nat y)
            (nat.partrec.code.evaln k cg n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39        { exact ⟨x, by simp [e]⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ @Exists.{1} nat
    (λ (a : nat),
       @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
         (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (@option.none.{0} nat)
            (nat.partrec.code.evaln k cg n)))

case option.some
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x),
y : nat
⊢ @Exists.{1} nat
    (λ (a : nat),
       @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
         (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (@option.some.{0} nat y)
            (nat.partrec.code.evaln k cg n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ @Exists.{1} nat
    (λ (a : nat),
       @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
         (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (@option.none.{0} nat)
            (nat.partrec.code.evaln k cg n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) x
    (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
       (@option.none.{0} nat)
       (nat.partrec.code.evaln k cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ @Exists.{1} nat
    (λ (a : nat),
       @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
         (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (@option.none.{0} nat)
            (nat.partrec.code.evaln k cg n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x),
y : nat
⊢ @Exists.{1} nat
    (λ (a : nat),
       @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
         (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (@option.some.{0} nat y)
            (nat.partrec.code.evaln k cg n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40        { exact ⟨y, by simp⟩ } } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x),
y : nat
⊢ @Exists.{1} nat
    (λ (a : nat),
       @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
         (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (@option.some.{0} nat y)
            (nat.partrec.code.evaln k cg n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x),
y : nat
⊢ @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) y
    (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
       (@option.some.{0} nat y)
       (nat.partrec.code.evaln k cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat,
this :
  ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n)),
x k : nat,
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x),
y : nat
⊢ @Exists.{1} nat
    (λ (a : nat),
       @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) a
         (@has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (@option.some.{0} nat y)
            (nat.partrec.code.evaln k cg n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat
⊢ ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    { intros x h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n : nat
⊢ ∀ (x : nat),
    @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
      (@nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))) →
    or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
      (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n)))
⊢ or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42      rcases nat.rfind_opt_spec h with ⟨k, e⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='nat.rfind_opt_spec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 106, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {f : nat → option.{0} α} {a : α}, @has_mem.mem.{0 0} α (roption.{0} α) (@roption.has_mem.{0} α) a (@nat.rfind_opt.{0} α f) → @Exists.{1} nat (λ (n : nat), @has_mem.mem.{0 0} α (option.{0} α) (@option.has_mem.{0} α) a (f n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (@nat.rfind_opt.{0} nat (λ (k : nat), @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat (nat.partrec.code.evaln k cf n) (nat.partrec.code.evaln k cg n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n)))
⊢ or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n))),
k : nat,
e :
  @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) x
    ((λ (k : nat),
        @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
          (nat.partrec.code.evaln k cf n)
          (nat.partrec.code.evaln k cg n))
       k)
⊢ or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43      revert e,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`revert h₁ ... hₙ` applies to any goal with hypotheses `h₁` ... `hₙ`. It moves the hypotheses and their dependencies to the target of the goal. This tactic is the inverse of `intro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='revert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n))),
k : nat,
e :
  @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) x
    ((λ (k : nat),
        @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
          (nat.partrec.code.evaln k cf n)
          (nat.partrec.code.evaln k cg n))
       k)
⊢ or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n))),
k : nat
⊢ @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) x
    ((λ (k : nat),
        @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
          (nat.partrec.code.evaln k cf n)
          (nat.partrec.code.evaln k cg n))
       k) →
  or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44      simp; cases e&#x27; : cf.evaln k n with y; simp; intro,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='cf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 543, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n))),
k : nat
⊢ @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) x
    ((λ (k : nat),
        @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
          (nat.partrec.code.evaln k cf n)
          (nat.partrec.code.evaln k cg n))
       k) →
  or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n))),
k : nat,
e&#x27; : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.none.{0} nat),
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))

case option.some
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n))),
k y : nat,
e&#x27; : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat y),
e : @eq.{1} nat y x
⊢ or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45      { exact or.inr (code.evaln_sound e) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='or.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec.code.evaln_sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 604, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, b → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {k : nat} {c : nat.partrec.code} {n x : nat}, @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) x (nat.partrec.code.evaln k c n) → @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval c n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n))),
k : nat,
e&#x27; : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.none.{0} nat),
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))

case option.some
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n))),
k y : nat,
e&#x27; : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat y),
e : @eq.{1} nat y x
⊢ or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n))),
k : nat,
e&#x27; : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.none.{0} nat),
e : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cg n) (@option.some.{0} nat x)
⊢ or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n))),
k y : nat,
e&#x27; : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat y),
e : @eq.{1} nat y x
⊢ or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46      { subst y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n))),
k y : nat,
e&#x27; : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat y),
e : @eq.{1} nat y x
⊢ or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n))),
k : nat,
e&#x27; : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat x)
⊢ or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47          exact or.inl (code.evaln_sound e&#x27;) } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec.code.evaln_sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 604, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {k : nat} {c : nat.partrec.code} {n x : nat}, @has_mem.mem.{0 0} nat (option.{0} nat) (@option.has_mem.{0} nat) x (nat.partrec.code.evaln k c n) → @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval c n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='cf : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval cf),
cg : nat.partrec.code,
hg : nat.partrec (nat.partrec.code.eval cg),
this :
  nat.partrec
    (λ (n : nat),
       @nat.rfind_opt.{0} nat
         (λ (k : nat),
            @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
              (nat.partrec.code.evaln k cf n)
              (nat.partrec.code.evaln k cg n))),
n x : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
    (@nat.rfind_opt.{0} nat
       (λ (k : nat),
          @has_orelse.orelse.{0 0} option.{0} (@alternative.to_has_orelse.{0 0} option.{0} option.alternative.{0}) nat
            (nat.partrec.code.evaln k cf n)
            (nat.partrec.code.evaln k cg n))),
k : nat,
e&#x27; : @eq.{1} (option.{0} nat) (nat.partrec.code.evaln k cf n) (@option.some.{0} nat x)
⊢ or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cf n))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (nat.partrec.code.eval cg n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  end nat.partrec</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  namespace partrec</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  variables {α : Type*} {β : Type*} {γ : Type*} {σ : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  variables [primcodable α] [primcodable β] [primcodable γ] [primcodable σ]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='primcodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='primcodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='primcodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='primcodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_4 → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A `primcodable` type is an `encodable` type for which
 the encode/decode functions are primitive recursive.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A `primcodable` type is an `encodable` type for which
 the encode/decode functions are primitive recursive.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A `primcodable` type is an `encodable` type for which
 the encode/decode functions are primitive recursive.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A `primcodable` type is an `encodable` type for which
 the encode/decode functions are primitive recursive.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  open computable roption nat.partrec (code) nat.partrec.code</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  theorem merge&#x27; {f g : α →. σ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_4 → Type (max u_1 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59    (hf : partrec f) (hg : partrec g) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    ∃ k : α →. σ, partrec k ∧ ∀ a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u_1 u_4)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_4 → Type (max u_1 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u_1 u_4)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61      (∀ x ∈ k a, x ∈ f a ∨ x ∈ g a) ∧</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62      ((k a).dom ↔ (f a).dom ∨ (g a).dom) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.dom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.dom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.dom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4}, roption.{u_4} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4}, roption.{u_4} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4}, roption.{u_4} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  let ⟨k, hk, H⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} (pfun.{0 0} nat nat) (λ (h : pfun.{0 0} nat nat), and (nat.partrec h) (∀ (a : nat), and (∀ (x : nat), @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) → or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (f a))) a)) (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (g a))) a))) (iff (@roption.dom.{0} nat (h a)) (or (@roption.dom.{0} nat ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (f a))) a)) (@roption.dom.{0} nat ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (g a))) a)))))) → @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ) (λ (k : pfun.{u_1 u_4} α σ), and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k) (∀ (a : α), and (∀ (x : σ), @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) → or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)) (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))) (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64    nat.partrec.merge&#x27; (bind_decode2_iff.1 hf) (bind_decode2_iff.1 hg) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec.merge&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='partrec.bind_decode2_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='partrec.bind_decode2_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 16, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 470, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 470, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {f g : pfun.{0 0} nat nat}, nat.partrec f → nat.partrec g → @Exists.{1} (pfun.{0 0} nat nat) (λ (h : pfun.{0 0} nat nat), and (nat.partrec h) (∀ (a : nat), and (∀ (x : nat), @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) → or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (f a)) (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (g a))) (iff (@roption.dom.{0} nat (h a)) (or (@roption.dom.{0} nat (f a)) (@roption.dom.{0} nat (g a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{u_4} σ] {f : pfun.{u_1 u_4} α σ}, iff (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 f) (nat.partrec (λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@partrec.{u_1 u_4} α σ _inst_1 _inst_4 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{u_4} σ] {f : pfun.{u_1 u_4} α σ}, iff (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 f) (nat.partrec (λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@partrec.{u_1 u_4} α σ _inst_1 _inst_4 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a))))
⊢ @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66    let k&#x27; := λ a, (k (encode a)).bind (λ n, decode σ n),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='encodable.encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='encodable.decode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : encodable.{u_1} α], α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_4) [c : encodable.{u_4} α], nat → option.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a))))
⊢ @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : ?m_1 → roption.{u_4} σ :=
  λ (a : ?m_1),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{?l_2} ?m_1 ?m_3[a] a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n))
⊢ @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))))

α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a))))
⊢ Type ?l_1

α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
a : ?m_1
⊢ encodable.{?l_2} ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67    refine ⟨k&#x27;, ((nat_iff.2 hk).comp computable.encode).bind</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='k&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='partrec.nat_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='computable.encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 369, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 298, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → roption.{u_4} σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {f : pfun.{0 0} nat nat}, iff (@partrec.{0 0} nat nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) f) (nat.partrec f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec k'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : primcodable.{u_1} α], @computable.{u_1 0} α nat _inst_1 (@primcodable.of_denumerable.{0} nat denumerable.nat) (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : ?m_1 → roption.{u_4} σ :=
  λ (a : ?m_1),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{?l_2} ?m_1 ?m_3[a] a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n))
⊢ @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))))

α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a))))
⊢ Type ?l_1

α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
a : ?m_1
⊢ encodable.{?l_2} ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68      (computable.decode.of_option.comp snd).to₂, λ a, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='computable.decode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 301, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_4} [_inst_1 : primcodable.{u_4} α], @computable.{0 u_4} nat (option.{u_4} α) (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.option.{u_4} α _inst_1) (@encodable.decode.{u_4} α (@primcodable.to_encodable.{u_4} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{0} β], @computable.{u_1 0} (prod.{u_1 0} α β) β (@primcodable.prod.{u_1 0} α β _inst_1 _inst_2) _inst_2 (@prod.snd.{u_1 0} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : ?m_1 → roption.{u_4} σ :=
  λ (a : ?m_1),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{?l_2} ?m_1 ?m_3[a] a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n))
⊢ @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))))

α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a))))
⊢ Type ?l_1

α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
a : ?m_1
⊢ encodable.{?l_2} ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α
⊢ and
    (∀ (x : σ),
       @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
       or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
         (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
    (iff (@roption.dom.{u_4} σ (k&#x27; a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    suffices, refine ⟨this,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α
⊢ and
    (∀ (x : σ),
       @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
       or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
         (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
    (iff (@roption.dom.{u_4} σ (k&#x27; a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this : ?m_1
⊢ and
    (∀ (x : σ),
       @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
       or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
         (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
    (iff (@roption.dom.{u_4} σ (k&#x27; a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))

α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α
⊢ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70      ⟨λ h, (this _ ⟨h, rfl⟩).imp Exists.fst Exists.fst, _⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='Exists.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 549, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (x : σ), @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) → or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)) (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {a : α}, @eq.{u_4+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {b : Prop} {p : b → Prop}, @Exists.{0} b p → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this : ?m_1
⊢ and
    (∀ (x : σ),
       @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
       or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
         (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
    (iff (@roption.dom.{u_4} σ (k&#x27; a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))

α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α
⊢ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))
⊢ or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)) → @roption.dom.{u_4} σ (k&#x27; a)

α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α
⊢ ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71    { intro h, simp [k&#x27;],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='k&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → roption.{u_4} σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))
⊢ or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)) → @roption.dom.{u_4} σ (k&#x27; a)

α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α
⊢ ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))
⊢ or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)) → @roption.dom.{u_4} σ (k&#x27; a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))
⊢ @roption.dom.{u_4} σ (k&#x27; a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))
⊢ @Exists.{0} (@roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))
    (λ (h : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))),
       @roption.dom.{u_4} σ
         (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
            (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
               (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
            (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
               (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
                  h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72      have hk : (k (encode a)).dom :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='encodable.encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : encodable.{u_1} α], α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))
⊢ @Exists.{0} (@roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))
    (λ (h : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))),
       @roption.dom.{u_4} σ
         (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
            (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
               (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
            (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
               (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
                  h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73        (H _).2.2 (by simpa [encodek2] using h),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='encodable.encodek2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (a : nat), and (∀ (x : nat), @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) → or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (f a))) a)) (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (g a))) a))) (iff (@roption.dom.{0} nat (k a)) (or (@roption.dom.{0} nat ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (f a))) a)) (@roption.dom.{0} nat ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (g a))) a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : encodable.{?l_1} α] (a : α), @eq.{?l_1+1} (option.{?l_1} α) (@encodable.decode2.{?l_1} α _inst_1 (@encodable.encode.{?l_1} α _inst_1 a)) (@option.some.{?l_1} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))
⊢ @Exists.{0} (@roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))
    (λ (h : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))),
       @roption.dom.{u_4} σ
         (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
            (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
               (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
            (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
               (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
                  h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))
⊢ or
    (@roption.dom.{0} nat
       ((λ (n : nat),
           @roption.bind.{u_1 0} α nat
             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
             (λ (a : α),
                @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                  (f a)))
          (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))
    (@roption.dom.{0} nat
       ((λ (n : nat),
           @roption.bind.{u_1 0} α nat
             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
             (λ (a : α),
                @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                  (g a)))
          (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))
⊢ @Exists.{0} (@roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))
    (λ (h : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))),
       @roption.dom.{u_4} σ
         (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
            (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
               (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
            (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
               (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
                  h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)),
hk : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
⊢ @Exists.{0} (@roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))
    (λ (h : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))),
       @roption.dom.{u_4} σ
         (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
            (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
               (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
            (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
               (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
                  h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74      existsi hk,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)),
hk : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
⊢ @Exists.{0} (@roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))
    (λ (h : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))),
       @roption.dom.{u_4} σ
         (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
            (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
               (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
            (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
               (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
                  h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)),
hk : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
⊢ @roption.dom.{u_4} σ
    (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
       (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
          (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
       (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
          (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) hk)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75      cases (H _).1 _ ⟨hk, rfl⟩ with h h;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (a : nat), and (∀ (x : nat), @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) → or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (f a))) a)) (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (g a))) a))) (iff (@roption.dom.{0} nat (k a)) (or (@roption.dom.{0} nat ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (f a))) a)) (@roption.dom.{0} nat ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (g a))) a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)),
hk : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
⊢ @roption.dom.{u_4} σ
    (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
       (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
          (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
       (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
          (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) hk)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76      { simp at h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)),
hk : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
⊢ @roption.dom.{u_4} σ
    (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
       (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
          (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
       (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
          (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) hk)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)),
hk : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat)
    (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) hk)
    ((λ (n : nat),
        @roption.bind.{u_1 0} α nat
          (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
             (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
          (λ (a : α),
             @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
               (f a)))
       (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
⊢ @roption.dom.{u_4} σ
    (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
       (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
          (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
       (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
          (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) hk)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)),
hk : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
h :
  @Exists.{u_1+1} α
    (λ (a_1 : α),
       and
         (@eq.{u_1+1} (option.{u_1} α)
            (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1)
               (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
            (@option.some.{u_1} α a_1))
         (@Exists.{u_4+1} σ
            (λ (a_2 : σ),
               and (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a_2 (f a_1))
                 (@eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_2)
                    (@roption.get.{0} nat
                       (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
                       hk)))))
⊢ @roption.dom.{u_4} σ
    (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
       (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
          (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
       (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
          (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) hk)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77        rcases h with ⟨a&#x27;, ha&#x27;, y, hy, e⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u_1+1} α (λ (a_1 : α), and (@eq.{u_1+1} (option.{u_1} α) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) (@option.some.{u_1} α a_1)) (@Exists.{u_4+1} σ (λ (a_2 : σ), and (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a_2 (f a_1)) (@eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_2) (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) hk)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)),
hk : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
h :
  @Exists.{u_1+1} α
    (λ (a_1 : α),
       and
         (@eq.{u_1+1} (option.{u_1} α)
            (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1)
               (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
            (@option.some.{u_1} α a_1))
         (@Exists.{u_4+1} σ
            (λ (a_2 : σ),
               and (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a_2 (f a_1))
                 (@eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_2)
                    (@roption.get.{0} nat
                       (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
                       hk)))))
⊢ @roption.dom.{u_4} σ
    (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
       (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
          (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
       (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
          (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) hk)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)),
hk : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
a&#x27; : α,
ha&#x27; :
  @eq.{u_1+1} (option.{u_1} α)
    (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1)
       (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
    (@option.some.{u_1} α a&#x27;),
y : σ,
hy : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (f a&#x27;),
e :
  @eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) y)
    (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) hk)
⊢ @roption.dom.{u_4} σ
    (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
       (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
          (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
       (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
          (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) hk)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78        simp [e.symm, encodek] } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='encodable.encodek'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) hk) (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [c : encodable.{?l_1} α] (a : α), @eq.{?l_1+1} (option.{?l_1} α) (@encodable.decode.{?l_1} α c (@encodable.encode.{?l_1} α c a)) (@option.some.{?l_1} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
this :
  ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
h : or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)),
hk : @roption.dom.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
a&#x27; : α,
ha&#x27; :
  @eq.{u_1+1} (option.{u_1} α)
    (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1)
       (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
    (@option.some.{u_1} α a&#x27;),
y : σ,
hy : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (f a&#x27;),
e :
  @eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) y)
    (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) hk)
⊢ @roption.dom.{u_4} σ
    (@coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
       (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
          (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
       (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
          (@roption.get.{0} nat (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)) hk)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α
⊢ ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    { intros x h&#x27;, simp [k&#x27;] at h&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='k&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → roption.{u_4} σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α
⊢ ∀ (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a) →
    or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
      (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x : σ,
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k&#x27; a)
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x : σ,
h&#x27; :
  @Exists.{1} nat
    (λ (a_1 : nat),
       and
         (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a_1
            (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))
         (@eq.{u_4+1} (option.{u_4} σ) (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_1)
            (@option.some.{u_4} σ x)))
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80      rcases h&#x27; with ⟨n, hn, hx⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} nat (λ (a_1 : nat), and (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a_1 (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))) (@eq.{u_4+1} (option.{u_4} σ) (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_1) (@option.some.{u_4} σ x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x : σ,
h&#x27; :
  @Exists.{1} nat
    (λ (a_1 : nat),
       and
         (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a_1
            (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))
         (@eq.{u_4+1} (option.{u_4} σ) (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_1)
            (@option.some.{u_4} σ x)))
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x : σ,
n : nat,
hn :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n
    (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
hx :
  @eq.{u_4+1} (option.{u_4} σ) (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)
    (@option.some.{u_4} σ x)
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81      have := (H _).1 _ hn,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (a : nat), and (∀ (x : nat), @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) → or (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (f a))) a)) (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (g a))) a))) (iff (@roption.dom.{0} nat (k a)) (or (@roption.dom.{0} nat ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (f a))) a)) (@roption.dom.{0} nat ((λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (g a))) a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x : σ,
n : nat,
hn :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n
    (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
hx :
  @eq.{u_4+1} (option.{u_4} σ) (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)
    (@option.some.{u_4} σ x)
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x : σ,
n : nat,
hn :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n
    (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
hx :
  @eq.{u_4+1} (option.{u_4} σ) (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)
    (@option.some.{u_4} σ x),
this :
  or
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n
       ((λ (n : nat),
           @roption.bind.{u_1 0} α nat
             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
             (λ (a : α),
                @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                  (f a)))
          (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n
       ((λ (n : nat),
           @roption.bind.{u_1 0} α nat
             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
             (λ (a : α),
                @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                  (g a)))
          (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82      simp [mem_decode2, encode_injective.eq_iff] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='encodable.mem_decode2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : encodable.{?l_1} α] {n : nat} {a : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (option.{?l_1} α) (@option.has_mem.{?l_1} α) a (@encodable.decode2.{?l_1} α _inst_1 n)) (@eq.{1} nat (@encodable.encode.{?l_1} α _inst_1 a) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='iff (@eq.{1} nat (@encodable.encode.{?l_1} ?m_2 ?m_3 ?m_4) (@encodable.encode.{?l_1} ?m_2 ?m_3 ?m_5)) (@eq.{?l_1+1} ?m_2 ?m_4 ?m_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x : σ,
n : nat,
hn :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n
    (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
hx :
  @eq.{u_4+1} (option.{u_4} σ) (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)
    (@option.some.{u_4} σ x),
this :
  or
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n
       ((λ (n : nat),
           @roption.bind.{u_1 0} α nat
             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
             (λ (a : α),
                @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                  (f a)))
          (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n
       ((λ (n : nat),
           @roption.bind.{u_1 0} α nat
             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
             (λ (a : α),
                @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                  (g a)))
          (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)))
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x : σ,
n : nat,
hn :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n
    (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
hx :
  @eq.{u_4+1} (option.{u_4} σ) (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)
    (@option.some.{u_4} σ x),
this :
  or
    (@Exists.{u_4+1} σ
       (λ (a_1 : σ),
          and (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a_1 (f a))
            (@eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_1) n)))
    (@Exists.{u_4+1} σ
       (λ (a_1 : σ),
          and (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a_1 (g a))
            (@eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_1) n)))
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83      cases this with h h;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='or (@Exists.{u_4+1} σ (λ (a_1 : σ), and (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a_1 (f a)) (@eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_1) n))) (@Exists.{u_4+1} σ (λ (a_1 : σ), and (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a_1 (g a)) (@eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_1) n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x : σ,
n : nat,
hn :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n
    (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
hx :
  @eq.{u_4+1} (option.{u_4} σ) (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)
    (@option.some.{u_4} σ x),
this :
  or
    (@Exists.{u_4+1} σ
       (λ (a_1 : σ),
          and (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a_1 (f a))
            (@eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_1) n)))
    (@Exists.{u_4+1} σ
       (λ (a_1 : σ),
          and (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a_1 (g a))
            (@eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_1) n)))
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84      { rcases h with ⟨a&#x27;, ha, rfl⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u_4+1} σ (λ (a_1 : σ), and (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a_1 (f a)) (@eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_1) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x : σ,
n : nat,
hn :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n
    (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
hx :
  @eq.{u_4+1} (option.{u_4} σ) (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)
    (@option.some.{u_4} σ x),
this :
  or
    (@Exists.{u_4+1} σ
       (λ (a_1 : σ),
          and (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a_1 (f a))
            (@eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_1) n)))
    (@Exists.{u_4+1} σ
       (λ (a_1 : σ),
          and (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a_1 (g a))
            (@eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_1) n)))
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x : σ,
n : nat,
hn :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n
    (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
hx :
  @eq.{u_4+1} (option.{u_4} σ) (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)
    (@option.some.{u_4} σ x),
h :
  @Exists.{u_4+1} σ
    (λ (a_1 : σ),
       and (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a_1 (f a))
         (@eq.{1} nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a_1) n))
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x a&#x27; : σ,
ha : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a&#x27; (f a),
hn :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat)
    (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a&#x27;)
    (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
hx :
  @eq.{u_4+1} (option.{u_4} σ)
    (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
       (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a&#x27;))
    (@option.some.{u_4} σ x)
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85        simp [encodek] at hx, subst a&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='encodable.encodek'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [c : encodable.{?l_1} α] (a : α), @eq.{?l_1+1} (option.{?l_1} α) (@encodable.decode.{?l_1} α c (@encodable.encode.{?l_1} α c a)) (@option.some.{?l_1} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x a&#x27; : σ,
ha : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a&#x27; (f a),
hn :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat)
    (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a&#x27;)
    (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
hx :
  @eq.{u_4+1} (option.{u_4} σ)
    (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
       (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a&#x27;))
    (@option.some.{u_4} σ x)
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x a&#x27; : σ,
ha : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) a&#x27; (f a),
hn :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat)
    (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) a&#x27;)
    (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a)),
hx : @eq.{u_4+1} σ a&#x27; x
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x : σ,
ha : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a),
hn :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat)
    (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) x)
    (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86        simp [ha] } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} (pfun.{0 0} nat nat)
    (λ (h : pfun.{0 0} nat nat),
       and (nat.partrec h)
         (∀ (a : nat),
            and
              (∀ (x : nat),
                 @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (h a) →
                 or
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (f a)))
                         a))
                   (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
                      ((λ (n : nat),
                          @roption.bind.{u_1 0} α nat
                            (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                               (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                  (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                     (@roption.has_coe.{u_1} α)))
                               (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                            (λ (a : α),
                               @roption.map.{u_4 0} σ nat
                                 (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                 (g a)))
                         a)))
              (iff (@roption.dom.{0} nat (h a))
                 (or
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (f a)))
                          a))
                    (@roption.dom.{0} nat
                       ((λ (n : nat),
                           @roption.bind.{u_1 0} α nat
                             (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                   (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                                      (@roption.has_coe.{u_1} α)))
                                (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                             (λ (a : α),
                                @roption.map.{u_4 0} σ nat
                                  (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                                  (g a)))
                          a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))),
k : pfun.{0 0} nat nat,
hk : nat.partrec k,
H :
  ∀ (a : nat),
    and
      (∀ (x : nat),
         @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x (k a) →
         or
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (f a)))
                 a))
           (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) x
              ((λ (n : nat),
                  @roption.bind.{u_1 0} α nat
                    (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                       (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                          (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                       (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                    (λ (a : α),
                       @roption.map.{u_4 0} σ nat
                         (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                         (g a)))
                 a)))
      (iff (@roption.dom.{0} nat (k a))
         (or
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (f a)))
                  a))
            (@roption.dom.{0} nat
               ((λ (n : nat),
                   @roption.bind.{u_1 0} α nat
                     (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                        (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                           (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                        (@encodable.decode2.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
                     (λ (a : α),
                        @roption.map.{u_4 0} σ nat
                          (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                          (g a)))
                  a)))),
k&#x27; : α → roption.{u_4} σ :=
  λ (a : α),
    @roption.bind.{0 u_4} nat σ (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
      (λ (n : nat),
         @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
           (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
              (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
           (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) n)),
a : α,
x : σ,
ha : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a),
hn :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat)
    (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4) x)
    (k (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
⊢ or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  theorem merge {f g : α →. σ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_4 → Type (max u_1 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90    (hf : partrec f) (hg : partrec g)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91    (H : ∀ a (x ∈ f a) (y ∈ g a), x = y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92    ∃ k : α →. σ, partrec k ∧ ∀ a x, x ∈ k a ↔ x ∈ f a ∨ x ∈ g a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u_1 u_4)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_4 → Type (max u_1 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u_1 u_4)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  let ⟨k, hk, K⟩ := merge&#x27; hf hg in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='partrec.merge&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 58, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ) (λ (k : pfun.{u_1 u_4} α σ), and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k) (∀ (a : α), and (∀ (x : σ), @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) → or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)) (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))) (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) → @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ) (λ (k : pfun.{u_1 u_4} α σ), and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k) (∀ (a : α) (x : σ), iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a)) (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)) (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (a : α), and (∀ (x : σ), @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) → or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)) (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))) (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{u_4} σ] {f g : pfun.{u_1 u_4} α σ}, @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f → @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g → @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ) (λ (k : pfun.{u_1 u_4} α σ), and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k) (∀ (a : α), and (∀ (x : σ), @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) → or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)) (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))) (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@partrec.{u_1 u_4} α σ _inst_1 _inst_4 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@partrec.{u_1 u_4} α σ _inst_1 _inst_4 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  ⟨k, hk, λ a x, ⟨(K _).1 _, λ h, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='and.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {a b : Prop}, and a b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)) (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
h :
  or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))
⊢ @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    have : (k a).dom := (K _).2.2 (h.imp Exists.fst Exists.fst),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='Exists.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 549, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (a : α), and (∀ (x : σ), @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) → or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)) (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))) (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)) (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {b : Prop} {p : b → Prop}, @Exists.{0} b p → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
h :
  or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))
⊢ @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
h :
  or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
this : @roption.dom.{u_4} σ (k a)
⊢ @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96    refine ⟨this, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@roption.dom.{u_4} σ (k a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
h :
  or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
this : @roption.dom.{u_4} σ (k a)
⊢ @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
h :
  or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
this : @roption.dom.{u_4} σ (k a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97    cases h with h h; cases (K _).1 _ ⟨this, rfl⟩ with h&#x27; h&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)) (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (a : α), and (∀ (x : σ), @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) → or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)) (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))) (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@roption.dom.{u_4} σ (k a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {a : α}, @eq.{u_4+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
h :
  or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
    (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)),
this : @roption.dom.{u_4} σ (k a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (f a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x

case or.inr
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x

case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (f a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x

case or.inr
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98    { exact mem_unique h&#x27; h },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='roption.mem_unique'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4}, @relator.left_unique.{u_4 u_4} α (roption.{u_4} α) (@has_mem.mem.{u_4 u_4} α (roption.{u_4} α) (@roption.has_mem.{u_4} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (f a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x

case or.inr
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x

case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (f a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x

case or.inr
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (f a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inr
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x

case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (f a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x

case or.inr
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99    { exact (H _ _ h _ h&#x27;).symm },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (a : α) (x : σ), @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) → ∀ (y : σ), @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inr
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x

case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (f a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x

case or.inr
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (f a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x

case or.inr
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    { exact H _ _ h&#x27; _ h },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : α) (x : σ), @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) → ∀ (y : σ), @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (f a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x

case or.inr
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (f a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101    { exact mem_unique h&#x27; h }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='roption.mem_unique'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4}, @relator.left_unique.{u_4 u_4} α (roption.{u_4} α) (@has_mem.mem.{u_4 u_4} α (roption.{u_4} α) (@roption.has_mem.{u_4} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
f g : pfun.{u_1 u_4} α σ,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
H :
  ∀ (a : α) (x : σ),
    @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a) →
    ∀ (y : σ),
      @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) y (g a) → @eq.{u_4+1} σ x y,
_let_match :
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α),
            and
              (∀ (x : σ),
                 @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
                 or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                   (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
              (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))))) →
  @Exists.{(max (u_1+1) (u_4+1))} (pfun.{u_1 u_4} α σ)
    (λ (k : pfun.{u_1 u_4} α σ),
       and (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 k)
         (∀ (a : α) (x : σ),
            iff (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a))
              (or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
                 (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a))))),
k : pfun.{u_1 u_4} α σ,
hk : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 k,
K :
  ∀ (a : α),
    and
      (∀ (x : σ),
         @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (k a) →
         or (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (f a))
           (@has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a)))
      (iff (@roption.dom.{u_4} σ (k a)) (or (@roption.dom.{u_4} σ (f a)) (@roption.dom.{u_4} σ (g a)))),
a : α,
x : σ,
this : @roption.dom.{u_4} σ (k a),
h : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) x (g a),
h&#x27; : @has_mem.mem.{u_4 u_4} σ (roption.{u_4} σ) (@roption.has_mem.{u_4} σ) (@roption.get.{u_4} σ (k a) this) (g a)
⊢ @eq.{u_4+1} σ (@roption.get.{u_4} σ (k a) this) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  end⟩⟩</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  theorem cond {c : α → bool} {f : α →. σ} {g : α →. σ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_4 → Type (max u_1 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_4 → Type (max u_1 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105    (hc : computable c) (hf : partrec f) (hg : partrec g) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='computable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 220, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], (α → σ) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106    partrec (λ a, cond (c a) (f a) (g a)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cond'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/bool/basic.lean&#x27;, &#x27;line&#x27;: 7, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {a : Type u_4}, bool → a → a → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pfun.{u_1 u_4} α σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  let ⟨cf, ef⟩ := exists_code.1 hf,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec.code.exists_code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} nat.partrec.code (λ (c : nat.partrec.code), @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c) (λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (f a)))) → @partrec.{u_1 u_4} α σ _inst_1 _inst_4 (λ (a : α), @cond.{u_4} (roption.{u_4} σ) (c a) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {f : pfun.{0 0} nat nat}, iff (nat.partrec f) (@Exists.{1} nat.partrec.code (λ (c : nat.partrec.code), @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@partrec.{u_1 u_4} α σ _inst_1 _inst_4 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108      ⟨cg, eg⟩ := exists_code.1 hg in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='cg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec.code.exists_code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {f : pfun.{0 0} nat nat}, iff (nat.partrec f) (@Exists.{1} nat.partrec.code (λ (c : nat.partrec.code), @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@partrec.{u_1 u_4} α σ _inst_1 _inst_4 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  ((eval_part.comp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec.code.eval_part'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='partrec₂.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 887, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 388, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@partrec₂.{0 0 0} nat.partrec.code nat nat (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable) (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) nat.partrec.code.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β γ σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{0} β] [_inst_3 : primcodable.{0} γ] [_inst_5 : primcodable.{0} σ] {f : β → pfun.{0 0} γ σ} {g : α → β} {h : α → γ}, @partrec₂.{0 0 0} β γ σ _inst_2 _inst_3 _inst_5 f → @computable.{u_1 0} α β _inst_1 _inst_2 g → @computable.{u_1 0} α γ _inst_1 _inst_3 h → @partrec.{u_1 0} α σ _inst_1 _inst_5 (λ (a : α), f (g a) (h a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110      (computable.cond hc (const cf) (const cg)) computable.id).bind</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='computable.cond'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='computable.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='computable.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='partrec.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 533, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 259, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 337, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{0} σ] {c : α → bool} {f g : α → σ}, @computable.{u_1 0} α bool _inst_1 primcodable.bool c → @computable.{u_1 0} α σ _inst_1 _inst_4 f → @computable.{u_1 0} α σ _inst_1 _inst_4 g → @computable.{u_1 0} α σ _inst_1 _inst_4 (λ (a : α), @cond.{0} σ (c a) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@computable.{u_1 0} α bool _inst_1 primcodable.bool c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{0} σ] (s : σ), @computable.{u_1 0} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{0} σ] (s : σ), @computable.{u_1 0} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : primcodable.{u_1} α], @computable.{u_1 u_1} α α _inst_1 _inst_1 (@id.{u_1+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{0} β] [_inst_4 : primcodable.{u_4} σ] {f : pfun.{u_1 0} α β} {g : α → pfun.{0 u_4} β σ}, @partrec.{u_1 0} α β _inst_1 _inst_2 f → @partrec₂.{u_1 0 u_4} α β σ _inst_1 _inst_2 _inst_4 g → @partrec.{u_1 u_4} α σ _inst_1 _inst_4 (λ (a : α), @roption.bind.{0 u_4} β σ (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    ((@computable.decode σ _).comp snd).of_option.to₂).of_eq $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='computable.decode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='computable.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.of_option'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='partrec.to₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='partrec.of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 301, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 348, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_4} [_inst_1 : primcodable.{u_4} α], @computable.{0 u_4} nat (option.{u_4} α) (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.option.{u_4} α _inst_1) (@encodable.decode.{u_4} α (@primcodable.to_encodable.{u_4} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {β : Type} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{0} β] [_inst_4 : primcodable.{u_4} σ] {f : β → σ} {g : α → β}, @computable.{0 u_4} β σ _inst_2 _inst_4 f → @computable.{u_1 0} α β _inst_1 _inst_2 g → @computable.{u_1 u_4} α σ _inst_1 _inst_4 (λ (a : α), f (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {β : Type} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{0} β], @computable.{u_1 0} (prod.{u_1 0} α β) β (@primcodable.prod.{u_1 0} α β _inst_1 _inst_2) _inst_2 (@prod.snd.{u_1 0} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_4} β] {f : α → option.{u_4} β}, @computable.{u_1 u_4} α (option.{u_4} β) _inst_1 (@primcodable.option.{u_4} β _inst_2) f → @partrec.{u_1 u_4} α β _inst_1 _inst_2 (λ (a : α), @coe.{u_4+1 u_4+1} (option.{u_4} β) (roption.{u_4} β) (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} β) (roption.{u_4} β) (@coe_base.{u_4+1 u_4+1} (option.{u_4} β) (roption.{u_4} β) (@roption.has_coe.{u_4} β))) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{0} β] [_inst_4 : primcodable.{u_4} σ] {f : pfun.{u_1 u_4} (prod.{u_1 0} α β) σ}, @partrec.{u_1 u_4} (prod.{u_1 0} α β) σ (@primcodable.prod.{u_1 0} α β _inst_1 _inst_2) _inst_4 f → @partrec₂.{u_1 0 u_4} α β σ _inst_1 _inst_2 _inst_4 (λ (a : α) (b : β), f (@prod.mk.{u_1 0} α β a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{u_4} σ] {f g : pfun.{u_1 u_4} α σ}, @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f → (∀ (n : α), @eq.{u_4+1} (roption.{u_4} σ) (f n) (g n)) → @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  λ a, by cases c a; simp [ef, eg, encodek]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ef'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='encodable.encodek'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cg) (λ (n : nat), @roption.bind.{u_1 0} α nat (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α))) (@encodable.decode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n)) (λ (a : α), @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)) (g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [c : encodable.{?l_1} α] (a : α), @eq.{?l_1+1} (option.{?l_1} α) (@encodable.decode.{?l_1} α c (@encodable.encode.{?l_1} α c a)) (@option.some.{?l_1} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
c : α → bool,
f g : pfun.{u_1 u_4} α σ,
hc : @computable.{u_1 0} α bool _inst_1 primcodable.bool c,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
         (λ (n : nat),
            @roption.bind.{u_1 0} α nat
              (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                 (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                    (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                 (@encodable.decode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
              (λ (a : α),
                 @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                   (f a)))) →
  @partrec.{u_1 u_4} α σ _inst_1 _inst_4 (λ (a : α), @cond.{u_4} (roption.{u_4} σ) (c a) (f a) (g a)),
cf : nat.partrec.code,
ef :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf)
    (λ (n : nat),
       @roption.bind.{u_1 0} α nat
         (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
            (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
               (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
            (@encodable.decode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
         (λ (a : α),
            @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
              (f a))),
_let_match :
  @Exists.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
         (λ (n : nat),
            @roption.bind.{u_1 0} α nat
              (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                 (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                    (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                 (@encodable.decode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
              (λ (a : α),
                 @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                   (g a)))) →
  @partrec.{u_1 u_4} α σ _inst_1 _inst_4 (λ (a : α), @cond.{u_4} (roption.{u_4} σ) (c a) (f a) (g a)),
cg : nat.partrec.code,
eg :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cg)
    (λ (n : nat),
       @roption.bind.{u_1 0} α nat
         (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
            (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
               (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
            (@encodable.decode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
         (λ (a : α),
            @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
              (g a))),
a : α
⊢ @eq.{u_4+1} (roption.{u_4} σ)
    (@roption.bind.{0 u_4} nat σ
       (nat.partrec.code.eval (@cond.{0} nat.partrec.code (c a) cf cg)
          (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
       (λ (b : nat),
          @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
            (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
               (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
            (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
               (@prod.snd.{u_1 0} α nat (@prod.mk.{u_1 0} α nat a b)))))
    (@cond.{u_4} (roption.{u_4} σ) (c a) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_4 : primcodable.{u_4} σ,
c : α → bool,
f g : pfun.{u_1 u_4} α σ,
hc : @computable.{u_1 0} α bool _inst_1 primcodable.bool c,
hf : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f,
hg : @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g,
_let_match :
  @Exists.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
         (λ (n : nat),
            @roption.bind.{u_1 0} α nat
              (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                 (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                    (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                 (@encodable.decode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
              (λ (a : α),
                 @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                   (f a)))) →
  @partrec.{u_1 u_4} α σ _inst_1 _inst_4 (λ (a : α), @cond.{u_4} (roption.{u_4} σ) (c a) (f a) (g a)),
cf : nat.partrec.code,
ef :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf)
    (λ (n : nat),
       @roption.bind.{u_1 0} α nat
         (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
            (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
               (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
            (@encodable.decode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
         (λ (a : α),
            @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
              (f a))),
_let_match :
  @Exists.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
         (λ (n : nat),
            @roption.bind.{u_1 0} α nat
              (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                 (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
                    (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
                 (@encodable.decode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
              (λ (a : α),
                 @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
                   (g a)))) →
  @partrec.{u_1 u_4} α σ _inst_1 _inst_4 (λ (a : α), @cond.{u_4} (roption.{u_4} σ) (c a) (f a) (g a)),
cg : nat.partrec.code,
eg :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cg)
    (λ (n : nat),
       @roption.bind.{u_1 0} α nat
         (@coe.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
            (@coe_to_lift.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α)
               (@coe_base.{u_1+1 u_1+1} (option.{u_1} α) (roption.{u_1} α) (@roption.has_coe.{u_1} α)))
            (@encodable.decode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) n))
         (λ (a : α),
            @roption.map.{u_4 0} σ nat (@encodable.encode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4))
              (g a))),
a : α
⊢ @eq.{u_4+1} (roption.{u_4} σ)
    (@roption.bind.{0 u_4} nat σ
       (nat.partrec.code.eval (@cond.{0} nat.partrec.code (c a) cf cg)
          (@encodable.encode.{u_1} α (@primcodable.to_encodable.{u_1} α _inst_1) a))
       (λ (b : nat),
          @coe.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
            (@coe_to_lift.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ)
               (@coe_base.{u_4+1 u_4+1} (option.{u_4} σ) (roption.{u_4} σ) (@roption.has_coe.{u_4} σ)))
            (@encodable.decode.{u_4} σ (@primcodable.to_encodable.{u_4} σ _inst_4)
               (@prod.snd.{u_1 0} α nat (@prod.mk.{u_1 0} α nat a b)))))
    (@cond.{u_4} (roption.{u_4} σ) (c a) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  theorem sum_cases</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    {f : α → β ⊕ γ} {g : α → β →. σ} {h : α → γ →. σ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_4 → Type (max u_2 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3 → Type u_4 → Type (max u_3 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116    (hf : computable f) (hg : partrec₂ g) (hh : partrec₂ h) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='computable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='partrec₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='partrec₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 220, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], (α → σ) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → sum.{u_2 u_3} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {σ : Type u_3} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} β] [_inst_3 : primcodable.{u_3} σ], (α → pfun.{u_2 u_3} β σ) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → pfun.{u_2 u_4} β σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {σ : Type u_3} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} β] [_inst_3 : primcodable.{u_3} σ], (α → pfun.{u_2 u_3} β σ) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → pfun.{u_3 u_4} γ σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117    @partrec _ σ _ _ (λ a, sum.cases_on (f a) (g a) (h a)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sum.cases_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} {C : sum.{u v} α β → Sort l} (n : sum.{u v} α β), (Π (val : α), C (@sum.inl.{u v} α β val)) → (Π (val : β), C (@sum.inr.{u v} α β val)) → C n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → sum.{u_2 u_3} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → pfun.{u_2 u_4} β σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → pfun.{u_3 u_4} γ σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  option_some_iff.1 $ (cond</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='partrec.option_some_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='partrec.cond'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 604, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 104, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{u_4} σ] {f : pfun.{u_1 u_4} α σ}, iff (@partrec.{u_1 u_4} α (option.{u_4} σ) _inst_1 (@primcodable.option.{u_4} σ _inst_4) (λ (a : α), @roption.map.{u_4 u_4} σ (option.{u_4} σ) (@option.some.{u_4} σ) (f a))) (@partrec.{u_1 u_4} α σ _inst_1 _inst_4 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{u_4} σ] {c : α → bool} {f g : pfun.{u_1 u_4} α σ}, @computable.{u_1 0} α bool _inst_1 primcodable.bool c → @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f → @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g → @partrec.{u_1 u_4} α σ _inst_1 _inst_4 (λ (a : α), @cond.{u_4} (roption.{u_4} σ) (c a) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119    (sum_cases hf (const tt).to₂ (const ff).to₂)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='computable.sum_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.to₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='computable.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.to₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 557, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 256, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 256, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} β] [_inst_3 : primcodable.{u_3} γ] [_inst_4 : primcodable.{0} σ] {f : α → sum.{u_2 u_3} β γ} {g : α → β → σ} {h : α → γ → σ}, @computable.{u_1 (max u_2 u_3)} α (sum.{u_2 u_3} β γ) _inst_1 (@primcodable.sum.{u_2 u_3} β γ _inst_2 _inst_3) f → @computable₂.{u_1 u_2 0} α β σ _inst_1 _inst_2 _inst_4 g → @computable₂.{u_1 u_3 0} α γ σ _inst_1 _inst_3 _inst_4 h → @computable.{u_1 0} α σ _inst_1 _inst_4 (λ (a : α), @sum.cases_on.{1 u_2 u_3} β γ (λ (_x : sum.{u_2 u_3} β γ), σ) (f a) (g a) (h a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@computable.{u_1 (max u_2 u_3)} α (sum.{u_2 u_3} β γ) _inst_1 (@primcodable.sum.{u_2 u_3} β γ _inst_2 _inst_3) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type (max u_1 u_2)} {σ : Type} [_inst_1 : primcodable.{(max u_1 u_2)} α] [_inst_4 : primcodable.{0} σ] (s : σ), @computable.{(max u_1 u_2) 0} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} β] [_inst_4 : primcodable.{0} σ] {f : prod.{u_1 u_2} α β → σ}, @computable.{(max u_1 u_2) 0} (prod.{u_1 u_2} α β) σ (@primcodable.prod.{u_1 u_2} α β _inst_1 _inst_2) _inst_4 f → @computable₂.{u_1 u_2 0} α β σ _inst_1 _inst_2 _inst_4 (λ (a : α) (b : β), f (@prod.mk.{u_1 u_2} α β a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type (max u_1 u_3)} {σ : Type} [_inst_1 : primcodable.{(max u_1 u_3)} α] [_inst_4 : primcodable.{0} σ] (s : σ), @computable.{(max u_1 u_3) 0} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_3} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_3} β] [_inst_4 : primcodable.{0} σ] {f : prod.{u_1 u_3} α β → σ}, @computable.{(max u_1 u_3) 0} (prod.{u_1 u_3} α β) σ (@primcodable.prod.{u_1 u_3} α β _inst_1 _inst_2) _inst_4 f → @computable₂.{u_1 u_3 0} α β σ _inst_1 _inst_2 _inst_4 (λ (a : α) (b : β), f (@prod.mk.{u_1 u_3} α β a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120    (sum_cases_left hf (option_some_iff.2 hg).to₂ (const option.none).to₂)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='partrec.sum_cases_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='partrec.option_some_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='partrec.to₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='computable.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.to₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 635, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 604, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 348, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 256, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} β] [_inst_3 : primcodable.{u_3} γ] [_inst_4 : primcodable.{u_4} σ] {f : α → sum.{u_2 u_3} β γ} {g : α → pfun.{u_2 u_4} β σ} {h : α → γ → σ}, @computable.{u_1 (max u_2 u_3)} α (sum.{u_2 u_3} β γ) _inst_1 (@primcodable.sum.{u_2 u_3} β γ _inst_2 _inst_3) f → @partrec₂.{u_1 u_2 u_4} α β σ _inst_1 _inst_2 _inst_4 g → @computable₂.{u_1 u_3 u_4} α γ σ _inst_1 _inst_3 _inst_4 h → @partrec.{u_1 u_4} α σ _inst_1 _inst_4 (λ (a : α), @sum.cases_on.{u_4+1 u_2 u_3} β γ (λ (_x : sum.{u_2 u_3} β γ), roption.{u_4} σ) (f a) (g a) (λ (c : γ), @roption.some.{u_4} σ (h a c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@computable.{u_1 (max u_2 u_3)} α (sum.{u_2 u_3} β γ) _inst_1 (@primcodable.sum.{u_2 u_3} β γ _inst_2 _inst_3) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type (max u_1 u_2)} {σ : Type u_4} [_inst_1 : primcodable.{(max u_1 u_2)} α] [_inst_4 : primcodable.{u_4} σ] {f : pfun.{(max u_1 u_2) u_4} α σ}, iff (@partrec.{(max u_1 u_2) u_4} α (option.{u_4} σ) _inst_1 (@primcodable.option.{u_4} σ _inst_4) (λ (a : α), @roption.map.{u_4 u_4} σ (option.{u_4} σ) (@option.some.{u_4} σ) (f a))) (@partrec.{(max u_1 u_2) u_4} α σ _inst_1 _inst_4 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@partrec₂.{u_1 u_2 u_4} α β σ _inst_1 _inst_2 _inst_4 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} β] [_inst_4 : primcodable.{u_4} σ] {f : pfun.{(max u_1 u_2) u_4} (prod.{u_1 u_2} α β) σ}, @partrec.{(max u_1 u_2) u_4} (prod.{u_1 u_2} α β) σ (@primcodable.prod.{u_1 u_2} α β _inst_1 _inst_2) _inst_4 f → @partrec₂.{u_1 u_2 u_4} α β σ _inst_1 _inst_2 _inst_4 (λ (a : α) (b : β), f (@prod.mk.{u_1 u_2} α β a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type (max u_1 u_3)} {σ : Type u_4} [_inst_1 : primcodable.{(max u_1 u_3)} α] [_inst_4 : primcodable.{u_4} σ] (s : σ), @computable.{(max u_1 u_3) u_4} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4}, option.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_3} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_3} β] [_inst_4 : primcodable.{u_4} σ] {f : prod.{u_1 u_3} α β → σ}, @computable.{(max u_1 u_3) u_4} (prod.{u_1 u_3} α β) σ (@primcodable.prod.{u_1 u_3} α β _inst_1 _inst_2) _inst_4 f → @computable₂.{u_1 u_3 u_4} α β σ _inst_1 _inst_2 _inst_4 (λ (a : α) (b : β), f (@prod.mk.{u_1 u_3} α β a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121    (sum_cases_right hf (const option.none).to₂ (option_some_iff.2 hh).to₂))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='partrec.sum_cases_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.to₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='partrec.option_some_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hh'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='partrec.to₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 620, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 256, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 604, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 348, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} β] [_inst_3 : primcodable.{u_3} γ] [_inst_4 : primcodable.{u_4} σ] {f : α → sum.{u_2 u_3} β γ} {g : α → β → σ} {h : α → pfun.{u_3 u_4} γ σ}, @computable.{u_1 (max u_2 u_3)} α (sum.{u_2 u_3} β γ) _inst_1 (@primcodable.sum.{u_2 u_3} β γ _inst_2 _inst_3) f → @computable₂.{u_1 u_2 u_4} α β σ _inst_1 _inst_2 _inst_4 g → @partrec₂.{u_1 u_3 u_4} α γ σ _inst_1 _inst_3 _inst_4 h → @partrec.{u_1 u_4} α σ _inst_1 _inst_4 (λ (a : α), @sum.cases_on.{u_4+1 u_2 u_3} β γ (λ (_x : sum.{u_2 u_3} β γ), roption.{u_4} σ) (f a) (λ (b : β), @roption.some.{u_4} σ (g a b)) (h a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@computable.{u_1 (max u_2 u_3)} α (sum.{u_2 u_3} β γ) _inst_1 (@primcodable.sum.{u_2 u_3} β γ _inst_2 _inst_3) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type (max u_1 u_2)} {σ : Type u_4} [_inst_1 : primcodable.{(max u_1 u_2)} α] [_inst_4 : primcodable.{u_4} σ] (s : σ), @computable.{(max u_1 u_2) u_4} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4}, option.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} β] [_inst_4 : primcodable.{u_4} σ] {f : prod.{u_1 u_2} α β → σ}, @computable.{(max u_1 u_2) u_4} (prod.{u_1 u_2} α β) σ (@primcodable.prod.{u_1 u_2} α β _inst_1 _inst_2) _inst_4 f → @computable₂.{u_1 u_2 u_4} α β σ _inst_1 _inst_2 _inst_4 (λ (a : α) (b : β), f (@prod.mk.{u_1 u_2} α β a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type (max u_1 u_3)} {σ : Type u_4} [_inst_1 : primcodable.{(max u_1 u_3)} α] [_inst_4 : primcodable.{u_4} σ] {f : pfun.{(max u_1 u_3) u_4} α σ}, iff (@partrec.{(max u_1 u_3) u_4} α (option.{u_4} σ) _inst_1 (@primcodable.option.{u_4} σ _inst_4) (λ (a : α), @roption.map.{u_4 u_4} σ (option.{u_4} σ) (@option.some.{u_4} σ) (f a))) (@partrec.{(max u_1 u_3) u_4} α σ _inst_1 _inst_4 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@partrec₂.{u_1 u_3 u_4} α γ σ _inst_1 _inst_3 _inst_4 h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_3} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_3} β] [_inst_4 : primcodable.{u_4} σ] {f : pfun.{(max u_1 u_3) u_4} (prod.{u_1 u_3} α β) σ}, @partrec.{(max u_1 u_3) u_4} (prod.{u_1 u_3} α β) σ (@primcodable.prod.{u_1 u_3} α β _inst_1 _inst_2) _inst_4 f → @partrec₂.{u_1 u_3 u_4} α β σ _inst_1 _inst_2 _inst_4 (λ (a : α) (b : β), f (@prod.mk.{u_1 u_3} α β a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  .of_eq $ λ a, by cases f a; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='partrec.of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_4} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{u_4} σ] {f g : pfun.{u_1 u_4} α σ}, @partrec.{u_1 u_4} α σ _inst_1 _inst_4 f → (∀ (n : α), @eq.{u_4+1} (roption.{u_4} σ) (f n) (g n)) → @partrec.{u_1 u_4} α σ _inst_1 _inst_4 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → sum.{u_2 u_3} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_2 : primcodable.{u_2} β,
_inst_3 : primcodable.{u_3} γ,
_inst_4 : primcodable.{u_4} σ,
f : α → sum.{u_2 u_3} β γ,
g : α → pfun.{u_2 u_4} β σ,
h : α → pfun.{u_3 u_4} γ σ,
hf :
  @computable.{u_1 (max u_2 u_3)} α (sum.{u_2 u_3} β γ) _inst_1 (@primcodable.sum.{u_2 u_3} β γ _inst_2 _inst_3) f,
hg : @partrec₂.{u_1 u_2 u_4} α β σ _inst_1 _inst_2 _inst_4 g,
hh : @partrec₂.{u_1 u_3 u_4} α γ σ _inst_1 _inst_3 _inst_4 h,
a : α
⊢ @eq.{u_4+1} (roption.{u_4} (option.{u_4} σ))
    (@cond.{u_4} (roption.{u_4} (option.{u_4} σ))
       (@sum.cases_on.{1 u_2 u_3} β γ (λ (_x : sum.{u_2 u_3} β γ), bool) (f a) (λ (b : β), bool.tt)
          (λ (b : γ), bool.ff))
       (@sum.cases_on.{u_4+1 u_2 u_3} β γ (λ (_x : sum.{u_2 u_3} β γ), roption.{u_4} (option.{u_4} σ)) (f a)
          (λ (b : β),
             @roption.map.{u_4 u_4} σ (option.{u_4} σ) (@option.some.{u_4} σ)
               (g (@prod.fst.{u_1 u_2} α β (@prod.mk.{u_1 u_2} α β a b))
                  (@prod.snd.{u_1 u_2} α β (@prod.mk.{u_1 u_2} α β a b))))
          (λ (c : γ), @roption.some.{u_4} (option.{u_4} σ) (@option.none.{u_4} σ)))
       (@sum.cases_on.{u_4+1 u_2 u_3} β γ (λ (_x : sum.{u_2 u_3} β γ), roption.{u_4} (option.{u_4} σ)) (f a)
          (λ (b : β), @roption.some.{u_4} (option.{u_4} σ) (@option.none.{u_4} σ))
          (λ (b : γ),
             @roption.map.{u_4 u_4} σ (option.{u_4} σ) (@option.some.{u_4} σ)
               (h (@prod.fst.{u_1 u_3} α γ (@prod.mk.{u_1 u_3} α γ a b))
                  (@prod.snd.{u_1 u_3} α γ (@prod.mk.{u_1 u_3} α γ a b))))))
    (@roption.map.{u_4 u_4} σ (option.{u_4} σ) (@option.some.{u_4} σ)
       (@sum.cases_on.{u_4+1 u_2 u_3} β γ (λ (_x : sum.{u_2 u_3} β γ), roption.{u_4} σ) (f a) (g a) (h a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
σ : Type u_4,
_inst_1 : primcodable.{u_1} α,
_inst_2 : primcodable.{u_2} β,
_inst_3 : primcodable.{u_3} γ,
_inst_4 : primcodable.{u_4} σ,
f : α → sum.{u_2 u_3} β γ,
g : α → pfun.{u_2 u_4} β σ,
h : α → pfun.{u_3 u_4} γ σ,
hf :
  @computable.{u_1 (max u_2 u_3)} α (sum.{u_2 u_3} β γ) _inst_1 (@primcodable.sum.{u_2 u_3} β γ _inst_2 _inst_3) f,
hg : @partrec₂.{u_1 u_2 u_4} α β σ _inst_1 _inst_2 _inst_4 g,
hh : @partrec₂.{u_1 u_3 u_4} α γ σ _inst_1 _inst_3 _inst_4 h,
a : α
⊢ @eq.{u_4+1} (roption.{u_4} (option.{u_4} σ))
    (@cond.{u_4} (roption.{u_4} (option.{u_4} σ))
       (@sum.cases_on.{1 u_2 u_3} β γ (λ (_x : sum.{u_2 u_3} β γ), bool) (f a) (λ (b : β), bool.tt)
          (λ (b : γ), bool.ff))
       (@sum.cases_on.{u_4+1 u_2 u_3} β γ (λ (_x : sum.{u_2 u_3} β γ), roption.{u_4} (option.{u_4} σ)) (f a)
          (λ (b : β),
             @roption.map.{u_4 u_4} σ (option.{u_4} σ) (@option.some.{u_4} σ)
               (g (@prod.fst.{u_1 u_2} α β (@prod.mk.{u_1 u_2} α β a b))
                  (@prod.snd.{u_1 u_2} α β (@prod.mk.{u_1 u_2} α β a b))))
          (λ (c : γ), @roption.some.{u_4} (option.{u_4} σ) (@option.none.{u_4} σ)))
       (@sum.cases_on.{u_4+1 u_2 u_3} β γ (λ (_x : sum.{u_2 u_3} β γ), roption.{u_4} (option.{u_4} σ)) (f a)
          (λ (b : β), @roption.some.{u_4} (option.{u_4} σ) (@option.none.{u_4} σ))
          (λ (b : γ),
             @roption.map.{u_4 u_4} σ (option.{u_4} σ) (@option.some.{u_4} σ)
               (h (@prod.fst.{u_1 u_3} α γ (@prod.mk.{u_1 u_3} α γ a b))
                  (@prod.snd.{u_1 u_3} α γ (@prod.mk.{u_1 u_3} α γ a b))))))
    (@roption.map.{u_4 u_4} σ (option.{u_4} σ) (@option.some.{u_4} σ)
       (@sum.cases_on.{u_4+1 u_2 u_3} β γ (λ (_x : sum.{u_2 u_3} β γ), roption.{u_4} σ) (f a) (g a) (h a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  end partrec</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  def computable_pred {α} [primcodable α] (p : α → Prop) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='primcodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A `primcodable` type is an `encodable` type for which
 the encode/decode functions are primitive recursive.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  ∃ [D : decidable_pred p],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Sort u}, (α → Prop) → Sort (max u 1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  by exactI computable (λ a, to_bool (p a))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='computable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='decidable.to_bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 220, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 590, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{0} σ], (α → σ) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (p : Prop) [h : decidable p], bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : primcodable.{?l_1} α,
p : α → Prop,
D : @decidable_pred.{?l_1+1} α p
⊢ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : primcodable.{?l_1} α,
p : α → Prop,
D : @decidable_pred.{?l_1+1} α p
⊢ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  /- recursively enumerable predicate -/</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type ?l_1,
_inst_1 : primcodable.{?l_1} α,
p : α → Prop,
D : @decidable_pred.{?l_1+1} α p
⊢ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  def re_pred {α} [primcodable α] (p : α → Prop) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='primcodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='A `primcodable` type is an `encodable` type for which
 the encode/decode functions are primitive recursive.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  partrec (λ a, roption.assert (p a) (λ _, roption.some ()))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='roption.assert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='roption.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='unit.star'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 177, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} (p : Prop), (p → roption.{u_1} α) → roption.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='p a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → roption.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`assert p f` is a bind-like operation which appends an additional condition
 `p` to the domain and uses `f` to produce the value.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `some a` value in `roption` has a `true` domain and the
 function returns `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  theorem computable_pred.of_eq {α} [primcodable α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='primcodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='A `primcodable` type is an `encodable` type for which
 the encode/decode functions are primitive recursive.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135    {p q : α → Prop}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136    (hp : computable_pred p) (H : ∀ a, p a ↔ q a) : computable_pred q :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='computable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='computable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : primcodable.{u_1} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : primcodable.{u_1} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  (funext (λ a, propext (H a)) : p = q) ▸ hp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='propext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/propext.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : α → Type} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{1} (β x) (f₁ x) (f₂ x)) → @eq.{(max (u_1+1) 1)} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, iff a b → @eq.{1} Prop a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (a : α), iff (p a) (q a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {P : α → Prop} {a b : α}, @eq.{(max (u_1+1) 1)} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@computable_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  namespace computable_pred</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  variables {α : Type*} {σ : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  variables [primcodable α] [primcodable σ]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='primcodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='primcodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A `primcodable` type is an `encodable` type for which
 the encode/decode functions are primitive recursive.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A `primcodable` type is an `encodable` type for which
 the encode/decode functions are primitive recursive.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  open nat.partrec (code) nat.partrec.code computable</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  theorem computable_iff {p : α → Prop} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145    computable_pred p ↔ ∃ f : α → bool, computable f ∧ p = λ a, f a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 220, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : primcodable.{u_1} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], (α → σ) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  ⟨λ ⟨D, h⟩, by exactI ⟨_, h, funext $ λ a, propext (to_bool_iff _).symm⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='propext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='to_bool_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/propext.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/bool/lemmas.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@computable_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@computable.{u_1 0} α bool _inst_1 primcodable.bool (λ (a : α), @decidable.to_bool (p a) (D a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : α → Type} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{1} (β x) (f₁ x) (f₂ x)) → @eq.{(max (u_1+1) 1)} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → @eq.{1} Prop a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (p : Prop) [d : decidable p], iff (@eq.{1} bool (@decidable.to_bool p d) bool.tt) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_x : @computable_pred.{u_1} α _inst_1 p,
_fun_match :
  @computable_pred.{u_1} α _inst_1 p →
  @Exists.{(max (u_1+1) 1)} (α → bool)
    (λ (f : α → bool),
       and (@computable.{u_1 0} α bool _inst_1 primcodable.bool f)
         (@eq.{(max (u_1+1) 1)} (α → Prop) p (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)))),
D : @decidable_pred.{u_1+1} α p,
h : @computable.{u_1 0} α bool _inst_1 primcodable.bool (λ (a : α), @decidable.to_bool (p a) (D a))
⊢ @Exists.{(max (u_1+1) 1)} (α → bool)
    (λ (f : α → bool),
       and (@computable.{u_1 0} α bool _inst_1 primcodable.bool f)
         (@eq.{(max (u_1+1) 1)} (α → Prop) p (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147   by rintro ⟨f, h, rfl⟩; exact ⟨by apply_instance, by simpa using h⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@computable.{u_1 0} α bool _inst_1 primcodable.bool f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop
⊢ @Exists.{(max (u_1+1) 1)} (α → bool)
    (λ (f : α → bool),
       and (@computable.{u_1 0} α bool _inst_1 primcodable.bool f)
         (@eq.{(max (u_1+1) 1)} (α → Prop) p (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)))) →
  @computable_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
f : α → bool,
h : @computable.{u_1 0} α bool _inst_1 primcodable.bool f
⊢ @decidable_pred.{u_1+1} α (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop
⊢ @Exists.{(max (u_1+1) 1)} (α → bool)
    (λ (f : α → bool),
       and (@computable.{u_1 0} α bool _inst_1 primcodable.bool f)
         (@eq.{(max (u_1+1) 1)} (α → Prop) p (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)))) →
  @computable_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
f : α → bool,
h : @computable.{u_1 0} α bool _inst_1 primcodable.bool f
⊢ @computable.{u_1 0} α bool _inst_1 primcodable.bool
    (λ (a : α),
       @decidable.to_bool ((λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)) a) (bool.decidable_eq (f a) bool.tt))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop
⊢ @Exists.{(max (u_1+1) 1)} (α → bool)
    (λ (f : α → bool),
       and (@computable.{u_1 0} α bool _inst_1 primcodable.bool f)
         (@eq.{(max (u_1+1) 1)} (α → Prop) p (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)))) →
  @computable_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  protected theorem not {p : α → Prop}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150    (hp : computable_pred p) : computable_pred (λ a, ¬ p a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='computable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='computable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : primcodable.{u_1} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : primcodable.{u_1} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  by rcases computable_iff.1 hp with ⟨f, hf, rfl⟩; exact</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='computable_pred.computable_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 144, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : primcodable.{u_1} α] {p : α → Prop}, iff (@computable_pred.{u_1} α _inst_1 p) (@Exists.{(max (u_1+1) 1)} (α → bool) (λ (f : α → bool), and (@computable.{u_1 0} α bool _inst_1 primcodable.bool f) (@eq.{(max (u_1+1) 1)} (α → Prop) p (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@computable_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
hp : @computable_pred.{u_1} α _inst_1 p
⊢ @computable_pred.{u_1} α _inst_1 (λ (a : α), not (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152    ⟨by apply_instance,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
hp : @computable_pred.{u_1} α _inst_1 p
⊢ @computable_pred.{u_1} α _inst_1 (λ (a : α), not (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
f : α → bool,
hf : @computable.{u_1 0} α bool _inst_1 primcodable.bool f,
hp : @computable_pred.{u_1} α _inst_1 (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a))
⊢ @decidable_pred.{u_1+1} α (λ (a : α), not ((λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
hp : @computable_pred.{u_1} α _inst_1 p
⊢ @computable_pred.{u_1} α _inst_1 (λ (a : α), not (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153      (cond hf (const ff) (const tt)).of_eq</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='computable.cond'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='computable.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 533, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{0} σ] {c : α → bool} {f g : α → σ}, @computable.{u_1 0} α bool _inst_1 primcodable.bool c → @computable.{u_1 0} α σ _inst_1 _inst_4 f → @computable.{u_1 0} α σ _inst_1 _inst_4 g → @computable.{u_1 0} α σ _inst_1 _inst_4 (λ (a : α), @cond.{0} σ (c a) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@computable.{u_1 0} α bool _inst_1 primcodable.bool f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{0} σ] (s : σ), @computable.{u_1 0} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
hp : @computable_pred.{u_1} α _inst_1 p
⊢ @computable_pred.{u_1} α _inst_1 (λ (a : α), not (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154        (λ n, by {dsimp, cases f n; refl})⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
hp : @computable_pred.{u_1} α _inst_1 p
⊢ @computable_pred.{u_1} α _inst_1 (λ (a : α), not (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
f : α → bool,
hf : @computable.{u_1 0} α bool _inst_1 primcodable.bool f,
hp : @computable_pred.{u_1} α _inst_1 (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)),
n : α
⊢ @eq.{1} bool (@cond.{0} bool (f n) bool.ff bool.tt)
    (@decidable.to_bool ((λ (a : α), not ((λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)) a)) n)
       (@ne.decidable.{1} bool (λ (a b : bool), bool.decidable_eq a b) (f n) bool.tt))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
f : α → bool,
hf : @computable.{u_1 0} α bool _inst_1 primcodable.bool f,
hp : @computable_pred.{u_1} α _inst_1 (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)),
n : α
⊢ @eq.{1} bool (@cond.{0} bool (f n) bool.ff bool.tt)
    (@decidable.to_bool (not (@coe_sort.{1 1} bool coe_sort_bool (f n)))
       (@ne.decidable.{1} bool bool.decidable_eq (f n) bool.tt))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
hp : @computable_pred.{u_1} α _inst_1 p
⊢ @computable_pred.{u_1} α _inst_1 (λ (a : α), not (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
hp : @computable_pred.{u_1} α _inst_1 p
⊢ @computable_pred.{u_1} α _inst_1 (λ (a : α), not (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  theorem to_re {p : α → Prop} (hp : computable_pred p) : re_pred p :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='computable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='re_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 131, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : primcodable.{u_1} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : primcodable.{u_1} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
hp : @computable_pred.{u_1} α _inst_1 p
⊢ @re_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158    rcases computable_iff.1 hp with ⟨f, hf, rfl⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='computable_pred.computable_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 144, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : primcodable.{u_1} α] {p : α → Prop}, iff (@computable_pred.{u_1} α _inst_1 p) (@Exists.{(max (u_1+1) 1)} (α → bool) (λ (f : α → bool), and (@computable.{u_1 0} α bool _inst_1 primcodable.bool f) (@eq.{(max (u_1+1) 1)} (α → Prop) p (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@computable_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
hp : @computable_pred.{u_1} α _inst_1 p
⊢ @re_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
f : α → bool,
hf : @computable.{u_1 0} α bool _inst_1 primcodable.bool f,
hp : @computable_pred.{u_1} α _inst_1 (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a))
⊢ @re_pred.{u_1} α _inst_1 (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159    unfold re_pred,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
f : α → bool,
hf : @computable.{u_1 0} α bool _inst_1 primcodable.bool f,
hp : @computable_pred.{u_1} α _inst_1 (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a))
⊢ @re_pred.{u_1} α _inst_1 (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
f : α → bool,
hf : @computable.{u_1 0} α bool _inst_1 primcodable.bool f,
hp : @computable_pred.{u_1} α _inst_1 (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a))
⊢ @partrec.{u_1 0} α unit _inst_1 primcodable.unit.{0}
    (λ (a : α),
       @roption.assert.{0} unit (@coe_sort.{1 1} bool coe_sort_bool (f a))
         (λ (_x : @coe_sort.{1 1} bool coe_sort_bool (f a)), @roption.some.{0} unit unit.star))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160    refine (partrec.cond hf (partrec.const&#x27; (roption.some ())) partrec.none).of_eq</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='partrec.cond'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='partrec.const&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='roption.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='partrec.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 104, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 333, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 328, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{0} σ] {c : α → bool} {f g : pfun.{u_1 0} α σ}, @computable.{u_1 0} α bool _inst_1 primcodable.bool c → @partrec.{u_1 0} α σ _inst_1 _inst_4 f → @partrec.{u_1 0} α σ _inst_1 _inst_4 g → @partrec.{u_1 0} α σ _inst_1 _inst_4 (λ (a : α), @cond.{0} (roption.{0} σ) (c a) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@computable.{u_1 0} α bool _inst_1 primcodable.bool f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{0} σ] (s : roption.{0} σ), @partrec.{u_1 0} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → roption.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{0} σ], @partrec.{u_1 0} α σ _inst_1 _inst_4 (λ (a : α), @roption.none.{0} σ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `some a` value in `roption` has a `true` domain and the
 function returns `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
f : α → bool,
hf : @computable.{u_1 0} α bool _inst_1 primcodable.bool f,
hp : @computable_pred.{u_1} α _inst_1 (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a))
⊢ @partrec.{u_1 0} α unit _inst_1 primcodable.unit.{0}
    (λ (a : α),
       @roption.assert.{0} unit (@coe_sort.{1 1} bool coe_sort_bool (f a))
         (λ (_x : @coe_sort.{1 1} bool coe_sort_bool (f a)), @roption.some.{0} unit unit.star))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161      (λ n, roption.ext $ λ a, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='roption.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {o p : roption.{0} α}, (∀ (a : α), iff (@has_mem.mem.{0 0} α (roption.{0} α) (@roption.has_mem.{0} α) a o) (@has_mem.mem.{0 0} α (roption.{0} α) (@roption.has_mem.{0} α) a p)) → @eq.{1} (roption.{0} α) o p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`roption` extensionality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
f : α → bool,
hf : @computable.{u_1 0} α bool _inst_1 primcodable.bool f,
hp : @computable_pred.{u_1} α _inst_1 (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a))
⊢ @partrec.{u_1 0} α unit _inst_1 primcodable.unit.{0}
    (λ (a : α),
       @roption.assert.{0} unit (@coe_sort.{1 1} bool coe_sort_bool (f a))
         (λ (_x : @coe_sort.{1 1} bool coe_sort_bool (f a)), @roption.some.{0} unit unit.star))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
f : α → bool,
hf : @computable.{u_1 0} α bool _inst_1 primcodable.bool f,
hp : @computable_pred.{u_1} α _inst_1 (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)),
n : α,
a : unit
⊢ iff
    (@has_mem.mem.{0 0} unit (roption.{0} unit) (@roption.has_mem.{0} unit) a
       (@cond.{0} (roption.{0} unit) (f n) (@roption.some.{0} unit unit.star) (@roption.none.{0} unit)))
    (@has_mem.mem.{0 0} unit (roption.{0} unit) (@roption.has_mem.{0} unit) a
       (@roption.assert.{0} unit (@coe_sort.{1 1} bool coe_sort_bool (f n))
          (λ (_x : @coe_sort.{1 1} bool coe_sort_bool (f n)), @roption.some.{0} unit unit.star)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162    cases a, cases f n; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
f : α → bool,
hf : @computable.{u_1 0} α bool _inst_1 primcodable.bool f,
hp : @computable_pred.{u_1} α _inst_1 (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)),
n : α,
a : unit
⊢ iff
    (@has_mem.mem.{0 0} unit (roption.{0} unit) (@roption.has_mem.{0} unit) a
       (@cond.{0} (roption.{0} unit) (f n) (@roption.some.{0} unit unit.star) (@roption.none.{0} unit)))
    (@has_mem.mem.{0 0} unit (roption.{0} unit) (@roption.has_mem.{0} unit) a
       (@roption.assert.{0} unit (@coe_sort.{1 1} bool coe_sort_bool (f n))
          (λ (_x : @coe_sort.{1 1} bool coe_sort_bool (f n)), @roption.some.{0} unit unit.star)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
f : α → bool,
hf : @computable.{u_1 0} α bool _inst_1 primcodable.bool f,
hp : @computable_pred.{u_1} α _inst_1 (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (f a)),
n : α
⊢ iff
    (@has_mem.mem.{0 0} unit (roption.{0} unit) (@roption.has_mem.{0} unit) punit.star.{1}
       (@cond.{0} (roption.{0} unit) (f n) (@roption.some.{0} unit unit.star) (@roption.none.{0} unit)))
    (@has_mem.mem.{0 0} unit (roption.{0} unit) (@roption.has_mem.{0} unit) punit.star.{1}
       (@roption.assert.{0} unit (@coe_sort.{1 1} bool coe_sort_bool (f n))
          (λ (_x : @coe_sort.{1 1} bool coe_sort_bool (f n)), @roption.some.{0} unit unit.star)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  theorem rice (C : set (ℕ →. ℕ))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type → Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166    (h : computable_pred (λ c, eval c ∈ C))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='computable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec.code.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 478, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : primcodable.{u_1} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat.partrec.code → pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} (pfun.{0 0} nat nat)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167    {f g} (hf : nat.partrec f) (hg : nat.partrec g)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='nat.partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nat.partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='pfun.{0 0} nat nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pfun.{0 0} nat nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168    (fC : f ∈ C) : g ∈ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} (pfun.{0 0} nat nat)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} (pfun.{0 0} nat nat)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
h :
  @computable_pred.{0} nat.partrec.code (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170    cases h with _ h, resetI,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@computable_pred.{0} nat.partrec.code (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable) (λ (c : nat.partrec.code), @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) (nat.partrec.code.eval c) C)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Reset the instance cache. This allows any new instances
 added to the context to be used in typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='resetI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
h :
  @computable_pred.{0} nat.partrec.code (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a))
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    rcases fixed_point₂ (partrec.cond (h.comp fst)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec.code.fixed_point₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='partrec.cond'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 912, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 104, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 261, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {f : nat.partrec.code → pfun.{0 0} nat nat}, @partrec₂.{0 0 0} nat.partrec.code nat nat (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable) (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) f → @Exists.{1} nat.partrec.code (λ (c : nat.partrec.code), @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c) (f c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_4 : primcodable.{0} σ] {c : α → bool} {f g : pfun.{0 0} α σ}, @computable.{0 0} α bool _inst_1 primcodable.bool c → @partrec.{0 0} α σ _inst_1 _inst_4 f → @partrec.{0 0} α σ _inst_1 _inst_4 g → @partrec.{0 0} α σ _inst_1 _inst_4 (λ (a : α), @cond.{0} (roption.{0} σ) (c a) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@computable.{0 0} nat.partrec.code bool (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable) primcodable.bool (λ (a : nat.partrec.code), @decidable.to_bool ((λ (c : nat.partrec.code), @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) (nat.partrec.code.eval c) C) a) (h_w a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β], @computable.{0 0} (prod.{0 0} α β) α (@primcodable.prod.{0 0} α β _inst_1 _inst_2) _inst_1 (@prod.fst.{0 0} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a))
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172      ((partrec.nat_iff.2 hg).comp snd).to₂</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a))
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173      ((partrec.nat_iff.2 hf).comp snd).to₂).to₂ with ⟨c, e⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='partrec.nat_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='computable.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 369, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {f : pfun.{0 0} nat nat}, iff (@partrec.{0 0} nat nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) f) (nat.partrec f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β], @computable.{0 0} (prod.{0 0} α β) β (@primcodable.prod.{0 0} α β _inst_1 _inst_2) _inst_2 (@prod.snd.{0 0} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a))
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
e :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
    ((λ (a : nat.partrec.code) (b : nat),
        @cond.{0} (roption.{0} nat)
          (@decidable.to_bool
             ((λ (c : nat.partrec.code),
                 @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
                   (@set.has_mem.{0} (pfun.{0 0} nat nat))
                   (nat.partrec.code.eval c)
                   C)
                (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b)))
             (h_w (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b))))
          ((λ (a : nat.partrec.code) (b : nat),
              g (@prod.snd.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b)))
             (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b))
             (@prod.snd.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b)))
          ((λ (a : nat.partrec.code) (b : nat),
              f (@prod.snd.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b)))
             (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b))
             (@prod.snd.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b))))
       c)
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174    simp at e,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
e :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
    ((λ (a : nat.partrec.code) (b : nat),
        @cond.{0} (roption.{0} nat)
          (@decidable.to_bool
             ((λ (c : nat.partrec.code),
                 @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
                   (@set.has_mem.{0} (pfun.{0 0} nat nat))
                   (nat.partrec.code.eval c)
                   C)
                (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b)))
             (h_w (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b))))
          ((λ (a : nat.partrec.code) (b : nat),
              g (@prod.snd.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b)))
             (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b))
             (@prod.snd.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b)))
          ((λ (a : nat.partrec.code) (b : nat),
              f (@prod.snd.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b)))
             (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b))
             (@prod.snd.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat a b))))
       c)
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
e :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
    (λ (b : nat),
       @ite.{1}
         (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
            (nat.partrec.code.eval c)
            C)
         (h_w (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat c b)))
         (roption.{0} nat)
         (g b)
         (f b))
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175    by_cases eval c ∈ C,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='nat.partrec.code.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 478, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec.code → pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{0} (pfun.{0 0} nat nat)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
e :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
    (λ (b : nat),
       @ite.{1}
         (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
            (nat.partrec.code.eval c)
            C)
         (h_w (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat c b)))
         (roption.{0} nat)
         (g b)
         (f b))
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
e :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
    (λ (b : nat),
       @ite.{1}
         (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
            (nat.partrec.code.eval c)
            C)
         (h_w (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat c b)))
         (roption.{0} nat)
         (g b)
         (f b)),
h :
  @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
    (nat.partrec.code.eval c)
    C
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C

C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
e :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
    (λ (b : nat),
       @ite.{1}
         (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
            (nat.partrec.code.eval c)
            C)
         (h_w (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat c b)))
         (roption.{0} nat)
         (g b)
         (f b)),
h :
  not
    ((λ (c : nat.partrec.code),
        @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
          (nat.partrec.code.eval c)
          C)
       c)
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176    { simp [h] at e, rwa ← e },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) (nat.partrec.code.eval c) C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
e :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
    (λ (b : nat),
       @ite.{1}
         (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
            (nat.partrec.code.eval c)
            C)
         (h_w (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat c b)))
         (roption.{0} nat)
         (g b)
         (f b)),
h :
  @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
    (nat.partrec.code.eval c)
    C
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C

C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
e :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
    (λ (b : nat),
       @ite.{1}
         (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
            (nat.partrec.code.eval c)
            C)
         (h_w (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat c b)))
         (roption.{0} nat)
         (g b)
         (f b)),
h :
  not
    ((λ (c : nat.partrec.code),
        @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
          (nat.partrec.code.eval c)
          C)
       c)
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
e :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
    (λ (b : nat),
       @ite.{1}
         (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
            (nat.partrec.code.eval c)
            C)
         (h_w (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat c b)))
         (roption.{0} nat)
         (g b)
         (f b)),
h :
  @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
    (nat.partrec.code.eval c)
    C
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
h :
  @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
    (nat.partrec.code.eval c)
    C,
e : @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c) g
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
e :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
    (λ (b : nat),
       @ite.{1}
         (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
            (nat.partrec.code.eval c)
            C)
         (h_w (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat c b)))
         (roption.{0} nat)
         (g b)
         (f b)),
h :
  not
    ((λ (c : nat.partrec.code),
        @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
          (nat.partrec.code.eval c)
          C)
       c)
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177    { simp at h, simp [h] at e,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) (nat.partrec.code.eval c) C)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
e :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
    (λ (b : nat),
       @ite.{1}
         (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
            (nat.partrec.code.eval c)
            C)
         (h_w (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat c b)))
         (roption.{0} nat)
         (g b)
         (f b)),
h :
  not
    ((λ (c : nat.partrec.code),
        @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
          (nat.partrec.code.eval c)
          C)
       c)
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
e :
  @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c)
    (λ (b : nat),
       @ite.{1}
         (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
            (nat.partrec.code.eval c)
            C)
         (h_w (@prod.fst.{0 0} nat.partrec.code nat (@prod.mk.{0 0} nat.partrec.code nat c b)))
         (roption.{0} nat)
         (g b)
         (f b)),
h :
  not
    (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
       (nat.partrec.code.eval c)
       C)
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
h :
  not
    (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
       (nat.partrec.code.eval c)
       C),
e : @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c) f
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178      rw e at h, contradiction }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 825, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The contradiction tactic attempts to find in the current local context a hypothesis that is equivalent to an empty inductive type (e.g. `false`), a hypothesis of the form `c_1 ... = c_2 ...` where `c_1` and `c_2` are distinct constructors, or two contradictory hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
h :
  not
    (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
       (nat.partrec.code.eval c)
       C),
e : @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c) f
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} (pfun.{0 0} nat nat),
f g : pfun.{0 0} nat nat,
hf : nat.partrec f,
hg : nat.partrec g,
fC : @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C,
h_w :
  @decidable_pred.{1} nat.partrec.code
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval c)
         C),
h :
  @computable.{0 0} nat.partrec.code bool
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    primcodable.bool
    (λ (a : nat.partrec.code),
       @decidable.to_bool
         ((λ (c : nat.partrec.code),
             @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat))
               (@set.has_mem.{0} (pfun.{0 0} nat nat))
               (nat.partrec.code.eval c)
               C)
            a)
         (h_w a)),
c : nat.partrec.code,
e : @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c) f,
h :
  not
    (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C)
⊢ @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  theorem rice₂ (C : set code)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182    (H : ∀ cf cg, eval cf = eval cg → (cf ∈ C ↔ cg ∈ C)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='cf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec.code.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.partrec.code.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_fun_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 478, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 478, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat.partrec.code → pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@eq.{1} (set.{0} nat.partrec.code) C (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.partrec.code → pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@set.nonempty.{0} nat.partrec.code C → @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) (nat.partrec.code.eval f) (@set.image.{0 0} nat.partrec.code (pfun.{0 0} nat nat) nat.partrec.code.eval C) → @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) f C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183    computable_pred (λ c, c ∈ C) ↔ C = ∅ ∨ C = set.univ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : primcodable.{u_1} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type) [c : has_emptyc.{0} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  by haveI := classical.dec; exact</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='classical.dec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 619, &#x27;column&#x27;: 20}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (p : Prop), decidable p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)
⊢ iff
    (@computable_pred.{0} nat.partrec.code
       (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
       (λ (c : nat.partrec.code),
          @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C))
    (or
       (@eq.{1} (set.{0} nat.partrec.code) C
          (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
       (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  have hC : ∀ f, f ∈ C ↔ eval f ∈ eval &#x27;&#x27; C,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type}, (α → β) → set.{0} α → set.{0} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)
⊢ iff
    (@computable_pred.{0} nat.partrec.code
       (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
       (λ (c : nat.partrec.code),
          @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C))
    (or
       (@eq.{1} (set.{0} nat.partrec.code) C
          (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
       (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  from λ f, ⟨set.mem_image_of_mem _, λ ⟨g, hg, e⟩, (H _ _ e).1 hg⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.mem_image_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 899, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type} (f : α → β) {x : α} {a : set.{0} α}, @has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) x a → @has_mem.mem.{0 0} β (set.{0} β) (@set.has_mem.{0} β) (f x) (@set.image.{0 0} α β f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval g) (nat.partrec.code.eval f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (cf cg : nat.partrec.code), @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) → iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C) (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)
⊢ iff
    (@computable_pred.{0} nat.partrec.code
       (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
       (λ (c : nat.partrec.code),
          @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C))
    (or
       (@eq.{1} (set.{0} nat.partrec.code) C
          (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
       (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  ⟨λ h, or_iff_not_imp_left.2 $ λ C0,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='or_iff_not_imp_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 244, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop} [_inst_1 : decidable a], iff (or a b) (not a → b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)
⊢ iff
    (@computable_pred.{0} nat.partrec.code
       (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
       (λ (c : nat.partrec.code),
          @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C))
    (or
       (@eq.{1} (set.{0} nat.partrec.code) C
          (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
       (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    set.eq_univ_of_forall $ λ cg,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.eq_univ_of_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 251, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {s : set.{0} α}, (∀ (x : α), @has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) x s) → @eq.{1} (set.{0} α) s (@set.univ.{0} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)
⊢ iff
    (@computable_pred.{0} nat.partrec.code
       (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
       (λ (c : nat.partrec.code),
          @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C))
    (or
       (@eq.{1} (set.{0} nat.partrec.code) C
          (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
       (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189    let ⟨cf, fC⟩ := set.ne_empty_iff_nonempty.1 C0 in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='cf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fC'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.ne_empty_iff_nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 218, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {s : set.{0} α}, iff (@ne.{1} (set.{0} α) s (@has_emptyc.emptyc.{0} (set.{0} α) (@set.has_emptyc.{0} α))) (@set.nonempty.{0} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)
⊢ iff
    (@computable_pred.{0} nat.partrec.code
       (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
       (λ (c : nat.partrec.code),
          @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C))
    (or
       (@eq.{1} (set.{0} nat.partrec.code) C
          (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
       (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190    (hC _).2 $ rice (eval &#x27;&#x27; C) (h.of_eq hC)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='computable_pred.rice'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec.code.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='computable_pred.of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 478, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 134, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (C : set.{0} (pfun.{0 0} nat nat)), @computable_pred.{0} nat.partrec.code (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable) (λ (c : nat.partrec.code), @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) (nat.partrec.code.eval c) C) → ∀ {f g : pfun.{0 0} nat nat}, nat.partrec f → nat.partrec g → @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C → @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.partrec.code → pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{0} nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α] {p q : α → Prop}, @computable_pred.{0} α _inst_1 p → (∀ (a : α), iff (p a) (q a)) → @computable_pred.{0} α _inst_1 q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)
⊢ iff
    (@computable_pred.{0} nat.partrec.code
       (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
       (λ (c : nat.partrec.code),
          @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C))
    (or
       (@eq.{1} (set.{0} nat.partrec.code) C
          (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
       (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191      (partrec.nat_iff.1 $ eval_part.comp (const cf) computable.id)</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)
⊢ iff
    (@computable_pred.{0} nat.partrec.code
       (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
       (λ (c : nat.partrec.code),
          @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C))
    (or
       (@eq.{1} (set.{0} nat.partrec.code) C
          (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
       (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192      (partrec.nat_iff.1 $ eval_part.comp (const cg) computable.id)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='partrec.nat_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.partrec.code.eval_part'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='computable.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 369, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 887, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 259, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {f : pfun.{0 0} nat nat}, iff (@partrec.{0 0} nat nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) f) (nat.partrec f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@partrec₂.{0 0 0} nat.partrec.code nat nat (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable) (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) nat.partrec.code.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_4 : primcodable.{0} σ] (s : σ), @computable.{0 0} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α], @computable.{0 0} α α _inst_1 _inst_1 (@id.{1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)
⊢ iff
    (@computable_pred.{0} nat.partrec.code
       (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
       (λ (c : nat.partrec.code),
          @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C))
    (or
       (@eq.{1} (set.{0} nat.partrec.code) C
          (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
       (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193      ((hC _).1 fC),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)
⊢ iff
    (@computable_pred.{0} nat.partrec.code
       (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
       (λ (c : nat.partrec.code),
          @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C))
    (or
       (@eq.{1} (set.{0} nat.partrec.code) C
          (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
       (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  λ h, by rcases h with rfl | rfl; simp [computable_pred];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='computable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='or (@eq.{1} (set.{0} nat.partrec.code) C (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code))) (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : primcodable.{?l_1} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)
⊢ iff
    (@computable_pred.{0} nat.partrec.code
       (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
       (λ (c : nat.partrec.code),
          @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C))
    (or
       (@eq.{1} (set.{0} nat.partrec.code) C
          (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
       (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C),
_inst : Π (p : Prop), decidable p,
hC :
  ∀ (f : nat.partrec.code),
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) f C)
      (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval f)
         (@set.image.{0 0} nat.partrec.code (pfun.{0 0} nat nat) nat.partrec.code.eval C)),
h :
  or
    (@eq.{1} (set.{0} nat.partrec.code) C
       (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
    (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code))
⊢ @computable_pred.{0} nat.partrec.code
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195    exact ⟨by apply_instance, computable.const _⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='computable.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_4 : primcodable.{0} σ] (s : σ), @computable.{0 0} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C),
_inst : Π (p : Prop), decidable p,
hC :
  ∀ (f : nat.partrec.code),
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) f C)
      (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval f)
         (@set.image.{0 0} nat.partrec.code (pfun.{0 0} nat nat) nat.partrec.code.eval C)),
h :
  or
    (@eq.{1} (set.{0} nat.partrec.code) C
       (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
    (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code))
⊢ @computable_pred.{0} nat.partrec.code
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='_inst : Π (p : Prop), decidable p,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf
         (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg
         (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code))),
hC :
  ∀ (f : nat.partrec.code),
    iff
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) f
         (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
      (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval f)
         (@set.image.{0 0} nat.partrec.code (pfun.{0 0} nat nat) nat.partrec.code.eval
            (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code))))
⊢ @decidable_pred.{1} nat.partrec.code (λ (c : nat.partrec.code), false)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C),
_inst : Π (p : Prop), decidable p,
hC :
  ∀ (f : nat.partrec.code),
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) f C)
      (@has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat))
         (nat.partrec.code.eval f)
         (@set.image.{0 0} nat.partrec.code (pfun.{0 0} nat nat) nat.partrec.code.eval C)),
h :
  or
    (@eq.{1} (set.{0} nat.partrec.code) C
       (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
    (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code))
⊢ @computable_pred.{0} nat.partrec.code
    (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
    (λ (c : nat.partrec.code),
       @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)
⊢ iff
    (@computable_pred.{0} nat.partrec.code
       (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
       (λ (c : nat.partrec.code),
          @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C))
    (or
       (@eq.{1} (set.{0} nat.partrec.code) C
          (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
       (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : set.{0} nat.partrec.code,
H :
  ∀ (cf cg : nat.partrec.code),
    @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval cf) (nat.partrec.code.eval cg) →
    iff (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cf C)
      (@has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) cg C)
⊢ iff
    (@computable_pred.{0} nat.partrec.code
       (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)
       (λ (c : nat.partrec.code),
          @has_mem.mem.{0 0} nat.partrec.code (set.{0} nat.partrec.code) (@set.has_mem.{0} nat.partrec.code) c C))
    (or
       (@eq.{1} (set.{0} nat.partrec.code) C
          (@has_emptyc.emptyc.{0} (set.{0} nat.partrec.code) (@set.has_emptyc.{0} nat.partrec.code)))
       (@eq.{1} (set.{0} nat.partrec.code) C (@set.univ.{0} nat.partrec.code)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  theorem halting_problem (n) : ¬ computable_pred (λ c, (eval c n).dom)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.partrec.code.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.dom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 478, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : primcodable.{0} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat.partrec.code → pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, roption.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  | h := rice {f | (f n).dom} h nat.partrec.zero nat.partrec.none trivial</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='computable_pred.rice'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.dom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.partrec.zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.partrec.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='trivial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@computable_pred.{0} nat.partrec.code (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable) (λ (c : nat.partrec.code), @roption.dom.{0} nat (nat.partrec.code.eval c n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (C : set.{0} (pfun.{0 0} nat nat)), @computable_pred.{0} nat.partrec.code (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable) (λ (c : nat.partrec.code), @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) (nat.partrec.code.eval c) C) → ∀ {f g : pfun.{0 0} nat nat}, nat.partrec f → nat.partrec g → @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) f C → @has_mem.mem.{0 0} (pfun.{0 0} nat nat) (set.{0} (pfun.{0 0} nat nat)) (@set.has_mem.{0} (pfun.{0 0} nat nat)) g C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, (α → Prop) → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, roption.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat.partrec (@has_pure.pure.{0 0} (pfun.{0 0} nat) (@applicative.to_has_pure.{0 0} (pfun.{0 0} nat) (@monad.to_applicative.{0 0} (pfun.{0 0} nat) (@pfun.monad.{0 0} nat))) nat (@has_zero.zero.{0} nat nat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.partrec (λ (n : nat), @roption.none.{0} nat)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  -- Post&#x27;s theorem on the equivalence of r.e., co-r.e. sets and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  -- computable sets. The assumption that p is decidable is required</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  -- unless we assume Markov&#x27;s principle or LEM.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203  theorem computable_iff_re_compl_re {p : α → Prop} [decidable_pred p] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204    computable_pred p ↔ re_pred p ∧ re_pred (λ a, ¬ p a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='re_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='re_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 131, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 131, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : primcodable.{u_1} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : primcodable.{u_1} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : primcodable.{u_1} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  ⟨λ h, ⟨h.to_re, h.not.to_re⟩, λ ⟨h₁, h₂⟩, ⟨‹_›, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='computable_pred.to_re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='computable_pred.not'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='computable_pred.to_re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 156, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 149, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 156, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@computable_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@computable_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : primcodable.{u_1} α] {p : α → Prop}, @computable_pred.{u_1} α _inst_1 p → @re_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@computable_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : primcodable.{u_1} α] {p : α → Prop}, @computable_pred.{u_1} α _inst_1 p → @computable_pred.{u_1} α _inst_1 (λ (a : α), not (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : primcodable.{u_1} α] {p : α → Prop}, @computable_pred.{u_1} α _inst_1 p → @re_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))
⊢ @computable.{u_1 0} α bool _inst_1 primcodable.bool (λ (a : α), @decidable.to_bool (p a) (_inst_3 a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206    rcases partrec.merge</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='partrec.merge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 89, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{0} σ] {f g : pfun.{u_1 0} α σ}, @partrec.{u_1 0} α σ _inst_1 _inst_4 f → @partrec.{u_1 0} α σ _inst_1 _inst_4 g → (∀ (a : α) (x : σ), @has_mem.mem.{0 0} σ (roption.{0} σ) (@roption.has_mem.{0} σ) x (f a) → ∀ (y : σ), @has_mem.mem.{0 0} σ (roption.{0} σ) (@roption.has_mem.{0} σ) y (g a) → @eq.{1} σ x y) → @Exists.{(max (u_1+1) 1)} (pfun.{u_1 0} α σ) (λ (k : pfun.{u_1 0} α σ), and (@partrec.{u_1 0} α σ _inst_1 _inst_4 k) (∀ (a : α) (x : σ), iff (@has_mem.mem.{0 0} σ (roption.{0} σ) (@roption.has_mem.{0} σ) x (k a)) (or (@has_mem.mem.{0 0} σ (roption.{0} σ) (@roption.has_mem.{0} σ) x (f a)) (@has_mem.mem.{0 0} σ (roption.{0} σ) (@roption.has_mem.{0} σ) x (g a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))
⊢ @computable.{u_1 0} α bool _inst_1 primcodable.bool (λ (a : α), @decidable.to_bool (p a) (_inst_3 a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207      (h₁.map (computable.const tt).to₂)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 343, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@re_pred.{u_1} α _inst_1 p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))
⊢ @computable.{u_1 0} α bool _inst_1 primcodable.bool (λ (a : α), @decidable.to_bool (p a) (_inst_3 a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208      (h₂.map (computable.const ff).to₂) _ with ⟨k, pk, hk⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 343, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{0} σ] (s : σ), @computable.{u_1 0} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))
⊢ @computable.{u_1 0} α bool _inst_1 primcodable.bool (λ (a : α), @decidable.to_bool (p a) (_inst_3 a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a)),
k : pfun.{u_1 0} α bool,
pk : @partrec.{u_1 0} α bool _inst_1 primcodable.bool k,
hk :
  ∀ (a : α) (x : bool),
    iff (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x (k a))
      (or
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.tt)
                  (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star)))
               a))
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.ff)
                  (@roption.assert.{0} unit ((λ (a : α), not (p a)) a)
                     (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star)))
               a)))
⊢ @computable.{u_1 0} α bool _inst_1 primcodable.bool (λ (a : α), @decidable.to_bool (p a) (_inst_3 a))

α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))
⊢ ∀ (a : α) (x : bool),
    @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
      (@roption.map.{0 0} unit bool (λ (b : unit), bool.tt)
         (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star))) →
    ∀ (y : bool),
      @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) y
        (@roption.map.{0 0} unit bool (λ (b : unit), bool.ff)
           (@roption.assert.{0} unit ((λ (a : α), not (p a)) a)
              (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star))) →
      @eq.{1} bool x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209    { refine partrec.of_eq pk (λ n, roption.eq_some_iff.2 _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='partrec.of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='roption.eq_some_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 76, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type} [_inst_1 : primcodable.{u_1} α] [_inst_4 : primcodable.{0} σ] {f g : pfun.{u_1 0} α σ}, @partrec.{u_1 0} α σ _inst_1 _inst_4 f → (∀ (n : α), @eq.{1} (roption.{0} σ) (f n) (g n)) → @partrec.{u_1 0} α σ _inst_1 _inst_4 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@partrec.{u_1 0} α bool _inst_1 primcodable.bool k'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α} {o : roption.{0} α}, iff (@eq.{1} (roption.{0} α) o (@roption.some.{0} α a)) (@has_mem.mem.{0 0} α (roption.{0} α) (@roption.has_mem.{0} α) a o)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a)),
k : pfun.{u_1 0} α bool,
pk : @partrec.{u_1 0} α bool _inst_1 primcodable.bool k,
hk :
  ∀ (a : α) (x : bool),
    iff (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x (k a))
      (or
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.tt)
                  (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star)))
               a))
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.ff)
                  (@roption.assert.{0} unit ((λ (a : α), not (p a)) a)
                     (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star)))
               a)))
⊢ @computable.{u_1 0} α bool _inst_1 primcodable.bool (λ (a : α), @decidable.to_bool (p a) (_inst_3 a))

α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))
⊢ ∀ (a : α) (x : bool),
    @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
      (@roption.map.{0 0} unit bool (λ (b : unit), bool.tt)
         (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star))) →
    ∀ (y : bool),
      @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) y
        (@roption.map.{0 0} unit bool (λ (b : unit), bool.ff)
           (@roption.assert.{0} unit ((λ (a : α), not (p a)) a)
              (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star))) →
      @eq.{1} bool x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a)),
k : pfun.{u_1 0} α bool,
pk : @partrec.{u_1 0} α bool _inst_1 primcodable.bool k,
hk :
  ∀ (a : α) (x : bool),
    iff (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x (k a))
      (or
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.tt)
                  (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star)))
               a))
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.ff)
                  (@roption.assert.{0} unit ((λ (a : α), not (p a)) a)
                     (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star)))
               a)))
⊢ @computable.{u_1 0} α bool _inst_1 primcodable.bool (λ (a : α), @decidable.to_bool (p a) (_inst_3 a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a)),
k : pfun.{u_1 0} α bool,
pk : @partrec.{u_1 0} α bool _inst_1 primcodable.bool k,
hk :
  ∀ (a : α) (x : bool),
    iff (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x (k a))
      (or
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.tt)
                  (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star)))
               a))
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.ff)
                  (@roption.assert.{0} unit ((λ (a : α), not (p a)) a)
                     (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star)))
               a))),
n : α
⊢ @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool)
    ((λ (a : α), @decidable.to_bool (p a) (_inst_3 a)) n)
    (k n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210      rw hk, simp, apply decidable.em },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='decidable.em'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 630, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : α) (x : bool), iff (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x (k a)) (or (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x ((λ (a : α), @roption.map.{0 0} unit bool (λ (b : unit), bool.tt) (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star))) a)) (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x ((λ (a : α), @roption.map.{0 0} unit bool (λ (b : unit), bool.ff) (@roption.assert.{0} unit ((λ (a : α), not (p a)) a) (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star))) a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : Prop) [_inst_1 : decidable p], or p (not p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a)),
k : pfun.{u_1 0} α bool,
pk : @partrec.{u_1 0} α bool _inst_1 primcodable.bool k,
hk :
  ∀ (a : α) (x : bool),
    iff (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x (k a))
      (or
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.tt)
                  (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star)))
               a))
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.ff)
                  (@roption.assert.{0} unit ((λ (a : α), not (p a)) a)
                     (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star)))
               a))),
n : α
⊢ @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool)
    ((λ (a : α), @decidable.to_bool (p a) (_inst_3 a)) n)
    (k n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a)),
k : pfun.{u_1 0} α bool,
pk : @partrec.{u_1 0} α bool _inst_1 primcodable.bool k,
hk :
  ∀ (a : α) (x : bool),
    iff (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x (k a))
      (or
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.tt)
                  (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star)))
               a))
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.ff)
                  (@roption.assert.{0} unit ((λ (a : α), not (p a)) a)
                     (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star)))
               a))),
n : α
⊢ or
    (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool)
       ((λ (a : α), @decidable.to_bool (p a) (_inst_3 a)) n)
       ((λ (a : α),
           @roption.map.{0 0} unit bool (λ (b : unit), bool.tt)
             (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star)))
          n))
    (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool)
       ((λ (a : α), @decidable.to_bool (p a) (_inst_3 a)) n)
       ((λ (a : α),
           @roption.map.{0 0} unit bool (λ (b : unit), bool.ff)
             (@roption.assert.{0} unit ((λ (a : α), not (p a)) a)
                (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star)))
          n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a)),
k : pfun.{u_1 0} α bool,
pk : @partrec.{u_1 0} α bool _inst_1 primcodable.bool k,
hk :
  ∀ (a : α) (x : bool),
    iff (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x (k a))
      (or
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.tt)
                  (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star)))
               a))
         (@has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
            ((λ (a : α),
                @roption.map.{0 0} unit bool (λ (b : unit), bool.ff)
                  (@roption.assert.{0} unit ((λ (a : α), not (p a)) a)
                     (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star)))
               a))),
n : α
⊢ or (p n) (not (p n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))
⊢ ∀ (a : α) (x : bool),
    @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
      (@roption.map.{0 0} unit bool (λ (b : unit), bool.tt)
         (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star))) →
    ∀ (y : bool),
      @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) y
        (@roption.map.{0 0} unit bool (λ (b : unit), bool.ff)
           (@roption.assert.{0} unit ((λ (a : α), not (p a)) a)
              (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star))) →
      @eq.{1} bool x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211    { intros a x hx y hy, simp at hx hy, cases hy.1 hx.1 }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (not (p a)) (@eq.{1} bool bool.ff y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (p a) (@eq.{1} bool bool.tt x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))
⊢ ∀ (a : α) (x : bool),
    @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
      (@roption.map.{0 0} unit bool (λ (b : unit), bool.tt)
         (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star))) →
    ∀ (y : bool),
      @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) y
        (@roption.map.{0 0} unit bool (λ (b : unit), bool.ff)
           (@roption.assert.{0} unit ((λ (a : α), not (p a)) a)
              (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star))) →
      @eq.{1} bool x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a)),
a : α,
x : bool,
hx :
  @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) x
    (@roption.map.{0 0} unit bool (λ (b : unit), bool.tt)
       (@roption.assert.{0} unit (p a) (λ (_x : p a), @roption.some.{0} unit unit.star))),
y : bool,
hy :
  @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) y
    (@roption.map.{0 0} unit bool (λ (b : unit), bool.ff)
       (@roption.assert.{0} unit ((λ (a : α), not (p a)) a)
          (λ (_x : (λ (a : α), not (p a)) a), @roption.some.{0} unit unit.star)))
⊢ @eq.{1} bool x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : primcodable.{u_1} α,
p : α → Prop,
_inst_3 : @decidable_pred.{u_1+1} α p,
_x : and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))),
_fun_match :
  and (@re_pred.{u_1} α _inst_1 p) (@re_pred.{u_1} α _inst_1 (λ (a : α), not (p a))) →
  @computable_pred.{u_1} α _inst_1 p,
h₁ : @re_pred.{u_1} α _inst_1 p,
h₂ : @re_pred.{u_1} α _inst_1 (λ (a : α), not (p a)),
a : α,
x y : bool,
hy : and (not (p a)) (@eq.{1} bool bool.ff y),
hx : and (p a) (@eq.{1} bool bool.tt x)
⊢ @eq.{1} bool x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  end⟩⟩</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  end computable_pred</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216  namespace nat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  open vector roption</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219  /-- A simplified basis for `partrec`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  inductive partrec&#x27; : ∀ {n}, (vector ℕ n →. ℕ) → Prop</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type → Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  | prim {n f} : @primrec&#x27; n f → @partrec&#x27; n f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.primrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {n : nat}, (vector.{0} nat n → nat) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An alternative inductive definition of `primrec` which
 does not use the pairing function on ℕ, and so has to
 work with n-ary functions on ℕ instead of unary functions.
 We prove that this is equivalent to the regular notion
 in `to_prim` and `of_prim`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  | comp {m n f} (g : fin n → vector ℕ m →. ℕ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n → pfun.{0 0} (vector.{0} nat m) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type → Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223    partrec&#x27; f → (∀ i, partrec&#x27; (g i)) →</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@partrec&#x27; n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='fin n → pfun.{0 0} (vector.{0} nat m) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224    partrec&#x27; (λ v, m_of_fn (λ i, g i v) &gt;&gt;= f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.m_of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_bind.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/vector2.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='vector.{0} nat m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {m : Type u → Type u_1} [_inst_1 : monad.{u u_1} m] {α : Type u} {n : nat}, (fin n → m α) → m (vector.{u} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin n → pfun.{0 0} (vector.{0} nat m) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {m : Type → Type} [c : has_bind.{0 0} m] {α β : Type}, m α → (α → m β) → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  | rfind {n} {f : vector ℕ (n+1) → ℕ} : @partrec&#x27; (n+1) f →</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_to_lift.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_base.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@pfun.has_coe.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226    partrec&#x27; (λ v, rfind (λ n, some (f (n :: v) = 0)))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.rfind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='roption.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{0 0} nat bool → roption.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → roption.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {n : nat}, α → vector.{0} α n → vector.{0} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The `some a` value in `roption` has a `true` domain and the
 function returns `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228  end nat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230  namespace nat.partrec&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  open vector partrec computable nat (partrec&#x27;) nat.partrec&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  theorem to_part {n f} (pf : @partrec&#x27; n f) : partrec f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf : @nat.partrec&#x27; n f
⊢ @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235    induction pf,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='pf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@nat.partrec&#x27; n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf : @nat.partrec&#x27; n f
⊢ @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case nat.partrec&#x27;.prim
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf_n : nat,
pf_f : vector.{0} nat pf_n → nat,
pf_a : @nat.primrec&#x27; pf_n pf_f
⊢ @partrec.{0 0} (vector.{0} nat pf_n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat pf_n → nat) (pfun.{0 0} (vector.{0} nat pf_n) nat)
       (@coe_to_lift.{1 1} (vector.{0} nat pf_n → nat) (pfun.{0 0} (vector.{0} nat pf_n) nat)
          (@coe_base.{1 1} (vector.{0} nat pf_n → nat) (pfun.{0 0} (vector.{0} nat pf_n) nat)
             (@pfun.has_coe.{0 0} (vector.{0} nat pf_n) nat)))
       pf_f)

case nat.partrec&#x27;.comp
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf_m pf_n : nat,
pf_f : pfun.{0 0} (vector.{0} nat pf_n) nat,
pf_g : fin pf_n → pfun.{0 0} (vector.{0} nat pf_m) nat,
pf_a : @nat.partrec&#x27; pf_n pf_f,
pf_a_1 : ∀ (i : fin pf_n), @nat.partrec&#x27; pf_m (pf_g i),
pf_ih_a :
  @partrec.{0 0} (vector.{0} nat pf_n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    pf_f,
pf_ih_a_1 :
  ∀ (i : fin pf_n),
    @(λ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat} (pf : @nat.partrec&#x27; n f),
       @partrec.{0 0} (vector.{0} nat n) nat
         (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
         (@primcodable.of_denumerable.{0} nat denumerable.nat)
         f)
      pf_m
      (pf_g i)
      (pf_a_1 i)
⊢ @partrec.{0 0} (vector.{0} nat pf_m) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_m)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat pf_m),
       @has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat pf_n)
         nat
         (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat pf_n (λ (i : fin pf_n), pf_g i v))
         pf_f)

case nat.partrec&#x27;.rfind
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf_n : nat,
pf_f : vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat,
pf_a :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       pf_f),
pf_ih :
  @partrec.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)
       (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       pf_f)
⊢ @partrec.{0 0} (vector.{0} nat pf_n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat pf_n),
       nat.rfind
         (λ (n : nat),
            @roption.some.{0} bool
              (@decidable.to_bool
                 (@eq.{1} nat (pf_f (@vector.cons.{0} nat pf_n n v)) (@has_zero.zero.{0} nat nat.has_zero))
                 (nat.decidable_eq (pf_f (@vector.cons.{0} nat pf_n n v)) (@has_zero.zero.{0} nat nat.has_zero)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236    case nat.partrec&#x27;.prim : n f hf { exact hf.to_prim.to_comp },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 682, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1151, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 682, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_))) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@nat.primrec&#x27; n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_))) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Focuses on the `induction`/`cases`/`with_cases` subgoal corresponding to the given tag prefix, optionally renaming introduced locals.

```lean
example (n : ℕ) : n = n :=
begin
  induction n,
  case nat.zero { reflexivity },
  case nat.succ : a ih { reflexivity }
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Focuses on the `induction`/`cases`/`with_cases` subgoal corresponding to the given tag prefix, optionally renaming introduced locals.

```lean
example (n : ℕ) : n = n :=
begin
  induction n,
  case nat.zero { reflexivity },
  case nat.succ : a ih { reflexivity }
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='case'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='case'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(: id*)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(: id*)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case nat.partrec&#x27;.prim
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf_n : nat,
pf_f : vector.{0} nat pf_n → nat,
pf_a : @nat.primrec&#x27; pf_n pf_f
⊢ @partrec.{0 0} (vector.{0} nat pf_n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat pf_n → nat) (pfun.{0 0} (vector.{0} nat pf_n) nat)
       (@coe_to_lift.{1 1} (vector.{0} nat pf_n → nat) (pfun.{0 0} (vector.{0} nat pf_n) nat)
          (@coe_base.{1 1} (vector.{0} nat pf_n → nat) (pfun.{0 0} (vector.{0} nat pf_n) nat)
             (@pfun.has_coe.{0 0} (vector.{0} nat pf_n) nat)))
       pf_f)

case nat.partrec&#x27;.comp
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf_m pf_n : nat,
pf_f : pfun.{0 0} (vector.{0} nat pf_n) nat,
pf_g : fin pf_n → pfun.{0 0} (vector.{0} nat pf_m) nat,
pf_a : @nat.partrec&#x27; pf_n pf_f,
pf_a_1 : ∀ (i : fin pf_n), @nat.partrec&#x27; pf_m (pf_g i),
pf_ih_a :
  @partrec.{0 0} (vector.{0} nat pf_n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    pf_f,
pf_ih_a_1 :
  ∀ (i : fin pf_n),
    @(λ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat} (pf : @nat.partrec&#x27; n f),
       @partrec.{0 0} (vector.{0} nat n) nat
         (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
         (@primcodable.of_denumerable.{0} nat denumerable.nat)
         f)
      pf_m
      (pf_g i)
      (pf_a_1 i)
⊢ @partrec.{0 0} (vector.{0} nat pf_m) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_m)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat pf_m),
       @has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat pf_n)
         nat
         (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat pf_n (λ (i : fin pf_n), pf_g i v))
         pf_f)

case nat.partrec&#x27;.rfind
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf_n : nat,
pf_f : vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat,
pf_a :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       pf_f),
pf_ih :
  @partrec.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)
       (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       pf_f)
⊢ @partrec.{0 0} (vector.{0} nat pf_n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat pf_n),
       nat.rfind
         (λ (n : nat),
            @roption.some.{0} bool
              (@decidable.to_bool
                 (@eq.{1} nat (pf_f (@vector.cons.{0} nat pf_n n v)) (@has_zero.zero.{0} nat nat.has_zero))
                 (nat.decidable_eq (pf_f (@vector.cons.{0} nat pf_n n v)) (@has_zero.zero.{0} nat nat.has_zero)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.partrec&#x27;.prim
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
n : nat,
f : vector.{0} nat n → nat,
hf : @nat.primrec&#x27; n f
⊢ @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
       (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
          (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
             (@pfun.has_coe.{0 0} (vector.{0} nat n) nat)))
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case nat.partrec&#x27;.comp
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf_m pf_n : nat,
pf_f : pfun.{0 0} (vector.{0} nat pf_n) nat,
pf_g : fin pf_n → pfun.{0 0} (vector.{0} nat pf_m) nat,
pf_a : @nat.partrec&#x27; pf_n pf_f,
pf_a_1 : ∀ (i : fin pf_n), @nat.partrec&#x27; pf_m (pf_g i),
pf_ih_a :
  @partrec.{0 0} (vector.{0} nat pf_n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    pf_f,
pf_ih_a_1 :
  ∀ (i : fin pf_n),
    @(λ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat} (pf : @nat.partrec&#x27; n f),
       @partrec.{0 0} (vector.{0} nat n) nat
         (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
         (@primcodable.of_denumerable.{0} nat denumerable.nat)
         f)
      pf_m
      (pf_g i)
      (pf_a_1 i)
⊢ @partrec.{0 0} (vector.{0} nat pf_m) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_m)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat pf_m),
       @has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat pf_n)
         nat
         (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat pf_n (λ (i : fin pf_n), pf_g i v))
         pf_f)

case nat.partrec&#x27;.rfind
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf_n : nat,
pf_f : vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat,
pf_a :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       pf_f),
pf_ih :
  @partrec.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)
       (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       pf_f)
⊢ @partrec.{0 0} (vector.{0} nat pf_n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat pf_n),
       nat.rfind
         (λ (n : nat),
            @roption.some.{0} bool
              (@decidable.to_bool
                 (@eq.{1} nat (pf_f (@vector.cons.{0} nat pf_n n v)) (@has_zero.zero.{0} nat nat.has_zero))
                 (nat.decidable_eq (pf_f (@vector.cons.{0} nat pf_n n v)) (@has_zero.zero.{0} nat nat.has_zero)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237    case nat.partrec&#x27;.comp : m n f g _ _ hf hg {</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 682, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_))) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Focuses on the `induction`/`cases`/`with_cases` subgoal corresponding to the given tag prefix, optionally renaming introduced locals.

```lean
example (n : ℕ) : n = n :=
begin
  induction n,
  case nat.zero { reflexivity },
  case nat.succ : a ih { reflexivity }
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='case'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(: id*)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case nat.partrec&#x27;.comp
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf_m pf_n : nat,
pf_f : pfun.{0 0} (vector.{0} nat pf_n) nat,
pf_g : fin pf_n → pfun.{0 0} (vector.{0} nat pf_m) nat,
pf_a : @nat.partrec&#x27; pf_n pf_f,
pf_a_1 : ∀ (i : fin pf_n), @nat.partrec&#x27; pf_m (pf_g i),
pf_ih_a :
  @partrec.{0 0} (vector.{0} nat pf_n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    pf_f,
pf_ih_a_1 :
  ∀ (i : fin pf_n),
    @(λ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat} (pf : @nat.partrec&#x27; n f),
       @partrec.{0 0} (vector.{0} nat n) nat
         (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
         (@primcodable.of_denumerable.{0} nat denumerable.nat)
         f)
      pf_m
      (pf_g i)
      (pf_a_1 i)
⊢ @partrec.{0 0} (vector.{0} nat pf_m) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_m)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat pf_m),
       @has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat pf_n)
         nat
         (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat pf_n (λ (i : fin pf_n), pf_g i v))
         pf_f)

case nat.partrec&#x27;.rfind
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf_n : nat,
pf_f : vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat,
pf_a :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       pf_f),
pf_ih :
  @partrec.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)
       (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       pf_f)
⊢ @partrec.{0 0} (vector.{0} nat pf_n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat pf_n),
       nat.rfind
         (λ (n : nat),
            @roption.some.{0} bool
              (@decidable.to_bool
                 (@eq.{1} nat (pf_f (@vector.cons.{0} nat pf_n n v)) (@has_zero.zero.{0} nat nat.has_zero))
                 (nat.decidable_eq (pf_f (@vector.cons.{0} nat pf_n n v)) (@has_zero.zero.{0} nat nat.has_zero)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.partrec&#x27;.comp
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
m n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
g : fin n → pfun.{0 0} (vector.{0} nat m) nat,
pf_a : @nat.partrec&#x27; n f,
pf_a_1 : ∀ (i : fin n), @nat.partrec&#x27; m (g i),
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f,
hg :
  ∀ (i : fin n),
    @(λ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat} (pf : @nat.partrec&#x27; n f),
       @partrec.{0 0} (vector.{0} nat n) nat
         (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
         (@primcodable.of_denumerable.{0} nat denumerable.nat)
         f)
      m
      (g i)
      (pf_a_1 i)
⊢ @partrec.{0 0} (vector.{0} nat m) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) m)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat m),
       @has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat n) nat
         (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat n (λ (i : fin n), g i v))
         f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238      exact (vector_m_of_fn (λ i, hg i)).bind (hf.comp snd) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='partrec.vector_m_of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 682, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 477, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 682, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_))) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_4 : primcodable.{0} σ] {n : nat} {f : fin n → pfun.{0 0} α σ}, (∀ (i : fin n), @partrec.{0 0} α σ _inst_1 _inst_4 (f i)) → @partrec.{0 0} α (vector.{0} σ n) _inst_1 (@primcodable.vector.{0} σ _inst_4 n) (λ (a : α), @vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} σ n (λ (i : fin n), f i a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i : fin n), @(λ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat} (pf : @nat.partrec&#x27; n f), @partrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f) m (g i) (pf_a_1 i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@partrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β], @computable.{0 0} (prod.{0 0} α β) β (@primcodable.prod.{0 0} α β _inst_1 _inst_2) _inst_2 (@prod.snd.{0 0} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_))) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Focuses on the `induction`/`cases`/`with_cases` subgoal corresponding to the given tag prefix, optionally renaming introduced locals.

```lean
example (n : ℕ) : n = n :=
begin
  induction n,
  case nat.zero { reflexivity },
  case nat.succ : a ih { reflexivity }
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Focuses on the `induction`/`cases`/`with_cases` subgoal corresponding to the given tag prefix, optionally renaming introduced locals.

```lean
example (n : ℕ) : n = n :=
begin
  induction n,
  case nat.zero { reflexivity },
  case nat.succ : a ih { reflexivity }
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='case'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='case'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(: id*)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(: id*)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.partrec&#x27;.comp
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
m n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
g : fin n → pfun.{0 0} (vector.{0} nat m) nat,
pf_a : @nat.partrec&#x27; n f,
pf_a_1 : ∀ (i : fin n), @nat.partrec&#x27; m (g i),
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f,
hg :
  ∀ (i : fin n),
    @(λ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat} (pf : @nat.partrec&#x27; n f),
       @partrec.{0 0} (vector.{0} nat n) nat
         (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
         (@primcodable.of_denumerable.{0} nat denumerable.nat)
         f)
      m
      (g i)
      (pf_a_1 i)
⊢ @partrec.{0 0} (vector.{0} nat m) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) m)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat m),
       @has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat n) nat
         (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat n (λ (i : fin n), g i v))
         f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.partrec&#x27;.rfind
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf_n : nat,
pf_f : vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat,
pf_a :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       pf_f),
pf_ih :
  @partrec.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)
       (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       pf_f)
⊢ @partrec.{0 0} (vector.{0} nat pf_n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat pf_n),
       nat.rfind
         (λ (n : nat),
            @roption.some.{0} bool
              (@decidable.to_bool
                 (@eq.{1} nat (pf_f (@vector.cons.{0} nat pf_n n v)) (@has_zero.zero.{0} nat nat.has_zero))
                 (nat.decidable_eq (pf_f (@vector.cons.{0} nat pf_n n v)) (@has_zero.zero.{0} nat nat.has_zero)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239    case nat.partrec&#x27;.rfind : n f _ hf {</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 682, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_))) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Focuses on the `induction`/`cases`/`with_cases` subgoal corresponding to the given tag prefix, optionally renaming introduced locals.

```lean
example (n : ℕ) : n = n :=
begin
  induction n,
  case nat.zero { reflexivity },
  case nat.succ : a ih { reflexivity }
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='case'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(: id*)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.partrec&#x27;.rfind
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
pf_n : nat,
pf_f : vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat,
pf_a :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       pf_f),
pf_ih :
  @partrec.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)
       (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add pf_n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       pf_f)
⊢ @partrec.{0 0} (vector.{0} nat pf_n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) pf_n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat pf_n),
       nat.rfind
         (λ (n : nat),
            @roption.some.{0} bool
              (@decidable.to_bool
                 (@eq.{1} nat (pf_f (@vector.cons.{0} nat pf_n n v)) (@has_zero.zero.{0} nat nat.has_zero))
                 (nat.decidable_eq (pf_f (@vector.cons.{0} nat pf_n n v)) (@has_zero.zero.{0} nat nat.has_zero)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.partrec&#x27;.rfind
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
pf_a :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
hf :
  @partrec.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)
       (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f)
⊢ @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat n),
       nat.rfind
         (λ (n_1 : nat),
            @roption.some.{0} bool
              (@decidable.to_bool (@eq.{1} nat (f (@vector.cons.{0} nat n n_1 v)) (@has_zero.zero.{0} nat nat.has_zero))
                 (nat.decidable_eq (f (@vector.cons.{0} nat n n_1 v)) (@has_zero.zero.{0} nat nat.has_zero)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240      have := ((primrec.eq.comp primrec.id (primrec.const 0)).to_comp.comp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='primrec.eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='primrec.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='primrec.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 682, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 603, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 183, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 179, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_))) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α] [_inst_6 : decidable_eq.{1} α], @primrec_rel.{0 0} α α _inst_1 _inst_1 (@eq.{1} α) (λ (a b : α), _inst_6 a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α], @primrec.{0 0} α α _inst_1 _inst_1 (@id.{1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_3 : primcodable.{0} σ] (x : σ), @primrec.{0 0} α σ _inst_1 _inst_3 (λ (a : α), x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Focuses on the `induction`/`cases`/`with_cases` subgoal corresponding to the given tag prefix, optionally renaming introduced locals.

```lean
example (n : ℕ) : n = n :=
begin
  induction n,
  case nat.zero { reflexivity },
  case nat.succ : a ih { reflexivity }
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='case'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(: id*)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.partrec&#x27;.rfind
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
pf_a :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
hf :
  @partrec.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)
       (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f)
⊢ @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat n),
       nat.rfind
         (λ (n_1 : nat),
            @roption.some.{0} bool
              (@decidable.to_bool (@eq.{1} nat (f (@vector.cons.{0} nat n n_1 v)) (@has_zero.zero.{0} nat nat.has_zero))
                 (nat.decidable_eq (f (@vector.cons.{0} nat n n_1 v)) (@has_zero.zero.{0} nat nat.has_zero)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241        (hf.comp (vector_cons.comp snd fst))).to₂.part,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable.vector_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 287, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 261, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 682, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@partrec.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) (@primcodable.of_denumerable.{0} nat denumerable.nat) (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_to_lift.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_base.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@pfun.has_coe.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α] {n : nat}, @computable₂.{0 0 0} α (vector.{0} α n) (vector.{0} α (nat.succ n)) _inst_1 (@primcodable.vector.{0} α _inst_1 n) (@primcodable.vector.{0} α _inst_1 (nat.succ n)) (@vector.cons.{0} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β], @computable.{0 0} (prod.{0 0} α β) β (@primcodable.prod.{0 0} α β _inst_1 _inst_2) _inst_2 (@prod.snd.{0 0} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β], @computable.{0 0} (prod.{0 0} α β) α (@primcodable.prod.{0 0} α β _inst_1 _inst_2) _inst_1 (@prod.fst.{0 0} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_))) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Focuses on the `induction`/`cases`/`with_cases` subgoal corresponding to the given tag prefix, optionally renaming introduced locals.

```lean
example (n : ℕ) : n = n :=
begin
  induction n,
  case nat.zero { reflexivity },
  case nat.succ : a ih { reflexivity }
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='case'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(: id*)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.partrec&#x27;.rfind
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
pf_a :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
hf :
  @partrec.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)
       (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f)
⊢ @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat n),
       nat.rfind
         (λ (n_1 : nat),
            @roption.some.{0} bool
              (@decidable.to_bool (@eq.{1} nat (f (@vector.cons.{0} nat n n_1 v)) (@has_zero.zero.{0} nat nat.has_zero))
                 (nat.decidable_eq (f (@vector.cons.{0} nat n n_1 v)) (@has_zero.zero.{0} nat nat.has_zero)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
pf_a :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
hf :
  @partrec.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)
       (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
this :
  @partrec₂.{0 0 0} (vector.{0} nat n) nat bool
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    primcodable.bool
    (λ (a : vector.{0} nat n),
       @coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
         (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
            (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
         ((λ (a : vector.{0} nat n) (b : nat),
             @decidable.to_bool
               ((λ (a : nat), @eq.{1} nat (@id.{1} nat a) (@has_zero.zero.{0} nat nat.has_zero))
                  (f
                     (@vector.cons.{0} nat n
                        (@prod.snd.{0 0} (vector.{0} nat n) nat (@prod.mk.{0 0} (vector.{0} nat n) nat a b))
                        (@prod.fst.{0 0} (vector.{0} nat n) nat (@prod.mk.{0 0} (vector.{0} nat n) nat a b)))))
               ((λ (a : nat), nat.decidable_eq (@id.{1} nat a) (@has_zero.zero.{0} nat nat.has_zero))
                  (f
                     (@vector.cons.{0} nat n
                        (@prod.snd.{0 0} (vector.{0} nat n) nat (@prod.mk.{0 0} (vector.{0} nat n) nat a b))
                        (@prod.fst.{0 0} (vector.{0} nat n) nat (@prod.mk.{0 0} (vector.{0} nat n) nat a b))))))
            a))
⊢ @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat n),
       nat.rfind
         (λ (n_1 : nat),
            @roption.some.{0} bool
              (@decidable.to_bool (@eq.{1} nat (f (@vector.cons.{0} nat n n_1 v)) (@has_zero.zero.{0} nat nat.has_zero))
                 (nat.decidable_eq (f (@vector.cons.{0} nat n n_1 v)) (@has_zero.zero.{0} nat nat.has_zero)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242      exact this.rfind },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 682, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 436, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 682, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_))) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@partrec₂.{0 0 0} (vector.{0} nat n) nat bool (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) primcodable.bool (λ (a : vector.{0} nat n), @coe.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool))) ((λ (a : vector.{0} nat n) (b : nat), @decidable.to_bool ((λ (a : nat), @eq.{1} nat (@id.{1} nat a) (@has_zero.zero.{0} nat nat.has_zero)) (f (@vector.cons.{0} nat n (@prod.snd.{0 0} (vector.{0} nat n) nat (@prod.mk.{0 0} (vector.{0} nat n) nat a b)) (@prod.fst.{0 0} (vector.{0} nat n) nat (@prod.mk.{0 0} (vector.{0} nat n) nat a b))))) ((λ (a : nat), nat.decidable_eq (@id.{1} nat a) (@has_zero.zero.{0} nat nat.has_zero)) (f (@vector.cons.{0} nat n (@prod.snd.{0 0} (vector.{0} nat n) nat (@prod.mk.{0 0} (vector.{0} nat n) nat a b)) (@prod.fst.{0 0} (vector.{0} nat n) nat (@prod.mk.{0 0} (vector.{0} nat n) nat a b)))))) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_))) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Focuses on the `induction`/`cases`/`with_cases` subgoal corresponding to the given tag prefix, optionally renaming introduced locals.

```lean
example (n : ℕ) : n = n :=
begin
  induction n,
  case nat.zero { reflexivity },
  case nat.succ : a ih { reflexivity }
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Focuses on the `induction`/`cases`/`with_cases` subgoal corresponding to the given tag prefix, optionally renaming introduced locals.

```lean
example (n : ℕ) : n = n :=
begin
  induction n,
  case nat.zero { reflexivity },
  case nat.succ : a ih { reflexivity }
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='case'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='case'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(: id*)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(: id*)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
pf_a :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
hf :
  @partrec.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)
       (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
this :
  @partrec₂.{0 0 0} (vector.{0} nat n) nat bool
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    primcodable.bool
    (λ (a : vector.{0} nat n),
       @coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
         (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
            (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
         ((λ (a : vector.{0} nat n) (b : nat),
             @decidable.to_bool
               ((λ (a : nat), @eq.{1} nat (@id.{1} nat a) (@has_zero.zero.{0} nat nat.has_zero))
                  (f
                     (@vector.cons.{0} nat n
                        (@prod.snd.{0 0} (vector.{0} nat n) nat (@prod.mk.{0 0} (vector.{0} nat n) nat a b))
                        (@prod.fst.{0 0} (vector.{0} nat n) nat (@prod.mk.{0 0} (vector.{0} nat n) nat a b)))))
               ((λ (a : nat), nat.decidable_eq (@id.{1} nat a) (@has_zero.zero.{0} nat nat.has_zero))
                  (f
                     (@vector.cons.{0} nat n
                        (@prod.snd.{0 0} (vector.{0} nat n) nat (@prod.mk.{0 0} (vector.{0} nat n) nat a b))
                        (@prod.fst.{0 0} (vector.{0} nat n) nat (@prod.mk.{0 0} (vector.{0} nat n) nat a b))))))
            a))
⊢ @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat n),
       nat.rfind
         (λ (n_1 : nat),
            @roption.some.{0} bool
              (@decidable.to_bool (@eq.{1} nat (f (@vector.cons.{0} nat n n_1 v)) (@has_zero.zero.{0} nat nat.has_zero))
                 (nat.decidable_eq (f (@vector.cons.{0} nat n n_1 v)) (@has_zero.zero.{0} nat nat.has_zero)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  theorem of_eq {n} {f g : vector ℕ n →. ℕ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type → Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246    (hf : partrec&#x27; f) (H : ∀ i, f i = g i) : partrec&#x27; g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  (funext H : f = g) ▸ hf</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {β : α → Type} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{1} (β x) (f₁ x) (f₂ x)) → @eq.{1} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : vector.{0} nat n), @eq.{1} (roption.{0} nat) (f i) (g i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} {P : α → Prop} {a b : α}, @eq.{1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@nat.partrec&#x27; n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  theorem of_prim {n} {f : vector ℕ n → ℕ} (hf : primrec f) : @partrec&#x27; n f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='primrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 147, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title='`primrec f` means `f` is primitive recursive (after
 encoding its input and output as natural numbers).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  prim (nat.primrec&#x27;.of_prim hf)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.partrec&#x27;.prim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.primrec&#x27;.of_prim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1295, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {f : vector.{0} nat n → nat}, @nat.primrec&#x27; n f → @nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {n : nat} {f : vector.{0} nat n → nat}, @primrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f → @nat.primrec&#x27; n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@primrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252  theorem head {n : ℕ} : @partrec&#x27; n.succ (@head ℕ n) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='vector.head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {n : nat}, vector.{u} α (nat.succ n) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  prim nat.primrec&#x27;.head</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.partrec&#x27;.prim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.primrec&#x27;.head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1175, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {f : vector.{0} nat n → nat}, @nat.primrec&#x27; n f → @nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n : nat}, @nat.primrec&#x27; (nat.succ n) (@vector.head.{0} nat n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  theorem tail {n f} (hf : @partrec&#x27; n f) : @partrec&#x27; n.succ (λ v, f v.tail) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.tail'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='vector.{0} nat (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {n : nat}, vector.{0} α n → vector.{0} α (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  (hf.comp _ (λ i, @prim _ _ $ nat.primrec&#x27;.nth i.succ)).of_eq $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.partrec&#x27;.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.partrec&#x27;.prim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat.primrec&#x27;.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec&#x27;.of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/ops.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 245, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@nat.partrec&#x27; n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat} (g : fin n → pfun.{0 0} (vector.{0} nat m) nat), @nat.partrec&#x27; n f → (∀ (i : fin n), @nat.partrec&#x27; m (g i)) → @nat.partrec&#x27; m (λ (v : vector.{0} nat m), @has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat n) nat (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat n (λ (i : fin n), g i v)) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {n : nat} {f : vector.{0} nat n → nat}, @nat.primrec&#x27; n f → @nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {n : nat} (i : fin n), @nat.primrec&#x27; n (λ (v : vector.{0} nat n), @vector.nth.{0} nat n v i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → fin (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {n : nat} {f g : pfun.{0 0} (vector.{0} nat n) nat}, @nat.partrec&#x27; n f → (∀ (i : vector.{0} nat n), @eq.{1} (roption.{0} nat) (f i) (g i)) → @nat.partrec&#x27; n g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  λ v, by simp; rw [← of_fn_nth v.tail]; congr; funext i; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='vector.of_fn_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/vector2.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{0} nat (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type} (v : vector.{0} α n), @eq.{1} (vector.{0} α n) (@vector.of_fn.{0} α n (@vector.nth.{0} α n v)) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{0} nat (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf : @nat.partrec&#x27; n f,
v : vector.{0} nat (nat.succ n)
⊢ @eq.{1} (roption.{0} nat)
    (@has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat n) nat
       (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat n
          (λ (i : fin n),
             @coe.{1 1} (vector.{0} nat (nat.succ n) → nat) (pfun.{0 0} (vector.{0} nat (nat.succ n)) nat)
               (@coe_to_lift.{1 1} (vector.{0} nat (nat.succ n) → nat) (pfun.{0 0} (vector.{0} nat (nat.succ n)) nat)
                  (@coe_base.{1 1} (vector.{0} nat (nat.succ n) → nat) (pfun.{0 0} (vector.{0} nat (nat.succ n)) nat)
                     (@pfun.has_coe.{0 0} (vector.{0} nat (nat.succ n)) nat)))
               (λ (v : vector.{0} nat (nat.succ n)), @vector.nth.{0} nat (nat.succ n) v (@fin.succ n i))
               v))
       f)
    (f (@vector.tail.{0} nat (nat.succ n) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf : @nat.partrec&#x27; n f,
v : vector.{0} nat (nat.succ n)
⊢ @eq.{1} (roption.{0} nat)
    (f (@vector.of_fn.{0} nat n (λ (i : fin n), @vector.nth.{0} nat (nat.succ n) v (@fin.succ n i))))
    (f (@vector.tail.{0} nat (nat.succ n) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf : @nat.partrec&#x27; n f,
v : vector.{0} nat (nat.succ n)
⊢ @eq.{1} (roption.{0} nat)
    (f (@vector.of_fn.{0} nat n (λ (i : fin n), @vector.nth.{0} nat (nat.succ n) v (@fin.succ n i))))
    (f
       (@vector.of_fn.{0} nat (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))
          (@vector.nth.{0} nat (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))
             (@vector.tail.{0} nat (nat.succ n) v))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf : @nat.partrec&#x27; n f,
v : vector.{0} nat (nat.succ n)
⊢ @eq.{1} (roption.{0} nat)
    (@has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat n) nat
       (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat n
          (λ (i : fin n),
             @coe.{1 1} (vector.{0} nat (nat.succ n) → nat) (pfun.{0 0} (vector.{0} nat (nat.succ n)) nat)
               (@coe_to_lift.{1 1} (vector.{0} nat (nat.succ n) → nat) (pfun.{0 0} (vector.{0} nat (nat.succ n)) nat)
                  (@coe_base.{1 1} (vector.{0} nat (nat.succ n) → nat) (pfun.{0 0} (vector.{0} nat (nat.succ n)) nat)
                     (@pfun.has_coe.{0 0} (vector.{0} nat (nat.succ n)) nat)))
               (λ (v : vector.{0} nat (nat.succ n)), @vector.nth.{0} nat (nat.succ n) v (@fin.succ n i))
               v))
       f)
    (f (@vector.tail.{0} nat (nat.succ n) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf : @nat.partrec&#x27; n f,
v : vector.{0} nat (nat.succ n)
⊢ @eq.{1} (roption.{0} nat)
    (@has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat n) nat
       (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat n
          (λ (i : fin n),
             @coe.{1 1} (vector.{0} nat (nat.succ n) → nat) (pfun.{0 0} (vector.{0} nat (nat.succ n)) nat)
               (@coe_to_lift.{1 1} (vector.{0} nat (nat.succ n) → nat) (pfun.{0 0} (vector.{0} nat (nat.succ n)) nat)
                  (@coe_base.{1 1} (vector.{0} nat (nat.succ n) → nat) (pfun.{0 0} (vector.{0} nat (nat.succ n)) nat)
                     (@pfun.has_coe.{0 0} (vector.{0} nat (nat.succ n)) nat)))
               (λ (v : vector.{0} nat (nat.succ n)), @vector.nth.{0} nat (nat.succ n) v (@fin.succ n i))
               v))
       f)
    (f (@vector.tail.{0} nat (nat.succ n) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  protected theorem bind {n f g}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260    (hf : @partrec&#x27; n f) (hg : @partrec&#x27; (n+1) g) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261    @partrec&#x27; n (λ v, (f v).bind (λ a, g (a :: v))) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type}, roption.{0} α → (α → roption.{0} β) → roption.{0} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {n : nat}, α → vector.{0} α n → vector.{0} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The bind operation has value `g (f.get)`, and is defined when all the
 parts are defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  (@comp n (n+1) g</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec&#x27;.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {m n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat} (g : fin n → pfun.{0 0} (vector.{0} nat m) nat), @nat.partrec&#x27; n f → (∀ (i : fin n), @nat.partrec&#x27; m (g i)) → @nat.partrec&#x27; m (λ (v : vector.{0} nat m), @has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat n) nat (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat n (λ (i : fin n), g i v)) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263    (λ i, fin.cases f (λ i v, some (v.nth i)) i) hg</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fin.lean&#x27;, &#x27;line&#x27;: 244, &#x27;column&#x27;: 26}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat} {C : fin (nat.succ n) → Type}, C (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n)) → (Π (i : fin n), C (@fin.succ n i)) → Π (i : fin (nat.succ n)), C i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → option.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {n : nat}, vector.{0} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264    (λ i, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
g : pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat,
hf : @nat.partrec&#x27; n f,
hg : @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) g,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
⊢ @nat.partrec&#x27; n
    ((λ (i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))),
        @fin.cases.{1} n
          (λ (_x : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))),
             pfun.{0 0} (vector.{0} nat n) nat)
          f
          (λ (i : fin n) (v : vector.{0} nat n),
             @coe.{1 1} (option.{0} nat) (roption.{0} nat)
               (@coe_to_lift.{1 1} (option.{0} nat) (roption.{0} nat)
                  (@coe_base.{1 1} (option.{0} nat) (roption.{0} nat) (@roption.has_coe.{0} nat)))
               (@option.some.{0} nat (@vector.nth.{0} nat n v i)))
          i)
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265      refine fin.cases _ (λ i, _) i; simp *,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='fin.cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fin.lean&#x27;, &#x27;line&#x27;: 244, &#x27;column&#x27;: 26}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {C : fin (nat.succ n) → Prop}, C (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n)) → (∀ (i : fin n), C (@fin.succ n i)) → ∀ (i : fin (nat.succ n)), C i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
g : pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat,
hf : @nat.partrec&#x27; n f,
hg : @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) g,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
⊢ @nat.partrec&#x27; n
    ((λ (i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))),
        @fin.cases.{1} n
          (λ (_x : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))),
             pfun.{0 0} (vector.{0} nat n) nat)
          f
          (λ (i : fin n) (v : vector.{0} nat n),
             @coe.{1 1} (option.{0} nat) (roption.{0} nat)
               (@coe_to_lift.{1 1} (option.{0} nat) (roption.{0} nat)
                  (@coe_base.{1 1} (option.{0} nat) (roption.{0} nat) (@roption.has_coe.{0} nat)))
               (@option.some.{0} nat (@vector.nth.{0} nat n v i)))
          i)
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
g : pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat,
hf : @nat.partrec&#x27; n f,
hg : @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) g,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
i : fin n
⊢ @nat.partrec&#x27; n (λ (v : vector.{0} nat n), @roption.some.{0} nat (@vector.nth.{0} nat n v i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266      exact prim (nat.primrec&#x27;.nth _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='nat.partrec&#x27;.prim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.primrec&#x27;.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {f : vector.{0} nat n → nat}, @nat.primrec&#x27; n f → @nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n : nat} (i : fin n), @nat.primrec&#x27; n (λ (v : vector.{0} nat n), @vector.nth.{0} nat n v i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
g : pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat,
hf : @nat.partrec&#x27; n f,
hg : @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) g,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
i : fin n
⊢ @nat.partrec&#x27; n (λ (v : vector.{0} nat n), @roption.some.{0} nat (@vector.nth.{0} nat n v i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267    end)).of_eq $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat.partrec&#x27;.of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 245, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {n : nat} {f g : pfun.{0 0} (vector.{0} nat n) nat}, @nat.partrec&#x27; n f → (∀ (i : vector.{0} nat n), @eq.{1} (roption.{0} nat) (f i) (g i)) → @nat.partrec&#x27; n g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
g : pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat,
hf : @nat.partrec&#x27; n f,
hg : @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) g,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
i : fin n
⊢ @nat.partrec&#x27; n (λ (v : vector.{0} nat n), @roption.some.{0} nat (@vector.nth.{0} nat n v i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  λ v, by simp [m_of_fn, roption.bind_assoc, pure]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='vector.m_of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='roption.bind_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/vector2.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 232, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {m : Type ?l_1 → Type ?l_2} [_inst_1 : monad.{?l_1 ?l_2} m] {α : Type ?l_1} {n : nat}, (fin n → m α) → m (vector.{?l_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} (f : roption.{?l_1} α) (g : α → roption.{?l_2} β) (k : β → roption.{?l_3} γ), @eq.{?l_3+1} (roption.{?l_3} γ) (@roption.bind.{?l_2 ?l_3} β γ (@roption.bind.{?l_1 ?l_2} α β f g) k) (@roption.bind.{?l_1 ?l_3} α γ f (λ (x : α), @roption.bind.{?l_2 ?l_3} β γ (g x) k))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
g : pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat,
hf : @nat.partrec&#x27; n f,
hg : @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) g,
v : vector.{0} nat n
⊢ @eq.{1} (roption.{0} nat)
    (@has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0})
       (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
       nat
       (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat
          (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (λ (i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))),
             (λ (i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))),
                @fin.cases.{1} n
                  (λ (_x : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))),
                     pfun.{0 0} (vector.{0} nat n) nat)
                  f
                  (λ (i : fin n) (v : vector.{0} nat n),
                     @coe.{1 1} (option.{0} nat) (roption.{0} nat)
                       (@coe_to_lift.{1 1} (option.{0} nat) (roption.{0} nat)
                          (@coe_base.{1 1} (option.{0} nat) (roption.{0} nat) (@roption.has_coe.{0} nat)))
                       (@option.some.{0} nat (@vector.nth.{0} nat n v i)))
                  i)
               i
               v))
       g)
    (@roption.bind.{0 0} nat nat (f v) (λ (a : nat), g (@vector.cons.{0} nat n a v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
g : pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat,
hf : @nat.partrec&#x27; n f,
hg : @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) g,
v : vector.{0} nat n
⊢ @eq.{1} (roption.{0} nat)
    (@has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0})
       (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
       nat
       (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat
          (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (λ (i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))),
             (λ (i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))),
                @fin.cases.{1} n
                  (λ (_x : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))),
                     pfun.{0 0} (vector.{0} nat n) nat)
                  f
                  (λ (i : fin n) (v : vector.{0} nat n),
                     @coe.{1 1} (option.{0} nat) (roption.{0} nat)
                       (@coe_to_lift.{1 1} (option.{0} nat) (roption.{0} nat)
                          (@coe_base.{1 1} (option.{0} nat) (roption.{0} nat) (@roption.has_coe.{0} nat)))
                       (@option.some.{0} nat (@vector.nth.{0} nat n v i)))
                  i)
               i
               v))
       g)
    (@roption.bind.{0 0} nat nat (f v) (λ (a : nat), g (@vector.cons.{0} nat n a v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  protected theorem map {n f} {g : vector ℕ (n+1) → ℕ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271    (hf : @partrec&#x27; n f) (hg : @partrec&#x27; (n+1) g) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272    @partrec&#x27; n (λ v, (f v).map (λ a, g (a :: v))) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 186, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type}, (α → β) → roption.{0} α → roption.{0} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {n : nat}, α → vector.{0} α n → vector.{0} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The map operation for `roption` just maps the value and maintains the same domain.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  by simp [(roption.bind_some_eq_map _ _).symm];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='roption.bind_some_eq_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 228, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} (f : α → β) (x : roption.{?l_1} α), @eq.{?l_2+1} (roption.{?l_2} β) (@roption.bind.{?l_1 ?l_2} α β x (@function.comp.{?l_1+1 ?l_2+1 ?l_2+1} α β (roption.{?l_2} β) (@roption.some.{?l_2} β) f)) (@roption.map.{?l_1 ?l_2} α β f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
g : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf : @nat.partrec&#x27; n f,
hg :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       g)
⊢ @nat.partrec&#x27; n
    (λ (v : vector.{0} nat n), @roption.map.{0 0} nat nat (λ (a : nat), g (@vector.cons.{0} nat n a v)) (f v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274     exact hf.bind hg</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 259, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@nat.partrec&#x27; n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_to_lift.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_base.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@pfun.has_coe.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat))) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
g : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf : @nat.partrec&#x27; n f,
hg :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       g)
⊢ @nat.partrec&#x27; n
    (λ (v : vector.{0} nat n), @roption.map.{0 0} nat nat (λ (a : nat), g (@vector.cons.{0} nat n a v)) (f v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
g : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf : @nat.partrec&#x27; n f,
hg :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       g)
⊢ @nat.partrec&#x27; n
    (λ (v : vector.{0} nat n), @roption.map.{0 0} nat nat (λ (a : nat), g (@vector.cons.{0} nat n a v)) (f v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276  def vec {n m} (f : vector ℕ n → vector ℕ m) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277  ∀ i, partrec&#x27; (λ v, (f v).nth i)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{0} nat n → vector.{0} nat m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {n : nat}, vector.{0} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279  theorem vec.prim {n m f} (hf : @nat.primrec&#x27;.vec n m f) : vec f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='nat.primrec&#x27;.vec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.partrec&#x27;.vec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1182, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {n m : nat}, (vector.{0} nat n → vector.{0} nat m) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n → vector.{0} nat m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {n m : nat}, (vector.{0} nat n → vector.{0} nat m) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n → vector.{0} nat m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280  λ i, prim $ hf i</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec&#x27;.prim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {n : nat} {f : vector.{0} nat n → nat}, @nat.primrec&#x27; n f → @nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@nat.primrec&#x27;.vec n m f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282  protected theorem nil {n} : @vec n 0 (λ _, nil) := λ i, i.elim0</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='nat.partrec&#x27;.vec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.elim0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π {n m : nat}, (vector.{0} nat n → vector.{0} nat m) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, vector.{u} α (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='fin (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Prop}, fin (@has_zero.zero.{0} nat nat.has_zero) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  protected theorem cons {n m} {f : vector ℕ n → ℕ} {g}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285    (hf : @partrec&#x27; n f) (hg : @vec n m g) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec&#x27;.vec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {n m : nat}, (vector.{0} nat n → vector.{0} nat m) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n → vector.{0} nat m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286    vec (λ v, f v :: g v) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec&#x27;.vec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n m : nat}, (vector.{0} nat n → vector.{0} nat m) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{0} nat n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {n : nat}, α → vector.{0} α n → vector.{0} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n → vector.{0} nat m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287  λ i, fin.cases (by simp *) (λ i, by simp [hg i]) i</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fin.lean&#x27;, &#x27;line&#x27;: 244, &#x27;column&#x27;: 26}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin (nat.succ m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {n : nat} {C : fin (nat.succ n) → Prop}, C (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n)) → (∀ (i : fin n), C (@fin.succ n i)) → ∀ (i : fin (nat.succ n)), C i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='fin m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@nat.partrec&#x27;.vec n m g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='fin m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin (nat.succ m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='n m : nat,
f : vector.{0} nat n → nat,
g : vector.{0} nat n → vector.{0} nat m,
hf :
  @nat.partrec&#x27; n
    (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
       (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
          (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
             (@pfun.has_coe.{0 0} (vector.{0} nat n) nat)))
       f),
hg : @nat.partrec&#x27;.vec n m g,
i : fin (nat.succ m)
⊢ @nat.partrec&#x27; n
    (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
       (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
          (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
             (@pfun.has_coe.{0 0} (vector.{0} nat n) nat)))
       (λ (v : vector.{0} nat n),
          @vector.nth.{0} nat (nat.succ m) ((λ (v : vector.{0} nat n), @vector.cons.{0} nat m (f v) (g v)) v)
            (@has_zero.zero.{0} (fin (nat.succ m)) (@fin.has_zero m))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='n m : nat,
f : vector.{0} nat n → nat,
g : vector.{0} nat n → vector.{0} nat m,
hf :
  @nat.partrec&#x27; n
    (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
       (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
          (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
             (@pfun.has_coe.{0 0} (vector.{0} nat n) nat)))
       f),
hg : @nat.partrec&#x27;.vec n m g,
i : fin (nat.succ m),
i : fin m
⊢ @nat.partrec&#x27; n
    (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
       (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
          (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
             (@pfun.has_coe.{0 0} (vector.{0} nat n) nat)))
       (λ (v : vector.{0} nat n),
          @vector.nth.{0} nat (nat.succ m) ((λ (v : vector.{0} nat n), @vector.cons.{0} nat m (f v) (g v)) v)
            (@fin.succ m i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289  theorem idv {n} : @vec n n id := vec.prim nat.primrec&#x27;.idv</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='nat.partrec&#x27;.vec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.partrec&#x27;.vec.prim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.primrec&#x27;.idv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 279, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1192, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Π {n m : nat}, (vector.{0} nat n → vector.{0} nat m) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {n m : nat} {f : vector.{0} nat n → vector.{0} nat m}, @nat.primrec&#x27;.vec n m f → @nat.partrec&#x27;.vec n m f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n : nat}, @nat.primrec&#x27;.vec n n (@id.{1} (vector.{0} nat n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291  theorem comp&#x27; {n m f g} (hf : @partrec&#x27; m f) (hg : @vec n m g) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec&#x27;.vec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat m) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {n m : nat}, (vector.{0} nat n → vector.{0} nat m) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n → vector.{0} nat m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292    partrec&#x27; (λ v, f (g v)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat m) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{0} nat n → vector.{0} nat m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293  (hf.comp _ hg).of_eq $ λ v, by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.partrec&#x27;.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.partrec&#x27;.of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 245, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@nat.partrec&#x27; m f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat} (g : fin n → pfun.{0 0} (vector.{0} nat m) nat), @nat.partrec&#x27; n f → (∀ (i : fin n), @nat.partrec&#x27; m (g i)) → @nat.partrec&#x27; m (λ (v : vector.{0} nat m), @has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat n) nat (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat n (λ (i : fin n), g i v)) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@nat.partrec&#x27;.vec n m g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n : nat} {f g : pfun.{0 0} (vector.{0} nat n) nat}, @nat.partrec&#x27; n f → (∀ (i : vector.{0} nat n), @eq.{1} (roption.{0} nat) (f i) (g i)) → @nat.partrec&#x27; n g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='lime'><a title='n m : nat,
f : pfun.{0 0} (vector.{0} nat m) nat,
g : vector.{0} nat n → vector.{0} nat m,
hf : @nat.partrec&#x27; m f,
hg : @nat.partrec&#x27;.vec n m g,
v : vector.{0} nat n
⊢ @eq.{1} (roption.{0} nat)
    (@has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat m) nat
       (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat m
          (λ (i : fin m),
             @coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
               (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
                  (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
                     (@pfun.has_coe.{0 0} (vector.{0} nat n) nat)))
               (λ (v : vector.{0} nat n), @vector.nth.{0} nat m (g v) i)
               v))
       f)
    (f (g v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n m : nat,
f : pfun.{0 0} (vector.{0} nat m) nat,
g : vector.{0} nat n → vector.{0} nat m,
hf : @nat.partrec&#x27; m f,
hg : @nat.partrec&#x27;.vec n m g,
v : vector.{0} nat n
⊢ @eq.{1} (roption.{0} nat)
    (@has_bind.bind.{0 0} roption.{0} (@monad.to_has_bind.{0 0} roption.{0} roption.monad.{0}) (vector.{0} nat m) nat
       (@vector.m_of_fn.{0 0} roption.{0} roption.monad.{0} nat m
          (λ (i : fin m),
             @coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
               (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
                  (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
                     (@pfun.has_coe.{0 0} (vector.{0} nat n) nat)))
               (λ (v : vector.{0} nat n), @vector.nth.{0} nat m (g v) i)
               v))
       f)
    (f (g v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295  theorem comp₁ {n} (f : ℕ →. ℕ) {g : vector ℕ n → ℕ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type → Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296    (hf : @partrec&#x27; 1 (λ v, f v.head)) (hg : @partrec&#x27; n g) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='vector.{0} nat (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {n : nat}, vector.{0} α (nat.succ n) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297    @partrec&#x27; n (λ v, f (g v)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{0} nat n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298  by simpa using hf.comp&#x27; (partrec&#x27;.cons hg partrec&#x27;.nil)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec&#x27;.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.partrec&#x27;.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 291, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 284, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 282, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one) (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)), f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n m : nat} {f : vector.{0} nat n → nat} {g : vector.{0} nat n → vector.{0} nat m}, @nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) f) → @nat.partrec&#x27;.vec n m g → @nat.partrec&#x27;.vec n (nat.succ m) (λ (v : vector.{0} nat n), @vector.cons.{0} nat m (f v) (g v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat}, @nat.partrec&#x27;.vec n (@has_zero.zero.{0} nat nat.has_zero) (λ (_x : vector.{0} nat n), @vector.nil.{0} nat)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
f : pfun.{0 0} nat nat,
g : vector.{0} nat n → nat,
hf :
  @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
    (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
       f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
hg :
  @nat.partrec&#x27; n
    (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
       (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
          (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
             (@pfun.has_coe.{0 0} (vector.{0} nat n) nat)))
       g)
⊢ @nat.partrec&#x27; n (λ (v : vector.{0} nat n), f (g v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : pfun.{0 0} nat nat,
g : vector.{0} nat n → nat,
hf :
  @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
    (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
       f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
hg :
  @nat.partrec&#x27; n
    (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
       (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
          (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat)
             (@pfun.has_coe.{0 0} (vector.{0} nat n) nat)))
       g)
⊢ @nat.partrec&#x27; n (λ (v : vector.{0} nat n), f (g v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300  theorem rfind_opt {n} {f : vector ℕ (n+1) → ℕ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301    (hf : @partrec&#x27; (n+1) f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302    @partrec&#x27; n (λ v, nat.rfind_opt (λ a, of_nat (option ℕ) (f (a :: v)))) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.rfind_opt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='denumerable.of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/denumerable.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, (nat → option.{u_1} α) → roption.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [f : denumerable.{u_1} α], nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {n : nat}, α → vector.{0} α n → vector.{0} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303  ((rfind $ (of_prim (primrec.nat_sub.comp (primrec.const 1) primrec.vector_head))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec&#x27;.rfind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.partrec&#x27;.of_prim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='primrec.nat_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='primrec₂.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='primrec.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='primrec.vector_head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 249, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 544, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 378, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 179, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1082, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {n : nat} {f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat}, @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_to_lift.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_base.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@pfun.has_coe.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat))) f) → @nat.partrec&#x27; n (λ (v : vector.{0} nat n), nat.rfind (λ (n_1 : nat), @roption.some.{0} bool (@decidable.to_bool (@eq.{1} nat (f (@vector.cons.{0} nat n n_1 v)) (@has_zero.zero.{0} nat nat.has_zero)) (nat.decidable_eq (f (@vector.cons.{0} nat n n_1 v)) (@has_zero.zero.{0} nat nat.has_zero)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {n : nat} {f : vector.{0} nat n → nat}, @primrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f → @nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@primrec₂.{0 0 0} nat nat nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) (@has_sub.sub.{0} nat nat.has_sub)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β γ σ : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β] [_inst_3 : primcodable.{0} γ] [_inst_5 : primcodable.{0} σ] {f : β → γ → σ} {g : α → β} {h : α → γ}, @primrec₂.{0 0 0} β γ σ _inst_2 _inst_3 _inst_5 f → @primrec.{0 0} α β _inst_1 _inst_2 g → @primrec.{0 0} α γ _inst_1 _inst_3 h → @primrec.{0 0} α σ _inst_1 _inst_5 (λ (a : α), f (g a) (h a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_3 : primcodable.{0} σ] (x : σ), @primrec.{0 0} α σ _inst_1 _inst_3 (λ (a : α), x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α] {n : nat}, @primrec.{0 0} (vector.{0} α (nat.succ n)) α (@primcodable.vector.{0} α _inst_1 (nat.succ n)) _inst_1 (@vector.head.{0} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304     .comp₁ (λ n, roption.some (1 - n)) hf)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.partrec&#x27;.comp₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='roption.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 295, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {n : nat} (f : pfun.{0 0} nat nat) {g : vector.{0} nat n → nat}, @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one) (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)), f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)) → @nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) g) → @nat.partrec&#x27; n (λ (v : vector.{0} nat n), f (g v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → roption.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_to_lift.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_base.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@pfun.has_coe.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `some a` value in `roption` has a `true` domain and the
 function returns `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305     .bind ((prim nat.primrec&#x27;.pred).comp₁ nat.pred hf)).of_eq $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.partrec&#x27;.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.partrec&#x27;.prim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.primrec&#x27;.pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.partrec&#x27;.comp₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec&#x27;.of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 259, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1215, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 295, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 245, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat} {g : pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat}, @nat.partrec&#x27; n f → @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) g → @nat.partrec&#x27; n (λ (v : vector.{0} nat n), @roption.bind.{0 0} nat nat (f v) (λ (a : nat), g (@vector.cons.{0} nat n a v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {n : nat} {f : vector.{0} nat n → nat}, @nat.primrec&#x27; n f → @nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@nat.primrec&#x27; (@has_one.one.{0} nat nat.has_one) (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)), nat.pred (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n : nat} (f : pfun.{0 0} nat nat) {g : vector.{0} nat n → nat}, @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one) (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)), f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)) → @nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) g) → @nat.partrec&#x27; n (λ (v : vector.{0} nat n), f (g v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_to_lift.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_base.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@pfun.has_coe.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {n : nat} {f g : pfun.{0 0} (vector.{0} nat n) nat}, @nat.partrec&#x27; n f → (∀ (i : vector.{0} nat n), @eq.{1} (roption.{0} nat) (f i) (g i)) → @nat.partrec&#x27; n g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306  λ v, roption.ext $ λ b, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='roption.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} {o p : roption.{0} α}, (∀ (a : α), iff (@has_mem.mem.{0 0} α (roption.{0} α) (@roption.has_mem.{0} α) a o) (@has_mem.mem.{0 0} α (roption.{0} α) (@roption.has_mem.{0} α) a p)) → @eq.{1} (roption.{0} α) o p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`roption` extensionality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b : nat
⊢ iff
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) b
       (@roption.bind.{0 0} nat nat
          (nat.rfind
             (λ (n_1 : nat),
                @roption.some.{0} bool
                  (@decidable.to_bool
                     (@eq.{1} nat
                        (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                           (f (@vector.cons.{0} nat n n_1 v)))
                        (@has_zero.zero.{0} nat nat.has_zero))
                     (nat.decidable_eq
                        (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                           (f (@vector.cons.{0} nat n n_1 v)))
                        (@has_zero.zero.{0} nat nat.has_zero)))))
          (λ (a : nat),
             @coe.{1 1} (nat → nat) (pfun.{0 0} nat nat)
               (@coe_to_lift.{1 1} (nat → nat) (pfun.{0 0} nat nat)
                  (@coe_base.{1 1} (nat → nat) (pfun.{0 0} nat nat) (@pfun.has_coe.{0 0} nat nat)))
               nat.pred
               (f (@vector.cons.{0} nat n a v)))))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) b
       (@nat.rfind_opt.{0} nat
          (λ (a : nat),
             @denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
               (f (@vector.cons.{0} nat n a v)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307    simp [nat.rfind_opt, -nat.mem_rfind],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nat.rfind_opt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, (nat → option.{?l_1} α) → roption.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b : nat
⊢ iff
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) b
       (@roption.bind.{0 0} nat nat
          (nat.rfind
             (λ (n_1 : nat),
                @roption.some.{0} bool
                  (@decidable.to_bool
                     (@eq.{1} nat
                        (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                           (f (@vector.cons.{0} nat n n_1 v)))
                        (@has_zero.zero.{0} nat nat.has_zero))
                     (nat.decidable_eq
                        (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                           (f (@vector.cons.{0} nat n n_1 v)))
                        (@has_zero.zero.{0} nat nat.has_zero)))))
          (λ (a : nat),
             @coe.{1 1} (nat → nat) (pfun.{0 0} nat nat)
               (@coe_to_lift.{1 1} (nat → nat) (pfun.{0 0} nat nat)
                  (@coe_base.{1 1} (nat → nat) (pfun.{0 0} nat nat) (@pfun.has_coe.{0 0} nat nat)))
               nat.pred
               (f (@vector.cons.{0} nat n a v)))))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) b
       (@nat.rfind_opt.{0} nat
          (λ (a : nat),
             @denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
               (f (@vector.cons.{0} nat n a v)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b : nat
⊢ iff
    (@Exists.{1} nat
       (λ (a : nat),
          and
            (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
               (nat.rfind
                  (λ (n_1 : nat),
                     @roption.some.{0} bool
                       (@decidable.to_bool
                          (@eq.{1} nat
                             (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                                (f (@vector.cons.{0} nat n n_1 v)))
                             (@has_zero.zero.{0} nat nat.has_zero))
                          (nat.decidable_eq
                             (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                                (f (@vector.cons.{0} nat n n_1 v)))
                             (@has_zero.zero.{0} nat nat.has_zero))))))
            (@eq.{1} nat b (nat.pred (f (@vector.cons.{0} nat n a v))))))
    (@Exists.{1} nat
       (λ (a : nat),
          and
            (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
               (nat.rfind
                  (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
                     (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
                        (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
                     (λ (n_1 : nat),
                        @option.is_some.{0} nat
                          (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                             (f (@vector.cons.{0} nat n n_1 v)))))))
            (@eq.{1} (option.{0} nat)
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n a v)))
               (@option.some.{0} nat b))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308    refine exists_congr (λ a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='exists_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 577, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {p q : α → Prop}, (∀ (a : α), iff (p a) (q a)) → iff (@Exists.{1} α p) (@Exists.{1} α (λ (a : α), q a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b : nat
⊢ iff
    (@Exists.{1} nat
       (λ (a : nat),
          and
            (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
               (nat.rfind
                  (λ (n_1 : nat),
                     @roption.some.{0} bool
                       (@decidable.to_bool
                          (@eq.{1} nat
                             (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                                (f (@vector.cons.{0} nat n n_1 v)))
                             (@has_zero.zero.{0} nat nat.has_zero))
                          (nat.decidable_eq
                             (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                                (f (@vector.cons.{0} nat n n_1 v)))
                             (@has_zero.zero.{0} nat nat.has_zero))))))
            (@eq.{1} nat b (nat.pred (f (@vector.cons.{0} nat n a v))))))
    (@Exists.{1} nat
       (λ (a : nat),
          and
            (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
               (nat.rfind
                  (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
                     (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
                        (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
                     (λ (n_1 : nat),
                        @option.is_some.{0} nat
                          (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                             (f (@vector.cons.{0} nat n n_1 v)))))))
            (@eq.{1} (option.{0} nat)
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n a v)))
               (@option.some.{0} nat b))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309      (and_congr (iff_of_eq _) iff.rfl).trans (and_congr_right (λ h, _))),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='and_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='iff.rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='and_congr_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 372, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 244, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 375, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b c d : Prop}, iff a c → iff b d → iff (and a b) (and c d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, @eq.{1} Prop a b → iff a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a : Prop}, iff a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b c : Prop}, (a → iff b c) → iff (and a b) (and a c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b : nat
⊢ iff
    (@Exists.{1} nat
       (λ (a : nat),
          and
            (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
               (nat.rfind
                  (λ (n_1 : nat),
                     @roption.some.{0} bool
                       (@decidable.to_bool
                          (@eq.{1} nat
                             (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                                (f (@vector.cons.{0} nat n n_1 v)))
                             (@has_zero.zero.{0} nat nat.has_zero))
                          (nat.decidable_eq
                             (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                                (f (@vector.cons.{0} nat n n_1 v)))
                             (@has_zero.zero.{0} nat nat.has_zero))))))
            (@eq.{1} nat b (nat.pred (f (@vector.cons.{0} nat n a v))))))
    (@Exists.{1} nat
       (λ (a : nat),
          and
            (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
               (nat.rfind
                  (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
                     (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
                        (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
                     (λ (n_1 : nat),
                        @option.is_some.{0} nat
                          (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                             (f (@vector.cons.{0} nat n n_1 v)))))))
            (@eq.{1} (option.{0} nat)
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n a v)))
               (@option.some.{0} nat b))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat
⊢ @eq.{1} Prop
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
       (nat.rfind
          (λ (n_1 : nat),
             @roption.some.{0} bool
               (@decidable.to_bool
                  (@eq.{1} nat
                     (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                        (f (@vector.cons.{0} nat n n_1 v)))
                     (@has_zero.zero.{0} nat nat.has_zero))
                  (nat.decidable_eq
                     (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                        (f (@vector.cons.{0} nat n n_1 v)))
                     (@has_zero.zero.{0} nat nat.has_zero))))))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
       (nat.rfind
          (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
                (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
             (λ (n_1 : nat),
                @option.is_some.{0} nat
                  (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                     (f (@vector.cons.{0} nat n n_1 v)))))))

n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v))))))
⊢ iff (@eq.{1} nat b (nat.pred (f (@vector.cons.{0} nat n a v))))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
          (f (@vector.cons.{0} nat n a v)))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310    { congr; funext n,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat
⊢ @eq.{1} Prop
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
       (nat.rfind
          (λ (n_1 : nat),
             @roption.some.{0} bool
               (@decidable.to_bool
                  (@eq.{1} nat
                     (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                        (f (@vector.cons.{0} nat n n_1 v)))
                     (@has_zero.zero.{0} nat nat.has_zero))
                  (nat.decidable_eq
                     (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                        (f (@vector.cons.{0} nat n n_1 v)))
                     (@has_zero.zero.{0} nat nat.has_zero))))))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
       (nat.rfind
          (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
                (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
             (λ (n_1 : nat),
                @option.is_some.{0} nat
                  (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                     (f (@vector.cons.{0} nat n n_1 v)))))))

n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v))))))
⊢ iff (@eq.{1} nat b (nat.pred (f (@vector.cons.{0} nat n a v))))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
          (f (@vector.cons.{0} nat n a v)))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat
⊢ @eq.{1} Prop
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
       (nat.rfind
          (λ (n_1 : nat),
             @roption.some.{0} bool
               (@decidable.to_bool
                  (@eq.{1} nat
                     (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                        (f (@vector.cons.{0} nat n n_1 v)))
                     (@has_zero.zero.{0} nat nat.has_zero))
                  (nat.decidable_eq
                     (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one)
                        (f (@vector.cons.{0} nat n n_1 v)))
                     (@has_zero.zero.{0} nat nat.has_zero))))))
    (@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
       (nat.rfind
          (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
                (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
             (λ (n_1 : nat),
                @option.is_some.{0} nat
                  (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                     (f (@vector.cons.{0} nat n n_1 v)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a n : nat
⊢ @eq.{1} (roption.{0} bool)
    (@roption.some.{0} bool
       (@decidable.to_bool
          (@eq.{1} nat
             (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one) (f (@vector.cons.{0} nat n n v)))
             (@has_zero.zero.{0} nat nat.has_zero))
          (nat.decidable_eq
             (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one) (f (@vector.cons.{0} nat n n v)))
             (@has_zero.zero.{0} nat nat.has_zero))))
    (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
       (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
       (λ (n_1 : nat),
          @option.is_some.{0} nat
            (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
               (f (@vector.cons.{0} nat n n_1 v))))
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311      simp, cases f (n :: v); simp [nat.succ_ne_zero]; refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.succ_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {n : nat}, α → vector.{0} α n → vector.{0} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat), @ne.{1} nat (nat.succ n) (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a n : nat
⊢ @eq.{1} (roption.{0} bool)
    (@roption.some.{0} bool
       (@decidable.to_bool
          (@eq.{1} nat
             (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one) (f (@vector.cons.{0} nat n n v)))
             (@has_zero.zero.{0} nat nat.has_zero))
          (nat.decidable_eq
             (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one) (f (@vector.cons.{0} nat n n v)))
             (@has_zero.zero.{0} nat nat.has_zero))))
    (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
       (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
       (λ (n_1 : nat),
          @option.is_some.{0} nat
            (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
               (f (@vector.cons.{0} nat n n_1 v))))
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a n : nat
⊢ @eq.{1} bool
    (@decidable.to_bool
       (@eq.{1} nat
          (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one) (f (@vector.cons.{0} nat n n v)))
          (@has_zero.zero.{0} nat nat.has_zero))
       (nat.decidable_eq
          (@has_sub.sub.{0} nat nat.has_sub (@has_one.one.{0} nat nat.has_one) (f (@vector.cons.{0} nat n n v)))
          (@has_zero.zero.{0} nat nat.has_zero)))
    (@option.is_some.{0} nat
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
          (f (@vector.cons.{0} nat n n v))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v))))))
⊢ iff (@eq.{1} nat b (nat.pred (f (@vector.cons.{0} nat n a v))))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
          (f (@vector.cons.{0} nat n a v)))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312    { have := nat.rfind_spec h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='nat.rfind_spec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : pfun.{0 0} nat bool} {n : nat}, @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) n (nat.rfind p) → @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) bool.tt (p n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a (nat.rfind (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool))) (λ (n_1 : nat), @option.is_some.{0} nat (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (f (@vector.cons.{0} nat n n_1 v))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v))))))
⊢ iff (@eq.{1} nat b (nat.pred (f (@vector.cons.{0} nat n a v))))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
          (f (@vector.cons.{0} nat n a v)))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v)))))),
this :
  @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) bool.tt
    (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
       (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
       (λ (n_1 : nat),
          @option.is_some.{0} nat
            (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
               (f (@vector.cons.{0} nat n n_1 v))))
       a)
⊢ iff (@eq.{1} nat b (nat.pred (f (@vector.cons.{0} nat n a v))))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
          (f (@vector.cons.{0} nat n a v)))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313      simp at this,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v)))))),
this :
  @has_mem.mem.{0 0} bool (roption.{0} bool) (@roption.has_mem.{0} bool) bool.tt
    (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
       (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
       (λ (n_1 : nat),
          @option.is_some.{0} nat
            (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
               (f (@vector.cons.{0} nat n n_1 v))))
       a)
⊢ iff (@eq.{1} nat b (nat.pred (f (@vector.cons.{0} nat n a v))))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
          (f (@vector.cons.{0} nat n a v)))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v)))))),
this :
  @eq.{1} bool bool.tt
    (@option.is_some.{0} nat
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
          (f (@vector.cons.{0} nat n a v))))
⊢ iff (@eq.{1} nat b (nat.pred (f (@vector.cons.{0} nat n a v))))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
          (f (@vector.cons.{0} nat n a v)))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314      cases f (a :: v) with c, {cases this},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} bool bool.tt (@option.is_some.{0} nat (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) nat.zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v)))))),
this :
  @eq.{1} bool bool.tt
    (@option.is_some.{0} nat
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
          (f (@vector.cons.{0} nat n a v))))
⊢ iff (@eq.{1} nat b (nat.pred (f (@vector.cons.{0} nat n a v))))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
          (f (@vector.cons.{0} nat n a v)))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case nat.zero
n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v)))))),
this :
  @eq.{1} bool bool.tt
    (@option.is_some.{0} nat
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) nat.zero))
⊢ iff (@eq.{1} nat b (nat.pred nat.zero))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) nat.zero)
       (@option.some.{0} nat b))

case nat.succ
n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v)))))),
c : nat,
this :
  @eq.{1} bool bool.tt
    (@option.is_some.{0} nat
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (nat.succ c)))
⊢ iff (@eq.{1} nat b (nat.pred (nat.succ c)))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (nat.succ c))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.succ
n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v)))))),
c : nat,
this :
  @eq.{1} bool bool.tt
    (@option.is_some.{0} nat
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (nat.succ c)))
⊢ iff (@eq.{1} nat b (nat.pred (nat.succ c)))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (nat.succ c))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315      rw [← option.some_inj, eq_comm], refl }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='option.some_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/defs.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a b : α}, iff (@eq.{1} (option.{0} α) (@option.some.{0} α a) (@option.some.{0} α b)) (@eq.{1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a b : α}, iff (@eq.{1} α a b) (@eq.{1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.succ
n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v)))))),
c : nat,
this :
  @eq.{1} bool bool.tt
    (@option.is_some.{0} nat
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (nat.succ c)))
⊢ iff (@eq.{1} nat b (nat.pred (nat.succ c)))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (nat.succ c))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v)))))),
c : nat,
this :
  @eq.{1} bool bool.tt
    (@option.is_some.{0} nat
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (nat.succ c)))
⊢ iff (@eq.{1} (option.{0} nat) (@option.some.{0} nat b) (@option.some.{0} nat (nat.pred (nat.succ c))))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (nat.succ c))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v)))))),
c : nat,
this :
  @eq.{1} bool bool.tt
    (@option.is_some.{0} nat
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (nat.succ c)))
⊢ iff (@eq.{1} (option.{0} nat) (@option.some.{0} nat (nat.pred (nat.succ c))) (@option.some.{0} nat b))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (nat.succ c))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case nat.succ
n : nat,
f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat,
hf :
  @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
    (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
       (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
       (@coe_to_lift.{1 1}
          (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
          (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
          (@coe_base.{1 1}
             (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat)
             (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat)
             (@pfun.has_coe.{0 0}
                (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                nat)))
       f),
v : vector.{0} nat n,
b a : nat,
h :
  @has_mem.mem.{0 0} nat (roption.{0} nat) (@roption.has_mem.{0} nat) a
    (nat.rfind
       (@coe.{1 1} (nat → bool) (pfun.{0 0} nat bool)
          (@coe_to_lift.{1 1} (nat → bool) (pfun.{0 0} nat bool)
             (@coe_base.{1 1} (nat → bool) (pfun.{0 0} nat bool) (@pfun.has_coe.{0 0} nat bool)))
          (λ (n_1 : nat),
             @option.is_some.{0} nat
               (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat)
                  (f (@vector.cons.{0} nat n n_1 v)))))),
c : nat,
this :
  @eq.{1} bool bool.tt
    (@option.is_some.{0} nat
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (nat.succ c)))
⊢ iff (@eq.{1} (option.{0} nat) (@option.some.{0} nat (nat.pred (nat.succ c))) (@option.some.{0} nat b))
    (@eq.{1} (option.{0} nat)
       (@denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (nat.succ c))
       (@option.some.{0} nat b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>318  open nat.partrec.code</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>319  theorem of_part : ∀ {n f}, partrec f → @partrec&#x27; n f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>320  suffices ∀ f, nat.partrec f → @partrec&#x27; 1 (λ v, f v.head), from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{0 0} nat nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='vector.{0} nat (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {n : nat}, vector.{0} α (nat.succ n) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>321  λ n f hf, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@partrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='this :
  ∀ (f : pfun.{0 0} nat nat),
    nat.partrec f →
    @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
      (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
         f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f
⊢ @nat.partrec&#x27; n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>322    let g, swap,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='opt_param.{1} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Move goal `n` to the front.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;nat?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='this :
  ∀ (f : pfun.{0 0} nat nat),
    nat.partrec f →
    @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
      (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
         f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f
⊢ @nat.partrec&#x27; n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
this :
  ∀ (f : pfun.{0 0} nat nat),
    nat.partrec f →
    @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
      (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
         f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f
⊢ ?m_1

this :
  ∀ (f : pfun.{0 0} nat nat),
    nat.partrec f →
    @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
      (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
         f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f,
g : ?m_2 := ?m_1
⊢ @nat.partrec&#x27; n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
this :
  ∀ (f : pfun.{0 0} nat nat),
    nat.partrec f →
    @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
      (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
         f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f,
g : ?m_2 := ?m_1
⊢ @nat.partrec&#x27; n f

this :
  ∀ (f : pfun.{0 0} nat nat),
    nat.partrec f →
    @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
      (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
         f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f
⊢ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>323    exact (comp₁ g (this g hf) (prim nat.primrec&#x27;.encode)).of_eq</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec&#x27;.comp₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.partrec&#x27;.prim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat.primrec&#x27;.encode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 295, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1251, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n : nat} (f : pfun.{0 0} nat nat) {g : vector.{0} nat n → nat}, @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one) (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)), f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)) → @nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) g) → @nat.partrec&#x27; n (λ (v : vector.{0} nat n), f (g v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (f : pfun.{0 0} nat nat), nat.partrec f → @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one) (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)), f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@partrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n : nat} {f : vector.{0} nat n → nat}, @nat.primrec&#x27; n f → @nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat}, @nat.primrec&#x27; n (@encodable.encode.{0} (vector.{0} nat n) (@encodable.vector.{0} nat encodable.nat n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
this :
  ∀ (f : pfun.{0 0} nat nat),
    nat.partrec f →
    @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
      (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
         f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f,
g : ?m_2 := ?m_1
⊢ @nat.partrec&#x27; n f

this :
  ∀ (f : pfun.{0 0} nat nat),
    nat.partrec f →
    @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
      (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
         f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f
⊢ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>324      (λ i, by dsimp [g]; simp [encodek, roption.map_id&#x27;]),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='encodable.encodek'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='roption.map_id&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 261, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [c : encodable.{?l_1} α] (a : α), @eq.{?l_1+1} (option.{?l_1} α) (@encodable.decode.{?l_1} α c (@encodable.encode.{?l_1} α c a)) (@option.some.{?l_1} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {f : α → α}, (∀ (x : α), @eq.{?l_1+1} α (f x) x) → ∀ (o : roption.{?l_1} α), @eq.{?l_1+1} (roption.{?l_1} α) (@roption.map.{?l_1 ?l_1} α α f o) o'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
this :
  ∀ (f : pfun.{0 0} nat nat),
    nat.partrec f →
    @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
      (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
         f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f,
g : ?m_2 := ?m_1
⊢ @nat.partrec&#x27; n f

this :
  ∀ (f : pfun.{0 0} nat nat),
    nat.partrec f →
    @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
      (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
         f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f
⊢ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='this :
  ∀ (f : pfun.{0 0} nat nat),
    nat.partrec f →
    @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
      (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
         f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f,
g : pfun.{0 0} nat nat :=
  λ (n_1 : nat),
    @roption.bind.{0 0} (vector.{0} nat n) nat
      (@coe.{1 1} (option.{0} (vector.{0} nat n)) (roption.{0} (vector.{0} nat n))
         (@coe_to_lift.{1 1} (option.{0} (vector.{0} nat n)) (roption.{0} (vector.{0} nat n))
            (@coe_base.{1 1} (option.{0} (vector.{0} nat n)) (roption.{0} (vector.{0} nat n))
               (@roption.has_coe.{0} (vector.{0} nat n))))
         (@encodable.decode.{0} (vector.{0} nat n)
            (@primcodable.to_encodable.{0} (vector.{0} nat n)
               (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n))
            n_1))
      (λ (a : vector.{0} nat n),
         @roption.map.{0 0} nat nat
           (@encodable.encode.{0} nat
              (@primcodable.to_encodable.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)))
           (f a)),
i : vector.{0} nat n
⊢ @eq.{1} (roption.{0} nat)
    (g (@encodable.encode.{0} (vector.{0} nat n) (@encodable.vector.{0} nat encodable.nat n) i))
    (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
this :
  ∀ (f : pfun.{0 0} nat nat),
    nat.partrec f →
    @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
      (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
         f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f,
g : ?m_2 := ?m_1
⊢ @nat.partrec&#x27; n f

this :
  ∀ (f : pfun.{0 0} nat nat),
    nat.partrec f →
    @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
      (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
         f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
n : nat,
f : pfun.{0 0} (vector.{0} nat n) nat,
hf :
  @partrec.{0 0} (vector.{0} nat n) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    f
⊢ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>325  end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>326  λ f hf, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.partrec f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='f : pfun.{0 0} nat nat,
hf : nat.partrec f
⊢ @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
    (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
       f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>327    rcases exists_code.1 hf with ⟨c, rfl⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec.code.exists_code'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {f : pfun.{0 0} nat nat}, iff (nat.partrec f) (@Exists.{1} nat.partrec.code (λ (c : nat.partrec.code), @eq.{1} (pfun.{0 0} nat nat) (nat.partrec.code.eval c) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : pfun.{0 0} nat nat,
hf : nat.partrec f
⊢ @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
    (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
       f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval c)
⊢ @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
    (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
       nat.partrec.code.eval c (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>328    simpa [eval_eq_rfind_opt] using</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat.partrec.code.eval_eq_rfind_opt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 880, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (c : nat.partrec.code) (n : nat), @eq.{1} (roption.{0} nat) (nat.partrec.code.eval c n) (@nat.rfind_opt.{0} nat (λ (k : nat), nat.partrec.code.evaln k c n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval c)
⊢ @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
    (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
       nat.partrec.code.eval c (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>329      (rfind_opt $ of_prim $ primrec.encode_iff.2 $ evaln_prim.comp $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.partrec&#x27;.rfind_opt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.partrec&#x27;.of_prim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='primrec.encode_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.partrec.code.evaln_prim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 300, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 249, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec_code.lean&#x27;, &#x27;line&#x27;: 820, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n : nat} {f : vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat}, @nat.partrec&#x27; (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) (@coe.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_to_lift.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@coe_base.{1 1} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → nat) (pfun.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat) (@pfun.has_coe.{0 0} (vector.{0} nat (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) nat))) f) → @nat.partrec&#x27; n (λ (v : vector.{0} nat n), @nat.rfind_opt.{0} nat (λ (a : nat), @denumerable.of_nat.{0} (option.{0} nat) (@denumerable.option.{0} nat denumerable.nat) (f (@vector.cons.{0} nat n a v))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {f : vector.{0} nat n → nat}, @primrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f → @nat.partrec&#x27; n (@coe.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_to_lift.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@coe_base.{1 1} (vector.{0} nat n → nat) (pfun.{0 0} (vector.{0} nat n) nat) (@pfun.has_coe.{0 0} (vector.{0} nat n) nat))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_3 : primcodable.{0} σ] {f : α → σ}, iff (@primrec.{0 0} α nat _inst_1 (@primcodable.of_denumerable.{0} nat denumerable.nat) (λ (a : α), @encodable.encode.{0} σ (@primcodable.to_encodable.{0} σ _inst_3) (f a))) (@primrec.{0 0} α σ _inst_1 _inst_3 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@primrec.{0 0} (prod.{0 0} (prod.{0 0} nat nat.partrec.code) nat) (option.{0} nat) (@primcodable.prod.{0 0} (prod.{0 0} nat nat.partrec.code) nat (@primcodable.prod.{0 0} nat nat.partrec.code (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat.partrec.code nat.partrec.code.denumerable)) (@primcodable.of_denumerable.{0} nat denumerable.nat)) (@primcodable.option.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)) (λ (a : prod.{0 0} (prod.{0 0} nat nat.partrec.code) nat), nat.partrec.code.evaln (@prod.fst.{0 0} nat nat.partrec.code (@prod.fst.{0 0} (prod.{0 0} nat nat.partrec.code) nat a)) (@prod.snd.{0 0} nat nat.partrec.code (@prod.fst.{0 0} (prod.{0 0} nat nat.partrec.code) nat a)) (@prod.snd.{0 0} (prod.{0 0} nat nat.partrec.code) nat a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval c)
⊢ @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
    (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
       nat.partrec.code.eval c (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>330        (primrec.vector_head.pair (primrec.const c)).pair $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='primrec.pair'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='primrec.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 283, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 179, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β γ : Type} [_inst_3 : primcodable.{0} α] [_inst_4 : primcodable.{0} β] [_inst_5 : primcodable.{0} γ] {f : α → β} {g : α → γ}, @primrec.{0 0} α β _inst_3 _inst_4 f → @primrec.{0 0} α γ _inst_3 _inst_5 g → @primrec.{0 0} α (prod.{0 0} β γ) _inst_3 (@primcodable.prod.{0 0} β γ _inst_4 _inst_5) (λ (a : α), @prod.mk.{0 0} β γ (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_3 : primcodable.{0} σ] (x : σ), @primrec.{0 0} α σ _inst_1 _inst_3 (λ (a : α), x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.partrec.code'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval c)
⊢ @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
    (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
       nat.partrec.code.eval c (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>331        primrec.vector_head.comp primrec.vector_tail)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='primrec.vector_head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='primrec.vector_tail'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1082, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1086, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α] {n : nat}, @primrec.{0 0} (vector.{0} α (nat.succ n)) α (@primcodable.vector.{0} α _inst_1 (nat.succ n)) _inst_1 (@vector.head.{0} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α] {n : nat}, @primrec.{0 0} (vector.{0} α n) (vector.{0} α (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))) (@primcodable.vector.{0} α _inst_1 n) (@primcodable.vector.{0} α _inst_1 (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))) (@vector.tail.{0} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : nat.partrec.code,
hf : nat.partrec (nat.partrec.code.eval c)
⊢ @nat.partrec&#x27; (@has_one.one.{0} nat nat.has_one)
    (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
       nat.partrec.code.eval c (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>332  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>333  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>334  theorem part_iff {n f} : @partrec&#x27; n f ↔ partrec f := ⟨to_part, of_part⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat.partrec&#x27;.to_part'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec&#x27;.of_part'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 233, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 319, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} (vector.{0} nat n) nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat}, @nat.partrec&#x27; n f → @partrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat}, @partrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f → @nat.partrec&#x27; n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>335  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>336  theorem part_iff₁ {f : ℕ →. ℕ} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type → Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>337    @partrec&#x27; 1 (λ v, f v.head) ↔ partrec f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='partrec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='vector.{0} nat (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {n : nat}, vector.{0} α (nat.succ n) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], pfun.{u_1 u_2} α σ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>338  part_iff.trans ⟨</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.partrec&#x27;.part_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 334, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 248, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat}, iff (@nat.partrec&#x27; n f) (@partrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, iff a b → iff b c → iff a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>339    λ h, (h.comp $ (primrec.vector_of_fn $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='partrec.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='primrec.vector_of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 1101, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@partrec.{0 0} (vector.{0} nat (@has_one.one.{0} nat nat.has_one)) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@has_one.one.{0} nat nat.has_one)) (@primcodable.of_denumerable.{0} nat denumerable.nat) (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)), f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@partrec.{0 0} (vector.{0} nat (@has_one.one.{0} nat nat.has_one)) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@has_one.one.{0} nat nat.has_one)) (@primcodable.of_denumerable.{0} nat denumerable.nat) (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)), f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β σ : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β] [_inst_4 : primcodable.{0} σ] {f : pfun.{0 0} β σ} {g : α → β}, @partrec.{0 0} β σ _inst_2 _inst_4 f → @computable.{0 0} α β _inst_1 _inst_2 g → @partrec.{0 0} α σ _inst_1 _inst_4 (λ (a : α), f (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_4 : primcodable.{0} σ] {n : nat} {f : fin n → α → σ}, (∀ (i : fin n), @primrec.{0 0} α σ _inst_1 _inst_4 (f i)) → @primrec.{0 0} α (vector.{0} σ n) _inst_1 (@primcodable.vector.{0} σ _inst_4 n) (λ (a : α), @vector.of_fn.{0} σ n (λ (i : fin n), f i a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>340      λ i, primrec.id).to_comp).of_eq (λ v, by simp),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='primrec.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='primrec.to_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='partrec.of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/primrec.lean&#x27;, &#x27;line&#x27;: 183, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 225, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='fin (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α], @primrec.{0 0} α α _inst_1 _inst_1 (@id.{1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} σ] {f : α → σ}, @primrec.{0 0} α σ _inst_1 _inst_2 f → @computable.{0 0} α σ _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_4 : primcodable.{0} σ] {f g : pfun.{0 0} α σ}, @partrec.{0 0} α σ _inst_1 _inst_4 f → (∀ (n : α), @eq.{1} (roption.{0} σ) (f n) (g n)) → @partrec.{0 0} α σ _inst_1 _inst_4 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='lime'><a title='f : pfun.{0 0} nat nat,
h :
  @partrec.{0 0} (vector.{0} nat (@has_one.one.{0} nat nat.has_one)) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)
       (@has_one.one.{0} nat nat.has_one))
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat (@has_one.one.{0} nat nat.has_one)),
       f (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) v)),
v : nat
⊢ @eq.{1} (roption.{0} nat)
    (f
       (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero)
          (@vector.of_fn.{0} nat (@has_one.one.{0} nat nat.has_one)
             (λ (i : fin (@has_one.one.{0} nat nat.has_one)), @id.{1} nat v))))
    (f v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>341    λ h, h.comp vector_head⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='partrec.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.vector_head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 290, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@partrec.{0 0} nat nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@partrec.{0 0} nat nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β σ : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β] [_inst_4 : primcodable.{0} σ] {f : pfun.{0 0} β σ} {g : α → β}, @partrec.{0 0} β σ _inst_2 _inst_4 f → @computable.{0 0} α β _inst_1 _inst_2 g → @partrec.{0 0} α σ _inst_1 _inst_4 (λ (a : α), f (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α] {n : nat}, @computable.{0 0} (vector.{0} α (nat.succ n)) α (@primcodable.vector.{0} α _inst_1 (nat.succ n)) _inst_1 (@vector.head.{0} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>342  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>343  theorem part_iff₂ {f : ℕ → ℕ →. ℕ} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pfun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type → Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`pfun α β`, or `α →. β`, is the type of partial functions from
 `α` to `β`. It is defined as `α → roption β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>344    @partrec&#x27; 2 (λ v, f v.head v.tail.head) ↔ partrec₂ f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat.partrec&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.tail'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='partrec₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 220, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, pfun.{0 0} (vector.{0} nat n) nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='vector.{0} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {n : nat}, vector.{0} α (nat.succ n) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {n : nat}, vector.{0} α n → vector.{0} α (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {n : nat}, vector.{0} α (nat.succ n) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {σ : Type u_3} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} β] [_inst_3 : primcodable.{u_3} σ], (α → pfun.{u_2 u_3} β σ) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → pfun.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A simplified basis for `partrec`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>345  part_iff.trans ⟨</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.partrec&#x27;.part_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 334, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 248, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat}, iff (@nat.partrec&#x27; n f) (@partrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, iff a b → iff b c → iff a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>346    λ h, (h.comp $ vector_cons.comp fst $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='partrec.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='computable.vector_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='computable₂.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 287, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 418, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 261, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@partrec.{0 0} (vector.{0} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@primcodable.of_denumerable.{0} nat denumerable.nat) (λ (v : vector.{0} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))), f (@vector.head.{0} nat (@has_one.one.{0} nat nat.has_one) v) (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) (@vector.tail.{0} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)) v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@partrec.{0 0} (vector.{0} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@primcodable.of_denumerable.{0} nat denumerable.nat) (λ (v : vector.{0} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))), f (@vector.head.{0} nat (@has_one.one.{0} nat nat.has_one) v) (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero) (@vector.tail.{0} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)) v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β σ : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β] [_inst_4 : primcodable.{0} σ] {f : pfun.{0 0} β σ} {g : α → β}, @partrec.{0 0} β σ _inst_2 _inst_4 f → @computable.{0 0} α β _inst_1 _inst_2 g → @partrec.{0 0} α σ _inst_1 _inst_4 (λ (a : α), f (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α] {n : nat}, @computable₂.{0 0 0} α (vector.{0} α n) (vector.{0} α (nat.succ n)) _inst_1 (@primcodable.vector.{0} α _inst_1 n) (@primcodable.vector.{0} α _inst_1 (nat.succ n)) (@vector.cons.{0} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β γ σ : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β] [_inst_3 : primcodable.{0} γ] [_inst_5 : primcodable.{0} σ] {f : β → γ → σ} {g : α → β} {h : α → γ}, @computable₂.{0 0 0} β γ σ _inst_2 _inst_3 _inst_5 f → @computable.{0 0} α β _inst_1 _inst_2 g → @computable.{0 0} α γ _inst_1 _inst_3 h → @computable.{0 0} α σ _inst_1 _inst_5 (λ (a : α), f (g a) (h a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β], @computable.{0 0} (prod.{0 0} α β) α (@primcodable.prod.{0 0} α β _inst_1 _inst_2) _inst_1 (@prod.fst.{0 0} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>347      vector_cons.comp snd (const nil)).of_eq (λ v, by simp),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='computable.vector_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='computable₂.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='partrec.of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 287, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 418, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α] {n : nat}, @computable₂.{0 0 0} α (vector.{0} α n) (vector.{0} α (nat.succ n)) _inst_1 (@primcodable.vector.{0} α _inst_1 n) (@primcodable.vector.{0} α _inst_1 (nat.succ n)) (@vector.cons.{0} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β γ σ : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β] [_inst_3 : primcodable.{0} γ] [_inst_5 : primcodable.{0} σ] {f : β → γ → σ} {g : α → β} {h : α → γ}, @computable₂.{0 0 0} β γ σ _inst_2 _inst_3 _inst_5 f → @computable.{0 0} α β _inst_1 _inst_2 g → @computable.{0 0} α γ _inst_1 _inst_3 h → @computable.{0 0} α σ _inst_1 _inst_5 (λ (a : α), f (g a) (h a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β], @computable.{0 0} (prod.{0 0} α β) β (@primcodable.prod.{0 0} α β _inst_1 _inst_2) _inst_2 (@prod.snd.{0 0} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_4 : primcodable.{0} σ] (s : σ), @computable.{0 0} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, vector.{0} α (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_4 : primcodable.{0} σ] {f g : pfun.{0 0} α σ}, @partrec.{0 0} α σ _inst_1 _inst_4 f → (∀ (n : α), @eq.{1} (roption.{0} σ) (f n) (g n)) → @partrec.{0 0} α σ _inst_1 _inst_4 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='prod.{0 0} nat nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='lime'><a title='f : nat → pfun.{0 0} nat nat,
h :
  @partrec.{0 0} (vector.{0} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) nat
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat)
       (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
    (@primcodable.of_denumerable.{0} nat denumerable.nat)
    (λ (v : vector.{0} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
       f (@vector.head.{0} nat (@has_one.one.{0} nat nat.has_one) v)
         (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero)
            (@vector.tail.{0} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)) v))),
v : prod.{0 0} nat nat
⊢ @eq.{1} (roption.{0} nat)
    (f
       (@vector.head.{0} nat (@has_one.one.{0} nat nat.has_one)
          (@vector.cons.{0} nat (@has_one.one.{0} nat nat.has_one) (@prod.fst.{0 0} nat nat v)
             (@vector.cons.{0} nat (@has_zero.zero.{0} nat nat.has_zero) (@prod.snd.{0 0} nat nat v)
                (@vector.nil.{0} nat))))
       (@vector.head.{0} nat (@has_zero.zero.{0} nat nat.has_zero)
          (@vector.tail.{0} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))
             (@vector.cons.{0} nat (@has_one.one.{0} nat nat.has_one) (@prod.fst.{0 0} nat nat v)
                (@vector.cons.{0} nat (@has_zero.zero.{0} nat nat.has_zero) (@prod.snd.{0 0} nat nat v)
                   (@vector.nil.{0} nat))))))
    (f (@prod.fst.{0 0} nat nat v) (@prod.snd.{0 0} nat nat v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>348    λ h, h.comp vector_head (vector_head.comp vector_tail)⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='partrec₂.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.vector_head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable.vector_head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='computable.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable.vector_tail'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 388, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 290, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 290, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 291, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@partrec₂.{0 0 0} nat nat nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@partrec₂.{0 0 0} nat nat nat (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) (@primcodable.of_denumerable.{0} nat denumerable.nat) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β γ σ : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β] [_inst_3 : primcodable.{0} γ] [_inst_5 : primcodable.{0} σ] {f : β → pfun.{0 0} γ σ} {g : α → β} {h : α → γ}, @partrec₂.{0 0 0} β γ σ _inst_2 _inst_3 _inst_5 f → @computable.{0 0} α β _inst_1 _inst_2 g → @computable.{0 0} α γ _inst_1 _inst_3 h → @partrec.{0 0} α σ _inst_1 _inst_5 (λ (a : α), f (g a) (h a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α] {n : nat}, @computable.{0 0} (vector.{0} α (nat.succ n)) α (@primcodable.vector.{0} α _inst_1 (nat.succ n)) _inst_1 (@vector.head.{0} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α] {n : nat}, @computable.{0 0} (vector.{0} α (nat.succ n)) α (@primcodable.vector.{0} α _inst_1 (nat.succ n)) _inst_1 (@vector.head.{0} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β σ : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β] [_inst_4 : primcodable.{0} σ] {f : β → σ} {g : α → β}, @computable.{0 0} β σ _inst_2 _inst_4 f → @computable.{0 0} α β _inst_1 _inst_2 g → @computable.{0 0} α σ _inst_1 _inst_4 (λ (a : α), f (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α] {n : nat}, @computable.{0 0} (vector.{0} α n) (vector.{0} α (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))) (@primcodable.vector.{0} α _inst_1 n) (@primcodable.vector.{0} α _inst_1 (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))) (@vector.tail.{0} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>349  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>350  theorem vec_iff {m n f} : @vec m n f ↔ computable f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='nat.partrec&#x27;.vec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='computable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 220, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {n m : nat}, (vector.{0} nat n → vector.{0} nat m) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{0} nat m → vector.{0} nat n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : primcodable.{u_1} α] [_inst_2 : primcodable.{u_2} σ], (α → σ) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>351  ⟨λ h, by simpa using vector_of_fn (λ i, to_part (h i)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='computable.vector_of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat.partrec&#x27;.to_part'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 592, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 233, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@nat.partrec&#x27;.vec m n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_4 : primcodable.{0} σ] {n : nat} {f : fin n → α → σ}, (∀ (i : fin n), @computable.{0 0} α σ _inst_1 _inst_4 (f i)) → @computable.{0 0} α (vector.{0} σ n) _inst_1 (@primcodable.vector.{0} σ _inst_4 n) (λ (a : α), @vector.of_fn.{0} σ n (λ (i : fin n), f i a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat}, @nat.partrec&#x27; n f → @partrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@nat.partrec&#x27;.vec m n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='m n : nat,
f : vector.{0} nat m → vector.{0} nat n,
h : @nat.partrec&#x27;.vec m n f
⊢ @computable.{0 0} (vector.{0} nat m) (vector.{0} nat n)
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) m)
    (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n)
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>352   λ h i, of_part $ vector_nth.comp h (const i)⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.partrec&#x27;.of_part'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='computable.vector_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='computable₂.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='computable.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 319, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 292, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 418, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/computability/partrec.lean&#x27;, &#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@computable.{0 0} (vector.{0} nat m) (vector.{0} nat n) (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) m) (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {n : nat} {f : pfun.{0 0} (vector.{0} nat n) nat}, @partrec.{0 0} (vector.{0} nat n) nat (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) (@primcodable.of_denumerable.{0} nat denumerable.nat) f → @nat.partrec&#x27; n f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} [_inst_1 : primcodable.{0} α] {n : nat}, @computable₂.{0 0 0} (vector.{0} α n) (fin n) α (@primcodable.vector.{0} α _inst_1 n) (@primcodable.fin n) _inst_1 (@vector.nth.{0} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β γ σ : Type} [_inst_1 : primcodable.{0} α] [_inst_2 : primcodable.{0} β] [_inst_3 : primcodable.{0} γ] [_inst_5 : primcodable.{0} σ] {f : β → γ → σ} {g : α → β} {h : α → γ}, @computable₂.{0 0 0} β γ σ _inst_2 _inst_3 _inst_5 f → @computable.{0 0} α β _inst_1 _inst_2 g → @computable.{0 0} α γ _inst_1 _inst_3 h → @computable.{0 0} α σ _inst_1 _inst_5 (λ (a : α), f (g a) (h a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@computable.{0 0} (vector.{0} nat m) (vector.{0} nat n) (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) m) (@primcodable.vector.{0} nat (@primcodable.of_denumerable.{0} nat denumerable.nat) n) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α σ : Type} [_inst_1 : primcodable.{0} α] [_inst_4 : primcodable.{0} σ] (s : σ), @computable.{0 0} α σ _inst_1 _inst_4 (λ (a : α), s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>353  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>354  end nat.partrec&#x27;</code></pre>
</body>