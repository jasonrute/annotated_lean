<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.monad.adjunction</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/adjunction.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.adjunction.limits</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/limits.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  open category</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open category_theory.limits</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  universes v₁ v₂ u₁ u₂ -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  namespace monad</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  variables {C : Type u₁} [𝒞 : category.{v₁} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  include 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  variables {T : C ⥤ C} [monad.{v₁} T]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.monad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  variables {J : Type v₁} [𝒥 : small_category J]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  include 𝒥</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  namespace forget_creates_limits</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  variables (D : J ⥤ algebra T) [has_limit.{v₁} (D ⋙ forget T)]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.monad.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/algebra.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/algebra.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (C : Type v₁) [_inst_1 : category_theory.category.{v₁ v₁} C] (D : Type (max u₁ v₁)) [_inst_2 : category_theory.category.{v₁ (max u₁ v₁)} D], Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {J : Type v₁} [_inst_1 : category_theory.small_category.{v₁} J] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {C : Type v₁} [𝒞 : category_theory.category.{v₁ v₁} C] {D : Type (max u₁ v₁)} [𝒟 : category_theory.category.{v₁ (max u₁ v₁)} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ (max u₁ v₁) u₁} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.functor.{v₁ v₁ (max u₁ v₁) u₁} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  @[simps] def γ : (D ⋙ forget T ⋙ T) ⟶ (D ⋙ forget T) := { app := λ j, (D.obj j).a }</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  @[simps] def c : cone (D ⋙ forget T) :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  { X := T.obj (limit (D ⋙ forget T)),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31    π := (functor.const_comp _ _ T).inv ≫ whisker_right (limit.cone (D ⋙ forget T)).π T ≫ (γ D) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                         </code><font color='blue'><a title='category_theory.monad.forget_creates_limits.γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                         </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                         </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] {J : Type v₁} [𝒥 : category_theory.small_category.{v₁} J] (D : @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) [_inst_2 : @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))], @category_theory.has_hom.hom.{v₁ (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.category_struct.to_has_hom.{v₁ (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.category.to_category_struct.{v₁ (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞))) (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.functor.comp.{v₁ v₁ v₁ (max u₁ v₁) u₁ u₁} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 C 𝒞 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1) T)) (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  @[simps] def cone_point (D : J ⥤ algebra T) [has_limit.{v₁} (D ⋙ forget T)] : algebra T :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  { A := limit (D ⋙ forget T),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    a := limit.lift _ (c D),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    unit&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37    begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38      ext1,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`ext1 id` selects and apply one extensionality lemma (with attribute
`ext`), using `id`, if provided, to name a local constant
introduced by the lemma. If `id` is omitted, the local constant is
named automatically, as per `intro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39      rw [category.assoc, limit.lift_π],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40      dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41      erw [id_comp, ←category.assoc, ←nat_trans.naturality,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42          id_comp, category.assoc, algebra.unit, comp_id],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43      refl,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44    end,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45    assoc&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46    begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47      ext1,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`ext1 id` selects and apply one extensionality lemma (with attribute
`ext`), using `id`, if provided, to name a local constant
introduced by the lemma. If `id` is omitted, the local constant is
named automatically, as per `intro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48      dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49      simp only [limit.lift_π, γ_app, c_π, limit.cone_π, functor.const_comp, whisker_right_app,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='category_theory.limits.limit.lift_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.monad.forget_creates_limits.γ_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.monad.forget_creates_limits.c_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.limit.cone_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.const_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.whisker_right_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 455, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 440, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F) (j : J), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞)) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j)) (@category_theory.category_struct.comp.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) (@category_theory.limits.limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j) (@category_theory.limits.limit.lift.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 c) (@category_theory.limits.limit.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 j)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {T : @category_theory.functor.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{?l_2 ?l_1} C 𝒞 T] {J : Type ?l_2} [𝒥 : category_theory.small_category.{?l_2} J] (D : @category_theory.functor.{?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2)} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1)) [_inst_2 : @category_theory.limits.has_limit.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1))] (j : J), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 (@category_theory.functor.obj.{?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2)} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 (@category_theory.functor.obj.{?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2)} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) D j))) (@category_theory.nat_trans.app.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1 ?l_1} (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 C 𝒞 (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1) T)) (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.γ.{?l_2 ?l_1} C 𝒞 T _inst_1 J 𝒥 D _inst_2) j) (@category_theory.monad.algebra.a.{?l_2 ?l_1} C 𝒞 T _inst_1 (@category_theory.functor.obj.{?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2)} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) D j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {T : @category_theory.functor.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{?l_2 ?l_1} C 𝒞 T] {J : Type ?l_2} [𝒥 : category_theory.small_category.{?l_2} J] (D : @category_theory.functor.{?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2)} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1)) [_inst_2 : @category_theory.limits.has_limit.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1))], @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 (max ?l_2 ?l_1)} (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.category_struct.to_has_hom.{?l_2 (max ?l_2 ?l_1)} (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.category.to_category_struct.{?l_2 (max ?l_2 ?l_1)} (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.category.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞))) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 (max ?l_2 ?l_1)} C 𝒞 (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.category.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.const.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) _inst_2))) (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1))) (@category_theory.limits.cone.π.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.c.{?l_2 ?l_1} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) (@category_theory.category_struct.comp.{?l_2 (max ?l_2 ?l_1)} (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.category.to_category_struct.{?l_2 (max ?l_2 ?l_1)} (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.category.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞)) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 (max ?l_2 ?l_1)} C 𝒞 (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.category.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.const.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) _inst_2))) (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 ?l_1 ?l_1} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 (max ?l_2 ?l_1)} C 𝒞 (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.category.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.const.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.limits.limit.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) _inst_2)) T) (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) (@category_theory.iso.inv.{?l_2 (max ?l_2 ?l_1)} (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.category.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 ?l_1 ?l_1} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 (max ?l_2 ?l_1)} C 𝒞 (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.category.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.const.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.limits.limit.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) _inst_2)) T) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 (max ?l_2 ?l_1)} C 𝒞 (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.category.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.const.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) _inst_2))) (@category_theory.functor.const_comp.{?l_2 ?l_2 ?l_2 ?l_2 ?l_1 ?l_1} J 𝒥 C 𝒞 C 𝒞 (@category_theory.limits.limit.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) _inst_2) T)) (@category_theory.category_struct.comp.{?l_2 (max ?l_2 ?l_1)} (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.category.to_category_struct.{?l_2 (max ?l_2 ?l_1)} (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.category.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞)) (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 ?l_1 ?l_1} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 (max ?l_2 ?l_1)} C 𝒞 (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.category.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.const.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.limits.limit.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) _inst_2)) T) (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 ?l_1 ?l_1} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) T) (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) (@category_theory.whisker_right.{?l_2 ?l_2 ?l_1 ?l_2 ?l_1 ?l_2} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 (max ?l_2 ?l_1)} C 𝒞 (@category_theory.functor.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.category.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.functor.const.{?l_2 ?l_2 ?l_2 ?l_1} J 𝒥 C 𝒞) (@category_theory.limits.limit.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) (@category_theory.limits.cone.π.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) (@category_theory.limits.limit.cone.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1)) _inst_2)) T) (@category_theory.monad.forget_creates_limits.γ.{?l_2 ?l_1} C 𝒞 T _inst_1 J 𝒥 D _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F] (j : J), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞)) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3))) j) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3))) F (@category_theory.limits.cone.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3)) j) (@category_theory.limits.limit.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (J : Type ?l_1) [𝒥 : category_theory.category.{?l_2 ?l_1} J] {C : Type ?l_3} [𝒞 : category_theory.category.{?l_4 ?l_3} C] {D : Type ?l_5} [𝒟 : category_theory.category.{?l_6 ?l_5} D] (X : C) (F : @category_theory.functor.{?l_4 ?l_6 ?l_3 ?l_5} C 𝒞 D 𝒟), @category_theory.iso.{(max ?l_1 ?l_6) (max ?l_2 ?l_6 ?l_1 ?l_5)} (@category_theory.functor.{?l_2 ?l_6 ?l_1 ?l_5} J 𝒥 D 𝒟) (@category_theory.functor.category.{?l_2 ?l_6 ?l_1 ?l_5} J 𝒥 D 𝒟) (@category_theory.functor.comp.{?l_2 ?l_4 ?l_6 ?l_1 ?l_3 ?l_5} J 𝒥 C 𝒞 D 𝒟 (@category_theory.functor.obj.{?l_4 (max ?l_1 ?l_4) ?l_3 (max ?l_2 ?l_4 ?l_1 ?l_3)} C 𝒞 (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} J 𝒥 C 𝒞) (@category_theory.functor.category.{?l_2 ?l_4 ?l_1 ?l_3} J 𝒥 C 𝒞) (@category_theory.functor.const.{?l_2 ?l_4 ?l_1 ?l_3} J 𝒥 C 𝒞) X) F) (@category_theory.functor.obj.{?l_6 (max ?l_1 ?l_6) ?l_5 (max ?l_2 ?l_6 ?l_1 ?l_5)} D 𝒟 (@category_theory.functor.{?l_2 ?l_6 ?l_1 ?l_5} J 𝒥 D 𝒟) (@category_theory.functor.category.{?l_2 ?l_6 ?l_1 ?l_5} J 𝒥 D 𝒟) (@category_theory.functor.const.{?l_2 ?l_6 ?l_1 ?l_5} J 𝒥 D 𝒟) (@category_theory.functor.obj.{?l_4 ?l_6 ?l_3 ?l_5} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {D : Type ?l_3} [𝒟 : category_theory.category.{?l_4 ?l_3} D] {E : Type ?l_5} [ℰ : category_theory.category.{?l_6 ?l_5} E] {G H : @category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.functor.category.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟))) G H) (F : @category_theory.functor.{?l_4 ?l_6 ?l_3 ?l_5} D 𝒟 E ℰ) (c : C), @eq.{?l_6+1} (@category_theory.has_hom.hom.{?l_6 ?l_5} E (@category_theory.category_struct.to_has_hom.{?l_6 ?l_5} E (@category_theory.category.to_category_struct.{?l_6 ?l_5} E ℰ)) (@category_theory.functor.obj.{?l_4 ?l_6 ?l_3 ?l_5} D 𝒟 E ℰ F (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 G c)) (@category_theory.functor.obj.{?l_4 ?l_6 ?l_3 ?l_5} D 𝒟 E ℰ F (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 H c))) (@category_theory.nat_trans.app.{?l_2 ?l_6 ?l_1 ?l_5} C 𝒞 E ℰ (@category_theory.functor.comp.{?l_2 ?l_4 ?l_6 ?l_1 ?l_3 ?l_5} C 𝒞 D 𝒟 E ℰ G F) (@category_theory.functor.comp.{?l_2 ?l_4 ?l_6 ?l_1 ?l_3 ?l_5} C 𝒞 D 𝒟 E ℰ H F) (@category_theory.whisker_right.{?l_1 ?l_2 ?l_3 ?l_4 ?l_5 ?l_6} C 𝒞 D 𝒟 E ℰ G H α F) c) (@category_theory.functor.map.{?l_4 ?l_6 ?l_3 ?l_5} D 𝒟 E ℰ F (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 G c) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 H c) (@category_theory.nat_trans.app.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 G H α c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='These are actually equal, of course, but not definitionally equal
 (the equality requires F.map (𝟙 _) = 𝟙 _). A natural isomorphism is
 more convenient than an equality between functors (compare id_to_iso).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
             T
             (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3))
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)
             (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3
                (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50                  nat_trans.comp_app, category.assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='category_theory.nat_trans.comp_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {D : Type ?l_3} [𝒟 : category_theory.category.{?l_4 ?l_3} D] {F G H : @category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.functor.category.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟))) F G) (β : @category_theory.has_hom.hom.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.functor.category.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟))) G H) (X : C), @eq.{?l_4+1} (@category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 H X)) (@category_theory.nat_trans.app.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F H (@category_theory.category_struct.comp.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.functor.category.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟)) F G H α β) X) (@category_theory.category_struct.comp.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 H X) (@category_theory.nat_trans.app.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F G α X) (@category_theory.nat_trans.app.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 G H β X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W X) (g : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (h : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) Y Z), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W Z) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W Y Z (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Z f (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
             T
             (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3))
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)
             (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3
                (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
             j)
          (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                   (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                         C
                         𝒞
                         D
                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                      _inst_3))
                T)
             j)
          (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             j)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                   (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            D
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                         _inst_3)))
                j))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                      (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            D
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                         _inst_3))
                   T)
                j)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   T)
                j)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                j)
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                      (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            D
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                         _inst_3))
                   j)
                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   j)
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
             j)
          (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                   (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                         C
                         𝒞
                         D
                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                      _inst_3))
                T)
             j)
          (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             j)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                   (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            D
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                         _inst_3)))
                j))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                      (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            D
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                         _inst_3))
                   T)
                j)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   T)
                j)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                j)
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                      (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            D
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                         _inst_3))
                   j)
                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   j)
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51      dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
             j)
          (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                   (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                         C
                         𝒞
                         D
                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                      _inst_3))
                T)
             j)
          (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             j)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                   (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            D
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                         _inst_3)))
                j))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                      (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            D
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                         _inst_3))
                   T)
                j)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   T)
                j)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                j)
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                      (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            D
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                         _inst_3))
                   j)
                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   j)
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
             j)
          (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                   (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                         C
                         𝒞
                         D
                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                      _inst_3))
                T)
             j)
          (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             j)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                   (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            D
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                         _inst_3)))
                j))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                      (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            D
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                         _inst_3))
                   T)
                j)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   T)
                j)
             (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                j)
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                      (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            D
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                         _inst_3))
                   j)
                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   j)
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j)))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j))
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j)))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j))
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52      simp only [id_comp],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j)))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j))
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j)))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j))
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53      conv { to_rhs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_rhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3)
       (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3
          (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             j))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54        rw [←category.assoc, ←T.map_comp, limit.lift_π],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='category_theory.limits.limit.lift_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 455, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3)) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)))) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) f g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3) f) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v₁} [_inst_1 : category_theory.small_category.{v₁} J] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {F : @category_theory.functor.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{v₁ u₁} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cone.{v₁ u₁} J _inst_1 C 𝒞 F) (j : J), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.limits.cone.X.{v₁ u₁} J _inst_1 C 𝒞 F c) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞 F j)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.limits.cone.X.{v₁ u₁} J _inst_1 C 𝒞 F c) (@category_theory.limits.limit.{v₁ u₁} J _inst_1 C 𝒞 F _inst_3) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞 F j) (@category_theory.limits.limit.lift.{v₁ u₁} J _inst_1 C 𝒞 F _inst_3 c) (@category_theory.limits.limit.π.{v₁ u₁} J _inst_1 C 𝒞 F _inst_3 j)) (@category_theory.nat_trans.app.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v₁ u₁} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{v₁ u₁} J _inst_1 C 𝒞 F c) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3)
       (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3
          (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             j))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             j)))
    (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3))
          (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             j)))
    (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
⊢ C

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
⊢ C

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
⊢ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
             (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
             (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
             (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
             (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          (@category_theory.limits.cone.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3))
          j))
    (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55        dsimp [c],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='category_theory.monad.forget_creates_limits.c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {T : @category_theory.functor.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{?l_2 ?l_1} C 𝒞 T] {J : Type ?l_2} [𝒥 : category_theory.small_category.{?l_2} J] (D : @category_theory.functor.{?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2)} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1)) [_inst_2 : @category_theory.limits.has_limit.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1))], @category_theory.limits.cone.{?l_2 ?l_1} J 𝒥 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} J 𝒥 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
             (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
             (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
             (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
             (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3)))
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          (@category_theory.limits.cone.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_3))
          j))
    (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j)))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j))
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))))
    (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56        rw [id_comp], },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X X Y (@category_theory.category_struct.id.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j)))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j))
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))))
    (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))
    (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j)))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j))
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57      conv { to_lhs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_lhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j)))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j))
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j)))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j))
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_3
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
       T
       (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             j))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58        rw [←category.assoc, ←nat_trans.naturality, category.assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.nat_trans.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟} (c : @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G) ⦃X Y : C⦄ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X Y f) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G c Y)) (@category_theory.category_struct.comp.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G c X) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
       T
       (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             j))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             j)))
    (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))
    (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59        erw [algebra.assoc (D.obj j), ←category.assoc, ←T.map_comp], },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.monad.algebra.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/algebra.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] (c : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T) T (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)))) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)))) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) f g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_3)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) f) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_3
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))
    (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_3 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
j : J
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_3))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_3
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))
    (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    end }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  end forget_creates_limits</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  -- Theorem 5.6.5 from [Riehl][riehl2017]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  def forget_creates_limits (D : J ⥤ algebra T) [has_limit.{v₁} (D ⋙ forget T)] : has_limit D :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.monad.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/algebra.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/algebra.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v₁) [_inst_1 : category_theory.category.{v₁ v₁} C] (D : Type (max u₁ v₁)) [_inst_2 : category_theory.category.{v₁ (max u₁ v₁)} D], Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v₁} [_inst_1 : category_theory.small_category.{v₁} J] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v₁} [𝒞 : category_theory.category.{v₁ v₁} C] {D : Type (max u₁ v₁)} [𝒟 : category_theory.category.{v₁ (max u₁ v₁)} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ (max u₁ v₁) u₁} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.functor.{v₁ v₁ (max u₁ v₁) u₁} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  { cone :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67    { X := forget_creates_limits.cone_point D,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.monad.forget_creates_limits.cone_point'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] {J : Type v₁} [𝒥 : category_theory.small_category.{v₁} J] (D : @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) [_inst_3 : @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))], @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68      π :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69      { app := λ j, { f := limit.π (D ⋙ forget T) j },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.limits.limit.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.monad.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 437, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/algebra.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F] (j : J), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.limit.{v u} J _inst_1 C 𝒞 F _inst_3) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v₁} [𝒞 : category_theory.category.{v₁ v₁} C] {D : Type (max u₁ v₁)} [𝒟 : category_theory.category.{v₁ (max u₁ v₁)} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ (max u₁ v₁) u₁} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.functor.{v₁ v₁ (max u₁ v₁) u₁} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70        naturality&#x27; := λ X Y f, by { ext, dsimp, erw [id_comp, limit.w] } } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.limit.w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 443, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ v₁} J (@category_theory.category_struct.to_has_hom.{v₁ v₁} J (@category_theory.category.to_category_struct.{v₁ v₁} J 𝒥)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X X Y (@category_theory.category_struct.id.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v₁} [_inst_1 : category_theory.small_category.{v₁} J] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F : @category_theory.functor.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_limit.{v₁ u₁} J _inst_1 C 𝒞 F] {j j&#x27; : J} (f : @category_theory.has_hom.hom.{v₁ v₁} J (@category_theory.category_struct.to_has_hom.{v₁ v₁} J (@category_theory.category.to_category_struct.{v₁ v₁} J _inst_1)) j j&#x27;), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.limits.limit.{v₁ u₁} J _inst_1 C 𝒞 F _inst_3) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞 F j&#x27;)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.limits.limit.{v₁ u₁} J _inst_1 C 𝒞 F _inst_3) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞 F j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞 F j&#x27;) (@category_theory.limits.limit.π.{v₁ u₁} J _inst_1 C 𝒞 F _inst_3 j) (@category_theory.functor.map.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞 F j j&#x27; f)) (@category_theory.limits.limit.π.{v₁ u₁} J _inst_1 C 𝒞 F _inst_3 j&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
X Y : J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} J
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} J
       (@category_theory.category.to_category_struct.{v₁ v₁} J 𝒥))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
          X)
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          Y))
    (@category_theory.category_struct.comp.{v₁ (max u₁ v₁)}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
          X)
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
          Y)
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          Y)
       (@category_theory.functor.map.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
          X
          Y
          f)
       (@category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
             Y)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y)
          (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2
             Y)
          (@id.{0}
             (∀ (j : J),
                @eq.{v₁+1}
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                    𝒥
                                    D
                                    _inst_2))
                              j)))
                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           D
                           j)))
                  (@category_theory.category_struct.comp.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                    𝒥
                                    D
                                    _inst_2))
                              j)))
                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              D
                              j)))
                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           D
                           j))
                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                    𝒥
                                    D
                                    _inst_2))
                              j))
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              D
                              j))
                        (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              C
                              𝒞
                              D
                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                           _inst_2
                           j))
                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           D
                           j)))
                  (@category_theory.category_struct.comp.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                    𝒥
                                    D
                                    _inst_2))
                              j)))
                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                 𝒥
                                 D
                                 _inst_2))
                           j))
                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           D
                           j))
                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                 𝒥
                                 D
                                 _inst_2))
                           j))
                     (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           C
                           𝒞
                           D
                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                        _inst_2
                        j)))
             (λ (j : J),
                @eq.mpr.{0}
                  (@eq.{v₁+1}
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              _inst_2))
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              D
                              j)))
                     (@category_theory.category_struct.comp.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              _inst_2))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j)))
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              D
                              j))
                        (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              _inst_2)
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j))
                           (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              _inst_2
                              j))
                        (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              D
                              j)))
                     (@category_theory.category_struct.comp.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              _inst_2))
                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              C
                              𝒞
                              D
                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                           _inst_2)
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              D
                              j))
                        (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              C
                              𝒞
                              D
                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                           _inst_2
                           (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                              _inst_2))
                        (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              C
                              𝒞
                              D
                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                           _inst_2
                           j)))
                  (@eq.{v₁+1}
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              _inst_2))
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              D
                              j)))
                     (@category_theory.category_struct.comp.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              _inst_2))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j)))
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              D
                              j))
                        (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              _inst_2)
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j))
                           (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              _inst_2
                              j))
                        (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              D
                              j)))
                     (@category_theory.category_struct.comp.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                           (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                              (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                              (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                              (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                              (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                                    _inst_2)))
                           j)
                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                              (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                 (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                 (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                 (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                       C
                                       𝒞
                                       D
                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                    _inst_2))
                              T)
                           j)
                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              C
                              𝒞
                              D
                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                           j)
                        (@category_theory.category_struct.id.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                 (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                 (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                    (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                       (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                          C
                                          𝒞
                                          D
                                          (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                       _inst_2)))
                              j))
                        (@category_theory.category_struct.comp.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                    (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                    (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                    (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                    (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                       (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                          C
                                          𝒞
                                          D
                                          (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                       _inst_2))
                                 T)
                              j)
                           (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 T)
                              j)
                           (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              j)
                           (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                              (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                    (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                    (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                    (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                    (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                       (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                          C
                                          𝒞
                                          D
                                          (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                       _inst_2))
                                 j)
                              (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 j)
                              (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 _inst_2
                                 j))
                           (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j)))))
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{v₁+1}
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                 (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                       C
                                       𝒞
                                       D
                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                    _inst_2))
                              (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    D
                                    j)))
                           (@category_theory.category_struct.comp.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                 (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                       C
                                       𝒞
                                       D
                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                    _inst_2))
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                 (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                    (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                       D
                                       j)))
                              (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    D
                                    j))
                              (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                 (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                       C
                                       𝒞
                                       D
                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                    _inst_2)
                                 (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                    (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                       D
                                       j))
                                 (… 𝒥 C 𝒞 … _inst_2 j))
                              …)
                           …)
                        …)
                     …)
                  …)
             Y)))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
X Y : J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} J
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} J
       (@category_theory.category.to_category_struct.{v₁ v₁} J 𝒥))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
             X))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y)))
    (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
          X)
       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          Y)
       (@category_theory.category_struct.comp.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
             X)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
             Y)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y)
          (@category_theory.functor.map.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
             X
             Y
             f)
          (@category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                   (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                   (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                   (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                      _inst_2))
                Y)
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                Y)
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2
                Y)
             (@id.{0}
                (∀ (j : J),
                   @eq.{v₁+1}
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                       _inst_1
                                       J
                                       𝒥
                                       D
                                       _inst_2))
                                 j)))
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              D
                              j)))
                     (@category_theory.category_struct.comp.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                       _inst_1
                                       J
                                       𝒥
                                       D
                                       _inst_2))
                                 j)))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j)))
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              D
                              j))
                        (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                       _inst_1
                                       J
                                       𝒥
                                       D
                                       _inst_2))
                                 j))
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j))
                           (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              _inst_2
                              j))
                        (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              D
                              j)))
                     (@category_theory.category_struct.comp.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                       _inst_1
                                       J
                                       𝒥
                                       D
                                       _inst_2))
                                 j)))
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                    𝒥
                                    D
                                    _inst_2))
                              j))
                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              D
                              j))
                        (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                 (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                    𝒥
                                    D
                                    _inst_2))
                              j))
                        (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              C
                              𝒞
                              D
                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                           _inst_2
                           j)))
                (λ (j : J),
                   @eq.mpr.{0}
                     (@eq.{v₁+1}
                        (@category_theory.has_hom.hom.{v₁ u₁} C
                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 _inst_2))
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j)))
                        (@category_theory.category_struct.comp.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 _inst_2))
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                              (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    D
                                    j)))
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j))
                           (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 _inst_2)
                              (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    D
                                    j))
                              (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 _inst_2
                                 j))
                           (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j)))
                        (@category_theory.category_struct.comp.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 _inst_2))
                           (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              _inst_2)
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j))
                           (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              _inst_2
                              (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                                 _inst_2))
                           (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              _inst_2
                              j)))
                     (@eq.{v₁+1}
                        (@category_theory.has_hom.hom.{v₁ u₁} C
                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 _inst_2))
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j)))
                        (@category_theory.category_struct.comp.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 _inst_2))
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                              (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    D
                                    j)))
                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j))
                           (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 _inst_2)
                              (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    D
                                    j))
                              (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 _inst_2
                                 j))
                           (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j)))
                        (@category_theory.category_struct.comp.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                 (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                 (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                 (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                       C
                                       𝒞
                                       D
                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥
                                       D
                                       _inst_2)))
                              j)
                           (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                    (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                    (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                    (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                    (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                       (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                          C
                                          𝒞
                                          D
                                          (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                       _inst_2))
                                 T)
                              j)
                           (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 C
                                 𝒞
                                 D
                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                              j)
                           (@category_theory.category_struct.id.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                    (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                    (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                    (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                             𝒥
                                             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                _inst_1)
                                             C
                                             𝒞
                                             D
                                             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                          _inst_2)))
                                 j))
                           (@category_theory.category_struct.comp.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                       (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                       (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                       (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                             𝒥
                                             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                _inst_1)
                                             C
                                             𝒞
                                             D
                                             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                          _inst_2))
                                    T)
                                 j)
                              (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                                    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                       C
                                       𝒞
                                       D
                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                    T)
                                 j)
                              (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 j)
                              (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                 (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                       (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                       (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                       (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                             𝒥
                                             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                _inst_1)
                                             C
                                             𝒞
                                             D
                                             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                          _inst_2))
                                    j)
                                 (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                       C
                                       𝒞
                                       D
                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                    j)
                                 (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                       C
                                       𝒞
                                       D
                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                    _inst_2
                                    j))
                              (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    D
                                    j)))))
                     (@id.{0}
                        (@eq.{1} Prop
                           (@eq.{v₁+1}
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                    (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                       (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                          C
                                          𝒞
                                          D
                                          (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                       _inst_2))
                                 (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                    (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                       D
                                       j)))
                              (@category_theory.category_struct.comp.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                    (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                       (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                          C
                                          𝒞
                                          D
                                          (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                       _inst_2))
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 … … D
                                          j)))
                                 …
                                 …
                                 …)
                              …)
                           …)
                        …)
                     …)
                Y))))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
X Y : J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} J
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} J
       (@category_theory.category.to_category_struct.{v₁ v₁} J 𝒥))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y))
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2
          Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             X))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2
          X)
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             X)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y)
          (@category_theory.functor.map.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             X
             Y
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
X Y : J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} J
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} J
       (@category_theory.category.to_category_struct.{v₁ v₁} J 𝒥))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y)))
    (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          C
          𝒞
          D
          (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
       _inst_2
       Y)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             X))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2
          X)
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             X)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y)
          (@category_theory.functor.map.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             X
             Y
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
X Y : J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} J
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} J
       (@category_theory.category.to_category_struct.{v₁ v₁} J 𝒥))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y))
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2
          Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             X))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2
          X)
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             X)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             Y)
          (@category_theory.functor.map.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             X
             Y
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71    is_limit :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    { lift := λ s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73      { f := limit.lift _ ((forget T).map_cone s),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.limits.limit.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.monad.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map_cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 449, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/algebra.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 337, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.limit.{v u} J _inst_1 C 𝒞 F _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.functor.{v₁ v₁ (max u₁ v₁) u₁} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v₁} [_inst_1 : category_theory.small_category.{v₁} J] {C : Type (max u₁ v₁)} [𝒞 : category_theory.category.{v₁ (max u₁ v₁)} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] {F : @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J _inst_1 C 𝒞} (H : @category_theory.functor.{v₁ v₁ (max u₁ v₁) u₁} C 𝒞 D _inst_2), @category_theory.limits.cone.{v₁ (max u₁ v₁)} J _inst_1 C 𝒞 F → @category_theory.limits.cone.{v₁ u₁} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J _inst_1 C 𝒞 D _inst_2 F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The image of a cone in C under a functor G : C ⥤ D is a cone in D.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74        h&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75        begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)
                (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                      (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                      (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                      (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                         _inst_2))
                   D
                   (λ (j : J),
                      @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                 𝒥
                                 D
                                 _inst_2))
                           j)
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           D
                           j)
                        (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              C
                              𝒞
                              D
                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                           _inst_2
                           j)
                        (@id.{0}
                           (∀ (j : J),
                              @eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j)))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j))
                                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞
                                               T
                                               _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2))
                                         j))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞
                                               T
                                               _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2))
                                         j))
                                   (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2
                                      j)))
                           (λ (j : J),
                              @eq.mpr.{0}
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2)
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j))
                                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2)
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                            𝒥
                                            D
                                            _inst_2))
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j)))
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2)
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j))
                                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                            (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2)))
                                         j)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                            𝒞
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                               (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            T)
                                         j)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         j)
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                               (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                  (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     _inst_2)))
                                            j))
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                               C
                                               𝒞
                                               (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                  (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                     𝒞)
                                                  (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     _inst_2))
                                               T)
                                            j)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                               C
                                               𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               T)
                                            j)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            j)
                                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                  (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                     𝒞)
                                                  (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     _inst_2))
                                               j)
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               j)
                                            (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               j))
                                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))))
                                (@id.{0}
                                   (@eq.{1} Prop
                                      (@eq.{v₁+1}
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.category_struct.comp.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     D
                                                     j)))
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j))
                                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2)
                                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     D
                                                     j))
                                               (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2
                                                  j))
                                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.category_struct.comp.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2)
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j))
                                            (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               j)))
                                      (@eq.{v₁+1}
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (… …)
                                                  _inst_2))
                                            …)
                                         …
                                         …))
                                   …)
                                …)
                           j))
                   …)))))
    …
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76          ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)
                (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                      (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                      (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                      (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                         _inst_2))
                   D
                   (λ (j : J),
                      @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                 𝒥
                                 D
                                 _inst_2))
                           j)
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           D
                           j)
                        (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              C
                              𝒞
                              D
                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                           _inst_2
                           j)
                        (@id.{0}
                           (∀ (j : J),
                              @eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j)))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j))
                                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞
                                               T
                                               _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2))
                                         j))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞
                                               T
                                               _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2))
                                         j))
                                   (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2
                                      j)))
                           (λ (j : J),
                              @eq.mpr.{0}
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2)
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j))
                                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2)
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                            𝒥
                                            D
                                            _inst_2))
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j)))
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2)
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j))
                                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                            (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2)))
                                         j)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                            𝒞
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                               (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            T)
                                         j)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         j)
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                               (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                  (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     _inst_2)))
                                            j))
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                               C
                                               𝒞
                                               (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                  (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                     𝒞)
                                                  (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     _inst_2))
                                               T)
                                            j)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                               C
                                               𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               T)
                                            j)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            j)
                                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                  (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                     𝒞)
                                                  (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     _inst_2))
                                               j)
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               j)
                                            (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               j))
                                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))))
                                (@id.{0}
                                   (@eq.{1} Prop
                                      (@eq.{v₁+1}
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.category_struct.comp.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     D
                                                     j)))
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j))
                                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2)
                                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     D
                                                     j))
                                               (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2
                                                  j))
                                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.category_struct.comp.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2)
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j))
                                            (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               j)))
                                      (@eq.{v₁+1}
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (… …)
                                                  _inst_2))
                                            …)
                                         …
                                         …))
                                   …)
                                …)
                           j))
                   …)))))
    …
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          j)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                         _inst_2)
                      (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                            (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                            (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                            (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥
                               D
                               _inst_2))
                         D
                         (λ (j : J),
                            @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                    (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                       _inst_1
                                       J
                                       𝒥
                                       D
                                       _inst_2))
                                 j)
                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                 D
                                 j)
                              (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                    C
                                    𝒞
                                    D
                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                 _inst_2
                                 j)
                              (@id.{0}
                                 (∀ (j : J),
                                    @eq.{v₁+1}
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  (@category_theory.functor.obj.{v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     (max u₁ v₁)}
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1))
                                                     (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1))
                                                     (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1))
                                                     (@category_theory.monad.forget_creates_limits.cone_point.{v₁
                                                        u₁}
                                                        C
                                                        𝒞
                                                        T
                                                        _inst_1
                                                        J
                                                        𝒥
                                                        D
                                                        _inst_2))
                                                  j)))
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  (@category_theory.functor.obj.{v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     (max u₁ v₁)}
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1))
                                                     (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1))
                                                     (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1))
                                                     (@category_theory.monad.forget_creates_limits.cone_point.{v₁
                                                        u₁}
                                                        C
                                                        𝒞
                                                        T
                                                        _inst_1
                                                        J
                                                        𝒥
                                                        D
                                                        _inst_2))
                                                  j)))
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  (@category_theory.functor.obj.{v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     (max u₁ v₁)}
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1))
                                                     (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1))
                                                     (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1))
                                                     (@category_theory.monad.forget_creates_limits.cone_point.{v₁
                                                        u₁}
                                                        C
                                                        𝒞
                                                        T
                                                        _inst_1
                                                        J
                                                        𝒥
                                                        D
                                                        _inst_2))
                                                  j))
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j))
                                            (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               j))
                                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  (@category_theory.functor.obj.{v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     (max u₁ v₁)}
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1))
                                                     (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1))
                                                     (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1))
                                                     (@category_theory.monad.forget_creates_limits.cone_point.{v₁
                                                        u₁}
                                                        C
                                                        𝒞
                                                        T
                                                        _inst_1
                                                        J
                                                        𝒥
                                                        D
                                                        _inst_2))
                                                  j)))
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1))
                                                  (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1))
                                                  (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1))
                                                  (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                     𝒞
                                                     T
                                                     _inst_1
                                                     J
                                                     𝒥
                                                     D
                                                     _inst_2))
                                               j))
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1))
                                                  (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1))
                                                  (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1))
                                                  (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                     𝒞
                                                     T
                                                     _inst_1
                                                     J
                                                     𝒥
                                                     D
                                                     _inst_2))
                                               j))
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j)))
                                 (λ (j : J),
                                    @eq.mpr.{0}
                                      (@eq.{v₁+1}
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.category_struct.comp.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     D
                                                     j)))
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j))
                                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2)
                                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     D
                                                     j))
                                               (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2
                                                  j))
                                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.category_struct.comp.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2)
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j))
                                            (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               j)))
                                      (@eq.{v₁+1}
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.category_struct.comp.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     D
                                                     j)))
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j))
                                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2)
                                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     D
                                                     j))
                                               (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2
                                                  j))
                                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.category_struct.comp.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                  (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                     𝒞)
                                                  (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞
                                                        T
                                                        _inst_1
                                                        J
                                                        𝒥
                                                        D
                                                        _inst_2)))
                                               j)
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C
                                                  𝒞
                                                  C
                                                  𝒞
                                                  (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                     (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                     (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                        𝒞)
                                                     (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                        𝒞)
                                                     (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                        (@category_theory.functor.comp.{v₁
                                                           v₁
                                                           v₁
                                                           v₁
                                                           (max u₁ v₁)
                                                           u₁}
                                                           J
                                                           𝒥
                                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                              𝒞
                                                              T
                                                              _inst_1)
                                                           C
                                                           𝒞
                                                           D
                                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                        _inst_2))
                                                  T)
                                               j)
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               j)
                                            (@category_theory.category_struct.id.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                     (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                     (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                        𝒞)
                                                     (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                        𝒞)
                                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                           (@category_theory.functor.comp.{v₁
                                                              v₁
                                                              v₁
                                                              v₁
                                                              (max u₁ v₁)
                                                              u₁}
                                                              J
                                                              𝒥
                                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T
                                                                 _inst_1)
                                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁}
                                                                 C
                                                                 𝒞
                                                                 T
                                                                 _inst_1)
                                                              C
                                                              𝒞
                                                              D
                                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T
                                                                 _inst_1))
                                                           _inst_2)))
                                                  j))
                                            (@category_theory.category_struct.comp.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥
                                                     C
                                                     𝒞
                                                     C
                                                     𝒞
                                                     (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C
                                                        𝒞
                                                        (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                        (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥
                                                           C
                                                           𝒞)
                                                        (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                           𝒞)
                                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                           (@category_theory.functor.comp.{v₁
                                                              v₁
                                                              v₁
                                                              v₁
                                                              (max u₁ v₁)
                                                              u₁}
                                                              J
                                                              𝒥
                                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T
                                                                 _inst_1)
                                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁}
                                                                 C
                                                                 𝒞
                                                                 T
                                                                 _inst_1)
                                                              C
                                                              𝒞
                                                              D
                                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T
                                                                 _inst_1))
                                                           _inst_2))
                                                     T)
                                                  j)
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥
                                                     C
                                                     𝒞
                                                     C
                                                     𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     T)
                                                  j)
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  j)
                                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C
                                                        𝒞
                                                        (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                        (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥
                                                           C
                                                           𝒞)
                                                        (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                           𝒞)
                                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                           (@category_theory.functor.comp.{v₁
                                                              v₁
                                                              v₁
                                                              v₁
                                                              (max u₁ v₁)
                                                              u₁}
                                                              J
                                                              𝒥
                                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T
                                                                 _inst_1)
                                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁}
                                                                 C
                                                                 𝒞
                                                                 T
                                                                 _inst_1)
                                                              C
                                                              𝒞
                                                              D
                                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T
                                                                 _inst_1))
                                                           _inst_2))
                                                     j)
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     j)
                                                  (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     _inst_2
                                                     j))
                                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     D
                                                     j)))))
                                      (@id.{0}
                                         (@eq.{1} Prop
                                            (@eq.{v₁+1}
                                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                     (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                        (@category_theory.functor.comp.{v₁
                                                           v₁
                                                           v₁
                                                           v₁
                                                           (max u₁ v₁)
                                                           u₁}
                                                           J
                                                           𝒥
                                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                              𝒞
                                                              T
                                                              _inst_1)
                                                           C
                                                           𝒞
                                                           D
                                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                        _inst_2))
                                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        D
                                                        j)))
                                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                     (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                        (@category_theory.functor.comp.{v₁
                                                           v₁
                                                           v₁
                                                           v₁
                                                           (max u₁ v₁)
                                                           u₁}
                                                           J
                                                           𝒥
                                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                              𝒞
                                                              T
                                                              _inst_1)
                                                           C
                                                           𝒞
                                                           D
                                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                        _inst_2))
                                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                           𝒥
                                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                              𝒞
                                                              T
                                                              _inst_1)
                                                           D
                                                           j)))
                                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        D
                                                        j))
                                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                     (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                        (@category_theory.functor.comp.{v₁
                                                           v₁
                                                           v₁
                                                           v₁
                                                           (max u₁ v₁)
                                                           u₁}
                                                           J
                                                           𝒥
                                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                              𝒞
                                                              T
                                                              _inst_1)
                                                           C
                                                           𝒞
                                                           D
                                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                        _inst_2)
                                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                           𝒥
                                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                              𝒞
                                                              T
                                                              _inst_1)
                                                           D
                                                           j))
                                                     (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                                        (@category_theory.functor.comp.{v₁
                                                           v₁
                                                           v₁
                                                           v₁
                                                           (max u₁ v₁)
                                                           u₁}
                                                           J
                                                           𝒥
                                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                              𝒞
                                                              T
                                                              _inst_1)
                                                           C
                                                           𝒞
                                                           D
                                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                        _inst_2
                                                        j))
                                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        D
                                                        j)))
                                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                     (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                        (… D …)
                                                        _inst_2))
                                                  …
                                                  …
                                                  …
                                                  …))
                                            …)
                                         …)
                                      …)
                                 j))
                         …)))))
          …
          …
          …)
       …)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2)
             (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2
                (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                   s)))
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2)
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s))
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2
             (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                s)))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77          simp only [limit.lift_π, limit.cone_π, forget_map, id_comp, functor.const_comp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='category_theory.limits.limit.lift_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.limit.cone_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.monad.forget_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.const_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 455, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 440, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/algebra.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F) (j : J), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞)) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j)) (@category_theory.category_struct.comp.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) (@category_theory.limits.limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j) (@category_theory.limits.limit.lift.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 c) (@category_theory.limits.limit.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 j)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F] (j : J), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞)) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3))) j) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3))) F (@category_theory.limits.cone.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3)) j) (@category_theory.limits.limit.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] (T : @category_theory.functor.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{?l_2 ?l_1} C 𝒞 T] (A B : @category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (f : @category_theory.has_hom.hom.{?l_2 (max ?l_1 ?l_2)} (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.category_struct.to_has_hom.{?l_2 (max ?l_1 ?l_2)} (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.category.to_category_struct.{?l_2 (max ?l_1 ?l_2)} (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1))) A B), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 B)) (@category_theory.functor.map.{?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1) A B f) (@category_theory.monad.algebra.hom.f.{?l_2 ?l_1} C 𝒞 T _inst_1 A B f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (J : Type ?l_1) [𝒥 : category_theory.category.{?l_2 ?l_1} J] {C : Type ?l_3} [𝒞 : category_theory.category.{?l_4 ?l_3} C] {D : Type ?l_5} [𝒟 : category_theory.category.{?l_6 ?l_5} D] (X : C) (F : @category_theory.functor.{?l_4 ?l_6 ?l_3 ?l_5} C 𝒞 D 𝒟), @category_theory.iso.{(max ?l_1 ?l_6) (max ?l_2 ?l_6 ?l_1 ?l_5)} (@category_theory.functor.{?l_2 ?l_6 ?l_1 ?l_5} J 𝒥 D 𝒟) (@category_theory.functor.category.{?l_2 ?l_6 ?l_1 ?l_5} J 𝒥 D 𝒟) (@category_theory.functor.comp.{?l_2 ?l_4 ?l_6 ?l_1 ?l_3 ?l_5} J 𝒥 C 𝒞 D 𝒟 (@category_theory.functor.obj.{?l_4 (max ?l_1 ?l_4) ?l_3 (max ?l_2 ?l_4 ?l_1 ?l_3)} C 𝒞 (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} J 𝒥 C 𝒞) (@category_theory.functor.category.{?l_2 ?l_4 ?l_1 ?l_3} J 𝒥 C 𝒞) (@category_theory.functor.const.{?l_2 ?l_4 ?l_1 ?l_3} J 𝒥 C 𝒞) X) F) (@category_theory.functor.obj.{?l_6 (max ?l_1 ?l_6) ?l_5 (max ?l_2 ?l_6 ?l_1 ?l_5)} D 𝒟 (@category_theory.functor.{?l_2 ?l_6 ?l_1 ?l_5} J 𝒥 D 𝒟) (@category_theory.functor.category.{?l_2 ?l_6 ?l_1 ?l_5} J 𝒥 D 𝒟) (@category_theory.functor.const.{?l_2 ?l_6 ?l_1 ?l_5} J 𝒥 D 𝒟) (@category_theory.functor.obj.{?l_4 ?l_6 ?l_3 ?l_5} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='These are actually equal, of course, but not definitionally equal
 (the equality requires F.map (𝟙 _) = 𝟙 _). A natural isomorphism is
 more convenient than an equality between functors (compare id_to_iso).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2)
             (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2
                (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                   s)))
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2)
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s))
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2
             (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                s)))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78                      whisker_right_app, nat_trans.comp_app, category.assoc, functor.map_cone_π],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='category_theory.whisker_right_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.nat_trans.comp_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.map_cone_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 359, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {D : Type ?l_3} [𝒟 : category_theory.category.{?l_4 ?l_3} D] {E : Type ?l_5} [ℰ : category_theory.category.{?l_6 ?l_5} E] {G H : @category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.functor.category.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟))) G H) (F : @category_theory.functor.{?l_4 ?l_6 ?l_3 ?l_5} D 𝒟 E ℰ) (c : C), @eq.{?l_6+1} (@category_theory.has_hom.hom.{?l_6 ?l_5} E (@category_theory.category_struct.to_has_hom.{?l_6 ?l_5} E (@category_theory.category.to_category_struct.{?l_6 ?l_5} E ℰ)) (@category_theory.functor.obj.{?l_4 ?l_6 ?l_3 ?l_5} D 𝒟 E ℰ F (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 G c)) (@category_theory.functor.obj.{?l_4 ?l_6 ?l_3 ?l_5} D 𝒟 E ℰ F (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 H c))) (@category_theory.nat_trans.app.{?l_2 ?l_6 ?l_1 ?l_5} C 𝒞 E ℰ (@category_theory.functor.comp.{?l_2 ?l_4 ?l_6 ?l_1 ?l_3 ?l_5} C 𝒞 D 𝒟 E ℰ G F) (@category_theory.functor.comp.{?l_2 ?l_4 ?l_6 ?l_1 ?l_3 ?l_5} C 𝒞 D 𝒟 E ℰ H F) (@category_theory.whisker_right.{?l_1 ?l_2 ?l_3 ?l_4 ?l_5 ?l_6} C 𝒞 D 𝒟 E ℰ G H α F) c) (@category_theory.functor.map.{?l_4 ?l_6 ?l_3 ?l_5} D 𝒟 E ℰ F (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 G c) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 H c) (@category_theory.nat_trans.app.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 G H α c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {D : Type ?l_3} [𝒟 : category_theory.category.{?l_4 ?l_3} D] {F G H : @category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.functor.category.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟))) F G) (β : @category_theory.has_hom.hom.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.functor.category.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟))) G H) (X : C), @eq.{?l_4+1} (@category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 H X)) (@category_theory.nat_trans.app.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F H (@category_theory.category_struct.comp.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max ?l_1 ?l_4) (max ?l_2 ?l_4 ?l_1 ?l_3)} (@category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟) (@category_theory.functor.category.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟)) F G H α β) X) (@category_theory.category_struct.comp.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 H X) (@category_theory.nat_trans.app.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 F G α X) (@category_theory.nat_trans.app.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟 G H β X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W X) (g : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (h : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) Y Z), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W Z) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W Y Z (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Z f (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {D : Type ?l_3} [_inst_2 : category_theory.category.{?l_1 ?l_3} D] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞} (H : @category_theory.functor.{?l_1 ?l_1 ?l_2 ?l_3} C 𝒞 D _inst_2) (c : @category_theory.limits.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F) (j : J), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_1 ?l_3} D (@category_theory.category.to_category_struct.{?l_1 ?l_3} D _inst_2)) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_3 (max ?l_1 ?l_3)} D _inst_2 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2) (@category_theory.limits.cone.X.{?l_1 ?l_3} J _inst_1 D _inst_2 (@category_theory.functor.comp.{?l_1 ?l_1 ?l_1 ?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H) (@category_theory.functor.map_cone.{?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H c))) j) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2 (@category_theory.functor.comp.{?l_1 ?l_1 ?l_1 ?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H) j)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_3 (max ?l_1 ?l_3)} D _inst_2 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2) (@category_theory.limits.cone.X.{?l_1 ?l_3} J _inst_1 D _inst_2 (@category_theory.functor.comp.{?l_1 ?l_1 ?l_1 ?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H) (@category_theory.functor.map_cone.{?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H c))) (@category_theory.functor.comp.{?l_1 ?l_1 ?l_1 ?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H) (@category_theory.limits.cone.π.{?l_1 ?l_3} J _inst_1 D _inst_2 (@category_theory.functor.comp.{?l_1 ?l_1 ?l_1 ?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H) (@category_theory.functor.map_cone.{?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H c)) j) (@category_theory.functor.map.{?l_1 ?l_1 ?l_2 ?l_3} C 𝒞 D _inst_2 H (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2)
             (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2
                (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                   s)))
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2)
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s))
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2
             (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                s)))
       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2)
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2
             (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                s)))
       (@category_theory.nat_trans.app.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
             (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
             (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
             (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
             (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)))
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          (@category_theory.limits.cone.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)
          (@category_theory.nat_trans.app.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             D
             (@category_theory.limits.cone.π.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79          dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2)
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2
             (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                s)))
       (@category_theory.nat_trans.app.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
             (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
             (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
             (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
             (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)))
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          (@category_theory.limits.cone.π.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)
          (@category_theory.nat_trans.app.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             D
             (@category_theory.limits.cone.π.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2)
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2
             (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                s)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_2)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_2))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j)))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_2)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j))
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_2
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)
          (@category_theory.nat_trans.app.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             D
             (@category_theory.limits.cone.π.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80          rw [id_comp, ←category.assoc, ←T.map_comp],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X X Y (@category_theory.category_struct.id.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D s)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D s))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)))) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D s)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D s)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) f g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D s))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D s)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) f) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2)
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2
             (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                s)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_2)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_2))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j)))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_2)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      D
                      j))
                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      D
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                   _inst_2
                   j))
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)
          (@category_theory.nat_trans.app.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             D
             (@category_theory.limits.cone.π.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s))
          (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2)
          (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
             _inst_2
             (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                D
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                s)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2
                j))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)
          (@category_theory.nat_trans.app.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             D
             (@category_theory.limits.cone.π.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j)))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2)
             (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2
                (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                   s)))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2
                j)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)
          (@category_theory.nat_trans.app.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             D
             (@category_theory.limits.cone.π.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2
                (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                   s))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2
                j)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)
          (@category_theory.nat_trans.app.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             D
             (@category_theory.limits.cone.π.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81          simp only [limit.lift_π, monad.forget_map, algebra.hom.h, functor.map_cone_π],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='category_theory.limits.limit.lift_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.monad.forget_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.monad.algebra.hom.h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.map_cone_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 455, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/algebra.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/algebra.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 359, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F) (j : J), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞)) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j)) (@category_theory.category_struct.comp.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) (@category_theory.limits.limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j) (@category_theory.limits.limit.lift.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 c) (@category_theory.limits.limit.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 j)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] (T : @category_theory.functor.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{?l_2 ?l_1} C 𝒞 T] (A B : @category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (f : @category_theory.has_hom.hom.{?l_2 (max ?l_1 ?l_2)} (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.category_struct.to_has_hom.{?l_2 (max ?l_1 ?l_2)} (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.category.to_category_struct.{?l_2 (max ?l_1 ?l_2)} (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1))) A B), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 B)) (@category_theory.functor.map.{?l_2 ?l_2 (max ?l_1 ?l_2) ?l_1} (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) C 𝒞 (@category_theory.monad.forget.{?l_2 ?l_1} C 𝒞 T _inst_1) A B f) (@category_theory.monad.algebra.hom.f.{?l_2 ?l_1} C 𝒞 T _inst_1 A B f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {T : @category_theory.functor.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{?l_2 ?l_1} C 𝒞 T] {A B : @category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1} (c : @category_theory.monad.algebra.hom.{?l_2 ?l_1} C 𝒞 T _inst_1 A B), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 A)) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 B)) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 A)) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 B)) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 B) (@category_theory.functor.map.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 B) (@category_theory.monad.algebra.hom.f.{?l_2 ?l_1} C 𝒞 T _inst_1 A B c)) (@category_theory.monad.algebra.a.{?l_2 ?l_1} C 𝒞 T _inst_1 B)) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 A)) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 B) (@category_theory.monad.algebra.a.{?l_2 ?l_1} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.hom.f.{?l_2 ?l_1} C 𝒞 T _inst_1 A B c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {D : Type ?l_3} [_inst_2 : category_theory.category.{?l_1 ?l_3} D] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞} (H : @category_theory.functor.{?l_1 ?l_1 ?l_2 ?l_3} C 𝒞 D _inst_2) (c : @category_theory.limits.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F) (j : J), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_1 ?l_3} D (@category_theory.category.to_category_struct.{?l_1 ?l_3} D _inst_2)) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_3 (max ?l_1 ?l_3)} D _inst_2 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2) (@category_theory.limits.cone.X.{?l_1 ?l_3} J _inst_1 D _inst_2 (@category_theory.functor.comp.{?l_1 ?l_1 ?l_1 ?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H) (@category_theory.functor.map_cone.{?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H c))) j) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2 (@category_theory.functor.comp.{?l_1 ?l_1 ?l_1 ?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H) j)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_3 (max ?l_1 ?l_3)} D _inst_2 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_3} J _inst_1 D _inst_2) (@category_theory.limits.cone.X.{?l_1 ?l_3} J _inst_1 D _inst_2 (@category_theory.functor.comp.{?l_1 ?l_1 ?l_1 ?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H) (@category_theory.functor.map_cone.{?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H c))) (@category_theory.functor.comp.{?l_1 ?l_1 ?l_1 ?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H) (@category_theory.limits.cone.π.{?l_1 ?l_3} J _inst_1 D _inst_2 (@category_theory.functor.comp.{?l_1 ?l_1 ?l_1 ?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H) (@category_theory.functor.map_cone.{?l_1 ?l_2 ?l_3} J _inst_1 C 𝒞 D _inst_2 F H c)) j) (@category_theory.functor.map.{?l_1 ?l_1 ?l_2 ?l_3} C 𝒞 D _inst_2 H (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                j))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   j))
             (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2
                (@category_theory.functor.map_cone.{v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                   s))
             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   D
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                _inst_2
                j)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s)
          (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             j)
          (@category_theory.nat_trans.app.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   D
                   s))
             D
             (@category_theory.limits.cone.π.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                s)
             j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82        end },</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83      uniq&#x27; := λ s m w, by { ext1, ext1, simpa using congr_arg algebra.hom.f (w j) } } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.monad.algebra.hom.f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/algebra.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))) (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D s) (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2) (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) D (λ (j : J), @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j) (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j) (@id.{0} (∀ (j : J), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j))) (λ (j : J), @eq.mpr.{0} (@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j))) (@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) T) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) j) (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2))) j)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) T) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) T) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) j) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) j) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))))) (@id.{0} (@eq.{1} Prop (@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j))) (@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (… … C 𝒞 D …) _inst_2)) …) … …)) …) …) j)) …)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (j : J), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))) (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D s) (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.category_struct.comp.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D s) (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2) (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) D (λ (j : J), @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j) (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j) (@id.{0} (∀ (j : J), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j))) (λ (j : J), @eq.mpr.{0} (@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j))) (@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) T) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) j) (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2))) j)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) T) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) T) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) j) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) j) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))))) (@id.{0} (@eq.{1} Prop (@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) …)) …) …) …) j)) …))) … m …) …'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v₁} {a₁ a₂ : α} (f : α → β), @eq.{v₁+1} α a₁ a₂ → @eq.{v₁+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] {A B : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1}, @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 A B → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (j : J), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))) (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D s) (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.category_struct.comp.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D s) (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2) (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) D (λ (j : J), @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j) (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j) (@id.{0} (∀ (j : J), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j))) (λ (j : J), @eq.mpr.{0} (@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j))) (@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) T) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) j) (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2))) j)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) T) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) T) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) j) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) j) (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) j) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))))) (@id.{0} (@eq.{1} Prop (@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 j)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2)) (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D j)) (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)) _inst_2 (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)) …)) …) …) …) j)) …))) … m …) …'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`ext1 id` selects and apply one extensionality lemma (with attribute
`ext`), using `id`, if provided, to name a local constant
introduced by the lemma. If `id` is omitted, the local constant is
named automatically, as per `intro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`ext1 id` selects and apply one extensionality lemma (with attribute
`ext`), using `id`, if provided, to name a local constant
introduced by the lemma. If `id` is omitted, the local constant is
named automatically, as per `intro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='ext1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
m :
  @category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
    (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       D
       s)
    (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       D
       (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)
          (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
             D
             (λ (j : J),
                @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                        (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                        (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                        (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                           _inst_2))
                     j)
                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                     D
                     j)
                  (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                     (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                        C
                        𝒞
                        D
                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                     _inst_2
                     j)
                  (@id.{0}
                     (∀ (j : J),
                        @eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j)))
                             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   D
                                   j)))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j)))
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   D
                                   j))
                             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   _inst_2
                                   j))
                             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   D
                                   j)))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j)))
                             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                         _inst_1
                                         J
                                         𝒥
                                         D
                                         _inst_2))
                                   j))
                             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   D
                                   j))
                             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                         _inst_1
                                         J
                                         𝒥
                                         D
                                         _inst_2))
                                   j))
                             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   C
                                   𝒞
                                   D
                                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                _inst_2
                                j)))
                     (λ (j : J),
                        @eq.mpr.{0}
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2)
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2
                                      j))
                                (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   _inst_2)
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   _inst_2
                                   (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                                      _inst_2))
                                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   _inst_2
                                   j)))
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2)
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2
                                      j))
                                (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                      (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                      (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                      (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                      (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                            𝒥
                                            D
                                            _inst_2)))
                                   j)
                                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                         (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      T)
                                   j)
                                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   j)
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                         (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2)))
                                      j))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                         𝒞
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                            (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2))
                                         T)
                                      j)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                         𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         T)
                                      j)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      j)
                                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                            (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2))
                                         j)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         j)
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j))
                                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))))
                          (@id.{0}
                             (@eq.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2)
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j))
                                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2)
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                            𝒥
                                            D
                                            _inst_2))
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j)))
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (… … C 𝒞 D …)
                                            _inst_2))
                                      …)
                                   …
                                   …))
                             …)
                          …)
                     j))
             …))),
w :
  ∀ (j : J),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
         (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
         (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
            D
            s)
         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
            D
            j))
      (@category_theory.category_struct.comp.{v₁ (max u₁ v₁)}
         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
         (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
         (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
            D
            s)
         (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
            D
            (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥
               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
               D
               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)
               (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                  (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                     (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                     (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                     (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                        _inst_2))
                  D
                  (λ (j : J),
                     @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
                       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                          (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                             (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                             (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                             (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                             (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                𝒥
                                D
                                _inst_2))
                          j)
                       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                          D
                          j)
                       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                             C
                             𝒞
                             D
                             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                          _inst_2
                          j)
                       (@id.{0}
                          (∀ (j : J),
                             @eq.{v₁+1}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                 𝒞
                                                 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           j)))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        D
                                        j)))
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                 𝒞
                                                 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           j)))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        D
                                        j))
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                 𝒞
                                                 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           j))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j))
                                     (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        _inst_2
                                        j))
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        D
                                        j)))
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                 𝒞
                                                 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           j)))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                              _inst_1
                                              J
                                              𝒥
                                              D
                                              _inst_2))
                                        j))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        D
                                        j))
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                              _inst_1
                                              J
                                              𝒥
                                              D
                                              _inst_2))
                                        j))
                                  (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                     (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        C
                                        𝒞
                                        D
                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                     _inst_2
                                     j)))
                          (λ (j : J),
                             @eq.mpr.{0}
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j)))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j))
                                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2)
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j))
                                        (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2
                                           j))
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        _inst_2)
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j))
                                     (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        _inst_2
                                        (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                           𝒥
                                           D
                                           _inst_2))
                                     (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        _inst_2
                                        j)))
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j)))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j))
                                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2)
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j))
                                        (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2
                                           j))
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                           (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                           (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                           (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                           (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2)))
                                        j)
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                           𝒞
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                              (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2))
                                           T)
                                        j)
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        j)
                                     (@category_theory.category_struct.id.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                              (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                 (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                    (@category_theory.functor.comp.{v₁
                                                       v₁
                                                       v₁
                                                       v₁
                                                       (max u₁ v₁)
                                                       u₁}
                                                       J
                                                       𝒥
                                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞
                                                          T
                                                          _inst_1)
                                                       C
                                                       𝒞
                                                       D
                                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                    _inst_2)))
                                           j))
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                              C
                                              𝒞
                                              (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                    (@category_theory.functor.comp.{v₁
                                                       v₁
                                                       v₁
                                                       v₁
                                                       (max u₁ v₁)
                                                       u₁}
                                                       J
                                                       𝒥
                                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞
                                                          T
                                                          _inst_1)
                                                       C
                                                       𝒞
                                                       D
                                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                    _inst_2))
                                              T)
                                           j)
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                              C
                                              𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              T)
                                           j)
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           j)
                                        (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                    (@category_theory.functor.comp.{v₁
                                                       v₁
                                                       v₁
                                                       v₁
                                                       (max u₁ v₁)
                                                       u₁}
                                                       J
                                                       𝒥
                                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞
                                                          T
                                                          _inst_1)
                                                       C
                                                       𝒞
                                                       D
                                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                    _inst_2))
                                              j)
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              j)
                                           (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              _inst_2
                                              j))
                                        (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j)))))
                               (@id.{0}
                                  (@eq.{1} Prop
                                     (@eq.{v₁+1}
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2))
                                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 D
                                                 j)))
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2))
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    D
                                                    j)))
                                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 D
                                                 j))
                                           (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2)
                                              (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    D
                                                    j))
                                              (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2
                                                 j))
                                           (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 D
                                                 j)))
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2))
                                           (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              _inst_2)
                                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 D
                                                 j))
                                           (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              _inst_2
                                              (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           …))
                                     …)
                                  …)
                               …)
                          j))
                  …)))
         …
         m
         …)
      …
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
       (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          s)
       (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)
             (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                   (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                   (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                   (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                      _inst_2))
                D
                (λ (j : J),
                   @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                           (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                           (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                           (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥
                              D
                              _inst_2))
                        j)
                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                        D
                        j)
                     (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           C
                           𝒞
                           D
                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                        _inst_2
                        j)
                     (@id.{0}
                        (∀ (j : J),
                           @eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞
                                               T
                                               _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2))
                                         j)))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞
                                               T
                                               _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2))
                                         j)))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞
                                               T
                                               _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2))
                                         j))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2
                                      j))
                                (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞
                                               T
                                               _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2))
                                         j)))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j))
                                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   _inst_2
                                   j)))
                        (λ (j : J),
                           @eq.mpr.{0}
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2)
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j))
                                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2))
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2)
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2
                                      (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                         𝒥
                                         D
                                         _inst_2))
                                   (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2
                                      j)))
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2)
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j))
                                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                         (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2)))
                                      j)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                         𝒞
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                            (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2))
                                         T)
                                      j)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      j)
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                            (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2)))
                                         j))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                            𝒞
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                               (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            T)
                                         j)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                            𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            T)
                                         j)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         j)
                                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                               (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            j)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            j)
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j))
                                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))))
                             (@id.{0}
                                (@eq.{1} Prop
                                   (@eq.{v₁+1}
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2))
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2))
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2)
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j))
                                            (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               j))
                                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2))
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2)
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2))
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j)))
                                   (@eq.{v₁+1}
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (… …) _inst_2))
                                         …)
                                      …
                                      …))
                                …)
                             …)
                        j))
                …))))
    m
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
m :
  @category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
    (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       D
       s)
    (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       D
       (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)
          (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
             D
             (λ (j : J),
                @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                        (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                        (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                        (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                           _inst_2))
                     j)
                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                     D
                     j)
                  (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                     (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                        C
                        𝒞
                        D
                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                     _inst_2
                     j)
                  (@id.{0}
                     (∀ (j : J),
                        @eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j)))
                             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   D
                                   j)))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j)))
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   D
                                   j))
                             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   _inst_2
                                   j))
                             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   D
                                   j)))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j)))
                             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                         _inst_1
                                         J
                                         𝒥
                                         D
                                         _inst_2))
                                   j))
                             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   D
                                   j))
                             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                         _inst_1
                                         J
                                         𝒥
                                         D
                                         _inst_2))
                                   j))
                             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   C
                                   𝒞
                                   D
                                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                _inst_2
                                j)))
                     (λ (j : J),
                        @eq.mpr.{0}
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2)
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2
                                      j))
                                (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   _inst_2)
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   _inst_2
                                   (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                                      _inst_2))
                                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   _inst_2
                                   j)))
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2)
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2
                                      j))
                                (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                      (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                      (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                      (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                      (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                            𝒥
                                            D
                                            _inst_2)))
                                   j)
                                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                         (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      T)
                                   j)
                                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   j)
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                         (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2)))
                                      j))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                         𝒞
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                            (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2))
                                         T)
                                      j)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                         𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         T)
                                      j)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      j)
                                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                            (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2))
                                         j)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         j)
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j))
                                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))))
                          (@id.{0}
                             (@eq.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2)
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j))
                                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2)
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                            𝒥
                                            D
                                            _inst_2))
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j)))
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (… … C 𝒞 D …)
                                            _inst_2))
                                      …)
                                   …
                                   …))
                             …)
                          …)
                     j))
             …))),
w :
  ∀ (j : J),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
         (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
         (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
            D
            s)
         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
            D
            j))
      (@category_theory.category_struct.comp.{v₁ (max u₁ v₁)}
         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
         (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
         (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
            D
            s)
         (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
            D
            (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥
               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
               D
               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)
               (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                  (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                     (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                     (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                     (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                        _inst_2))
                  D
                  (λ (j : J),
                     @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
                       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                          (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                             (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                             (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                             (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                             (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                𝒥
                                D
                                _inst_2))
                          j)
                       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                          D
                          j)
                       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                             C
                             𝒞
                             D
                             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                          _inst_2
                          j)
                       (@id.{0}
                          (∀ (j : J),
                             @eq.{v₁+1}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                 𝒞
                                                 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           j)))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        D
                                        j)))
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                 𝒞
                                                 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           j)))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        D
                                        j))
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                 𝒞
                                                 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           j))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j))
                                     (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        _inst_2
                                        j))
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        D
                                        j)))
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                 𝒞
                                                 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           j)))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                              _inst_1
                                              J
                                              𝒥
                                              D
                                              _inst_2))
                                        j))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        D
                                        j))
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                              _inst_1
                                              J
                                              𝒥
                                              D
                                              _inst_2))
                                        j))
                                  (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                     (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        C
                                        𝒞
                                        D
                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                     _inst_2
                                     j)))
                          (λ (j : J),
                             @eq.mpr.{0}
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j)))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j))
                                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2)
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j))
                                        (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2
                                           j))
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        _inst_2)
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j))
                                     (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        _inst_2
                                        (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                           𝒥
                                           D
                                           _inst_2))
                                     (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        _inst_2
                                        j)))
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j)))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j))
                                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2)
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j))
                                        (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2
                                           j))
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                           (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                           (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                           (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                           (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2)))
                                        j)
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                           𝒞
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                              (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2))
                                           T)
                                        j)
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        j)
                                     (@category_theory.category_struct.id.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                              (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                 (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                    (@category_theory.functor.comp.{v₁
                                                       v₁
                                                       v₁
                                                       v₁
                                                       (max u₁ v₁)
                                                       u₁}
                                                       J
                                                       𝒥
                                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞
                                                          T
                                                          _inst_1)
                                                       C
                                                       𝒞
                                                       D
                                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                    _inst_2)))
                                           j))
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                              C
                                              𝒞
                                              (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                    (@category_theory.functor.comp.{v₁
                                                       v₁
                                                       v₁
                                                       v₁
                                                       (max u₁ v₁)
                                                       u₁}
                                                       J
                                                       𝒥
                                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞
                                                          T
                                                          _inst_1)
                                                       C
                                                       𝒞
                                                       D
                                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                    _inst_2))
                                              T)
                                           j)
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                              C
                                              𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              T)
                                           j)
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           j)
                                        (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                    (@category_theory.functor.comp.{v₁
                                                       v₁
                                                       v₁
                                                       v₁
                                                       (max u₁ v₁)
                                                       u₁}
                                                       J
                                                       𝒥
                                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞
                                                          T
                                                          _inst_1)
                                                       C
                                                       𝒞
                                                       D
                                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                    _inst_2))
                                              j)
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              j)
                                           (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              _inst_2
                                              j))
                                        (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j)))))
                               (@id.{0}
                                  (@eq.{1} Prop
                                     (@eq.{v₁+1}
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2))
                                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 D
                                                 j)))
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2))
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    D
                                                    j)))
                                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 D
                                                 j))
                                           (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2)
                                              (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    D
                                                    j))
                                              (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2
                                                 j))
                                           (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 D
                                                 j)))
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2))
                                           (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              _inst_2)
                                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 D
                                                 j))
                                           (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              _inst_2
                                              (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           …))
                                     …)
                                  …)
                               …)
                          j))
                  …)))
         …
         m
         …)
      …
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)
                (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                      (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                      (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                      (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                         _inst_2))
                   D
                   (λ (j : J),
                      @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                 𝒥
                                 D
                                 _inst_2))
                           j)
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           D
                           j)
                        (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              C
                              𝒞
                              D
                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                           _inst_2
                           j)
                        (@id.{0}
                           (∀ (j : J),
                              @eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j)))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j))
                                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞
                                               T
                                               _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2))
                                         j))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞
                                               T
                                               _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2))
                                         j))
                                   (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2
                                      j)))
                           (λ (j : J),
                              @eq.mpr.{0}
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2)
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j))
                                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2)
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                            𝒥
                                            D
                                            _inst_2))
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j)))
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2)
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j))
                                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                            (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2)))
                                         j)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                            𝒞
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                               (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            T)
                                         j)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         j)
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                               (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                  (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     _inst_2)))
                                            j))
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                               C
                                               𝒞
                                               (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                  (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                     𝒞)
                                                  (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     _inst_2))
                                               T)
                                            j)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                               C
                                               𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               T)
                                            j)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            j)
                                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                  (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                     𝒞)
                                                  (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     _inst_2))
                                               j)
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               j)
                                            (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               j))
                                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))))
                                (@id.{0}
                                   (@eq.{1} Prop
                                      (@eq.{v₁+1}
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.category_struct.comp.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     D
                                                     j)))
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j))
                                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2)
                                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     D
                                                     j))
                                               (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2
                                                  j))
                                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.category_struct.comp.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2)
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j))
                                            (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               j)))
                                      (@eq.{v₁+1}
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (… T _inst_1)
                                                     …
                                                     C
                                                     𝒞
                                                     D
                                                     …)
                                                  _inst_2))
                                            …)
                                         …
                                         …))
                                   …)
                                …)
                           j))
                   …)))))
    …
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J,
D :
  @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1),
_inst_2 :
  @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞
    (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       D
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)),
s :
  @category_theory.limits.cone.{v₁ (max u₁ v₁)} J 𝒥
    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
    D,
m :
  @category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
    (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       D
       s)
    (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       D
       (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          D
          (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)
          (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2))
             D
             (λ (j : J),
                @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                        (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                        (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                        (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                           _inst_2))
                     j)
                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                     D
                     j)
                  (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                     (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                        C
                        𝒞
                        D
                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                     _inst_2
                     j)
                  (@id.{0}
                     (∀ (j : J),
                        @eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j)))
                             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   D
                                   j)))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j)))
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   D
                                   j))
                             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   _inst_2
                                   j))
                             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   D
                                   j)))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                               _inst_1))
                                         (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                            _inst_1
                                            J
                                            𝒥
                                            D
                                            _inst_2))
                                      j)))
                             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                         _inst_1
                                         J
                                         𝒥
                                         D
                                         _inst_2))
                                   j))
                             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   D
                                   j))
                             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                                      (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                         _inst_1
                                         J
                                         𝒥
                                         D
                                         _inst_2))
                                   j))
                             (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                   C
                                   𝒞
                                   D
                                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                _inst_2
                                j)))
                     (λ (j : J),
                        @eq.mpr.{0}
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2)
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2
                                      j))
                                (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   _inst_2)
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   _inst_2
                                   (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                                      _inst_2))
                                (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   _inst_2
                                   j)))
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2))
                                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j))
                                (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                   (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2)
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2
                                      j))
                                (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      D
                                      j)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                      (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                      (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                      (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                      (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                            𝒥
                                            D
                                            _inst_2)))
                                   j)
                                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C 𝒞
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                         (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      T)
                                   j)
                                (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                   (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                      C
                                      𝒞
                                      D
                                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                   j)
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                         (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2)))
                                      j))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                         𝒞
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                            (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2))
                                         T)
                                      j)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                         𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         T)
                                      j)
                                   (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      j)
                                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                            (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2))
                                         j)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         j)
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j))
                                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))))
                          (@id.{0}
                             (@eq.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2)
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j))
                                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2)
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                            𝒥
                                            D
                                            _inst_2))
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j)))
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞 (… … C 𝒞 D …)
                                            _inst_2))
                                      …)
                                   …
                                   …))
                             …)
                          …)
                     j))
             …))),
w :
  ∀ (j : J),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
         (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
         (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
            D
            s)
         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
            D
            j))
      (@category_theory.category_struct.comp.{v₁ (max u₁ v₁)}
         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
         (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
         (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
            D
            s)
         (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
            D
            (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥
               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
               D
               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)
               (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                  (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                     (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                     (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                     (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                     (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                        _inst_2))
                  D
                  (λ (j : J),
                     @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
                       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                          (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                             (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                             (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                             (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                             (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                𝒥
                                D
                                _inst_2))
                          j)
                       (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                          D
                          j)
                       (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                             C
                             𝒞
                             D
                             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                          _inst_2
                          j)
                       (@id.{0}
                          (∀ (j : J),
                             @eq.{v₁+1}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                 𝒞
                                                 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           j)))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        D
                                        j)))
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                 𝒞
                                                 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           j)))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        D
                                        j))
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                 𝒞
                                                 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           j))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j))
                                     (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        _inst_2
                                        j))
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        D
                                        j)))
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1))
                                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                 𝒞
                                                 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           j)))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                              _inst_1
                                              J
                                              𝒥
                                              D
                                              _inst_2))
                                        j))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        D
                                        j))
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1))
                                           (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T
                                              _inst_1
                                              J
                                              𝒥
                                              D
                                              _inst_2))
                                        j))
                                  (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                     (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                        C
                                        𝒞
                                        D
                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                     _inst_2
                                     j)))
                          (λ (j : J),
                             @eq.mpr.{0}
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j)))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j))
                                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2)
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j))
                                        (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2
                                           j))
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        _inst_2)
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j))
                                     (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        _inst_2
                                        (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                           𝒥
                                           D
                                           _inst_2))
                                     (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        _inst_2
                                        j)))
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j)))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j))
                                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2)
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j))
                                        (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           _inst_2
                                           j))
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           D
                                           j)))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                           (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                           (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                           (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                           (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2)))
                                        j)
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                           𝒞
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                              (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2))
                                           T)
                                        j)
                                     (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                        (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                           C
                                           𝒞
                                           D
                                           (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                        j)
                                     (@category_theory.category_struct.id.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                              (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                 (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                    (@category_theory.functor.comp.{v₁
                                                       v₁
                                                       v₁
                                                       v₁
                                                       (max u₁ v₁)
                                                       u₁}
                                                       J
                                                       𝒥
                                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞
                                                          T
                                                          _inst_1)
                                                       C
                                                       𝒞
                                                       D
                                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                    _inst_2)))
                                           j))
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                              C
                                              𝒞
                                              (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                    (@category_theory.functor.comp.{v₁
                                                       v₁
                                                       v₁
                                                       v₁
                                                       (max u₁ v₁)
                                                       u₁}
                                                       J
                                                       𝒥
                                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞
                                                          T
                                                          _inst_1)
                                                       C
                                                       𝒞
                                                       D
                                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                    _inst_2))
                                              T)
                                           j)
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                              C
                                              𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              T)
                                           j)
                                        (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                              𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              C
                                              𝒞
                                              D
                                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                           j)
                                        (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                 (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                 (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                    (@category_theory.functor.comp.{v₁
                                                       v₁
                                                       v₁
                                                       v₁
                                                       (max u₁ v₁)
                                                       u₁}
                                                       J
                                                       𝒥
                                                       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞
                                                          T
                                                          _inst_1)
                                                       C
                                                       𝒞
                                                       D
                                                       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                    _inst_2))
                                              j)
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              j)
                                           (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              _inst_2
                                              j))
                                        (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                           (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                 _inst_1)
                                              D
                                              j)))))
                               (@id.{0}
                                  (@eq.{1} Prop
                                     (@eq.{v₁+1}
                                        (@category_theory.has_hom.hom.{v₁ u₁} C
                                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2))
                                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 D
                                                 j)))
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2))
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    D
                                                    j)))
                                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 D
                                                 j))
                                           (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2)
                                              (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                 (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    D
                                                    j))
                                              (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2
                                                 j))
                                           (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 D
                                                 j)))
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                              (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                 (@category_theory.functor.comp.{v₁
                                                    v₁
                                                    v₁
                                                    v₁
                                                    (max u₁ v₁)
                                                    u₁}
                                                    J
                                                    𝒥
                                                    (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                    (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                       _inst_1)
                                                    C
                                                    𝒞
                                                    D
                                                    (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                 _inst_2))
                                           (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              _inst_2)
                                           (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                              (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 D
                                                 j))
                                           (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                              (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                 J
                                                 𝒥
                                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                    _inst_1)
                                                 C
                                                 𝒞
                                                 D
                                                 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                              _inst_2
                                              (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                 _inst_1
                                                 J
                                                 𝒥
                                                 D
                                                 _inst_2))
                                           …))
                                     …)
                                  …)
                               …)
                          j))
                  …)))
         …
         m
         …)
      …,
j : J
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          j))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s))
       (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          _inst_2)
       (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             D
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
          j)
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             s)
          (@category_theory.limits.cone.X.{v₁ (max u₁ v₁)} J 𝒥
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             D
             (@category_theory.limits.cone.mk.{v₁ (max u₁ v₁)} J 𝒥
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                D
                (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D _inst_2)
                (@category_theory.nat_trans.mk.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                      (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                      (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                      (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J 𝒥 D
                         _inst_2))
                   D
                   (λ (j : J),
                      @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
                              (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞 T _inst_1 J
                                 𝒥
                                 D
                                 _inst_2))
                           j)
                        (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                           (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                           D
                           j)
                        (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                              (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                              C
                              𝒞
                              D
                              (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                           _inst_2
                           j)
                        (@id.{0}
                           (∀ (j : J),
                              @eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j)))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j))
                                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j)))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1))
                                               (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C
                                                  𝒞
                                                  T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2))
                                            j)))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞
                                               T
                                               _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2))
                                         j))
                                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         D
                                         j))
                                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) (max u₁ v₁)}
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.category.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.functor.const.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1))
                                            (@category_theory.monad.forget_creates_limits.cone_point.{v₁ u₁} C 𝒞
                                               T
                                               _inst_1
                                               J
                                               𝒥
                                               D
                                               _inst_2))
                                         j))
                                   (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥
                                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                         C
                                         𝒞
                                         D
                                         (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                      _inst_2
                                      j)))
                           (λ (j : J),
                              @eq.mpr.{0}
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2)
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j))
                                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2)
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.limits.limit.lift.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T _inst_1 J
                                            𝒥
                                            D
                                            _inst_2))
                                      (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         _inst_2
                                         j)))
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2))
                                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))
                                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j))
                                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                         (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2)
                                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j))
                                         (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            _inst_2
                                            j))
                                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            D
                                            j)))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                            (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                            (@category_theory.limits.cone.X.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               (@category_theory.monad.forget_creates_limits.c.{v₁ u₁} C 𝒞 T
                                                  _inst_1
                                                  J
                                                  𝒥
                                                  D
                                                  _inst_2)))
                                         j)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞 C
                                            𝒞
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                               (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            T)
                                         j)
                                      (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                         (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                            𝒥
                                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                            C
                                            𝒞
                                            D
                                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                         j)
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                               (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                                  (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     _inst_2)))
                                            j))
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                               C
                                               𝒞
                                               (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                  (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                     𝒞)
                                                  (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     _inst_2))
                                               T)
                                            j)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 C 𝒞
                                               C
                                               𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               T)
                                            j)
                                         (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                            (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J
                                               𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               C
                                               𝒞
                                               D
                                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                            j)
                                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.obj.{v₁ v₁ u₁ (max v₁ u₁)} C 𝒞
                                                  (@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.functor.category.{v₁ v₁ v₁ u₁} J 𝒥 C
                                                     𝒞)
                                                  (@category_theory.functor.const.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞)
                                                  (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                     (@category_theory.functor.comp.{v₁
                                                        v₁
                                                        v₁
                                                        v₁
                                                        (max u₁ v₁)
                                                        u₁}
                                                        J
                                                        𝒥
                                                        (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                        (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C
                                                           𝒞
                                                           T
                                                           _inst_1)
                                                        C
                                                        𝒞
                                                        D
                                                        (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                     _inst_2))
                                               j)
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               j)
                                            (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  C
                                                  𝒞
                                                  D
                                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                               _inst_2
                                               j))
                                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                            (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                  _inst_1)
                                               D
                                               j)))))
                                (@id.{0}
                                   (@eq.{1} Prop
                                      (@eq.{v₁+1}
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.category_struct.comp.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     D
                                                     j)))
                                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j))
                                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2)
                                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                                                  (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     D
                                                     j))
                                               (@category_theory.limits.limit.π.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2
                                                  j))
                                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                                               (@category_theory.functor.obj.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                     _inst_1)
                                                  D
                                                  j)))
                                         (@category_theory.category_struct.comp.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                               (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                                  (@category_theory.functor.comp.{v₁
                                                     v₁
                                                     v₁
                                                     v₁
                                                     (max u₁ v₁)
                                                     u₁}
                                                     J
                                                     𝒥
                                                     (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                     (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T
                                                        _inst_1)
                                                     C
                                                     𝒞
                                                     D
                                                     (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))
                                                  _inst_2))
                                            (@category_theory.limits.limit.{v₁ u₁} J 𝒥 C 𝒞
                                               (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁}
                                                  J
                                                  𝒥
                                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                                  …
                                                  C
                                                  𝒞
                                                  D
                                                  …)
                                               _inst_2)
                                            …
                                            …
                                            …))
                                      …)
                                   …)
                                …)
                           j))
                   …)))
          m)
       …)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  end monad</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  variables {C : Type u₁} [𝒞 : category.{v₁} C] {D : Type u₁} [𝒟 : category.{v₁} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  include 𝒞 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  variables {J : Type v₁} [𝒥 : small_category J]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  include 𝒥</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  instance comp_comparison_forget_has_limit</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94    (F : J ⥤ D) (R : D ⥤ C) [monadic_right_adjoint R] [has_limit.{v₁} (F ⋙ R)] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.monadic_right_adjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/adjunction.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v₁) [_inst_1 : category_theory.category.{v₁ v₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v₁} [_inst_1 : category_theory.small_category.{v₁} J] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v₁} [𝒞 : category_theory.category.{v₁ v₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A right adjoint functor `R : D ⥤ C` is *monadic* if the comparison function `monad.comparison R` from `D` to the
category of Eilenberg-Moore algebras for the adjunction is an equivalence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    has_limit ((F ⋙ monad.comparison R) ⋙ monad.forget ((left_adjoint R) ⋙ R)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.monad.comparison'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.monad.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.left_adjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/adjunction.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/algebra.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v₁} [𝒞 : category_theory.category.{v₁ v₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type (max u₁ v₁)} [ℰ : category_theory.category.{v₁ (max u₁ v₁)} E], @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ (max u₁ v₁)} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) [_inst_1 : @category_theory.is_right_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R], @category_theory.functor.{v₂ v₁ u₂ (max u₁ v₁)} D 𝒟 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 (@category_theory.left_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1) R) (@category_theory.adjunction.monad.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1)) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 (@category_theory.left_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1) R) (@category_theory.adjunction.monad.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type v₁} [𝒞 : category_theory.category.{v₁ v₁} C] {D : Type (max u₁ v₁)} [𝒟 : category_theory.category.{v₁ (max u₁ v₁)} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ (max u₁ v₁) u₁} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.functor.{v₁ v₁ (max u₁ v₁) u₁} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) [_inst_1 : @category_theory.is_right_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  (@has_limit_of_iso _ _ _ _ (F ⋙ R) _ _ (iso_whisker_left F (monad.comparison_forget R).symm))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.has_limit_of_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.iso_whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.monad.comparison_forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 488, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/adjunction.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F], @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) F G → @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v₁} [𝒞 : category_theory.category.{v₁ v₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {G H : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) G H → @category_theory.iso.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) [_inst_1 : @category_theory.is_right_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R], @category_theory.iso.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ (max u₁ v₁) u₁} D 𝒟 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 (@category_theory.left_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1) R) (@category_theory.adjunction.monad.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1)) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 (@category_theory.left_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1) R) (@category_theory.adjunction.monad.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1)) C 𝒞 (@category_theory.monad.comparison.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1) (@category_theory.monad.forget.{v₁ u₁} C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 (@category_theory.left_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1) R) (@category_theory.adjunction.monad.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1))) R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ u₁)} [𝒞 : category_theory.category.{(max u₁ v₁) (max v₁ u₁)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₁) (max v₁ u₁)} C 𝒞 X Y → @category_theory.iso.{(max u₁ v₁) (max v₁ u₁)} C 𝒞 Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  instance comp_comparison_has_limit</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99    (F : J ⥤ D) (R : D ⥤ C) [monadic_right_adjoint R] [has_limit.{v₁} (F ⋙ R)] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.monadic_right_adjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/adjunction.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v₁) [_inst_1 : category_theory.category.{v₁ v₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v₁} [_inst_1 : category_theory.small_category.{v₁} J] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v₁} [𝒞 : category_theory.category.{v₁ v₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A right adjoint functor `R : D ⥤ C` is *monadic* if the comparison function `monad.comparison R` from `D` to the
category of Eilenberg-Moore algebras for the adjunction is an equivalence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    has_limit (F ⋙ monad.comparison R) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.monad.comparison'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/adjunction.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v₁} [𝒞 : category_theory.category.{v₁ v₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type (max u₁ v₁)} [ℰ : category_theory.category.{v₁ (max u₁ v₁)} E], @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ (max u₁ v₁)} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) [_inst_1 : @category_theory.is_right_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R], @category_theory.functor.{v₂ v₁ u₂ (max u₁ v₁)} D 𝒟 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 (@category_theory.left_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1) R) (@category_theory.adjunction.monad.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1)) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 (@category_theory.left_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1) R) (@category_theory.adjunction.monad.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  monad.forget_creates_limits (F ⋙ monad.comparison R)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.forget_creates_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.monad.comparison'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/adjunction.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] {J : Type v₁} [𝒥 : category_theory.small_category.{v₁} J] (D : @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)) [_inst_2 : @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ (max u₁ v₁) u₁} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 D (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1))], @category_theory.limits.has_limit.{v₁ (max u₁ v₁)} J 𝒥 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v₁} [𝒞 : category_theory.category.{v₁ v₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type (max u₁ v₁)} [ℰ : category_theory.category.{v₁ (max u₁ v₁)} E], @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ (max u₁ v₁)} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ v₁ (max u₁ v₁)} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) [_inst_1 : @category_theory.is_right_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R], @category_theory.functor.{v₂ v₁ u₂ (max u₁ v₁)} D 𝒟 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 (@category_theory.left_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1) R) (@category_theory.adjunction.monad.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1)) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 (@category_theory.left_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1) R) (@category_theory.adjunction.monad.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  def monadic_creates_limits (F : J ⥤ D) (R : D ⥤ C) [monadic_right_adjoint R] [has_limit.{v₁} (F ⋙ R)] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.monadic_right_adjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/adjunction.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v₁) [_inst_1 : category_theory.category.{v₁ v₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v₁} [_inst_1 : category_theory.small_category.{v₁} J] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v₁} [𝒞 : category_theory.category.{v₁ v₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A right adjoint functor `R : D ⥤ C` is *monadic* if the comparison function `monad.comparison R` from `D` to the
category of Eilenberg-Moore algebras for the adjunction is an equivalence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104    has_limit F :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  adjunction.has_limit_of_comp_equivalence _ (monad.comparison R)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.has_limit_of_comp_equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.monad.comparison'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/limits.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/adjunction.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v u₂} D] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (K : @category_theory.functor.{v v v u₂} J _inst_1 D 𝒟) (E : @category_theory.functor.{v v u₂ u₁} D 𝒟 C 𝒞) [_inst_2 : @category_theory.is_equivalence.{v v u₂ u₁} D 𝒟 C 𝒞 E] [_inst_3 : @category_theory.limits.has_limit.{v u₁} J _inst_1 C 𝒞 (@category_theory.functor.comp.{v v v v u₂ u₁} J _inst_1 D 𝒟 C 𝒞 K E)], @category_theory.limits.has_limit.{v u₂} J _inst_1 D 𝒟 K'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (R : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) [_inst_1 : @category_theory.is_right_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R], @category_theory.functor.{v₂ v₁ u₂ (max u₁ v₁)} D 𝒟 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 (@category_theory.left_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1) R) (@category_theory.adjunction.monad.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1)) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 (@category_theory.left_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1) R) (@category_theory.adjunction.monad.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 R _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  omit 𝒥</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  def has_limits_of_reflective (R : D ⥤ C) [reflective R] [has_limits.{v₁} C] : has_limits.{v₁} D :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.reflective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.has_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/adjunction.lean&#x27;, &#x27;line&#x27;: 62, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 416, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 416, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], Type (max u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor is *reflective*, or *a reflective inclusion*, if it is fully faithful and right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`C` has all (small) limits if it has limits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`C` has all (small) limits if it has limits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  { has_limits_of_shape := λ J 𝒥, by exactI</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝒥'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.small_category.{v₁} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
R : @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞,
_inst_1 : @category_theory.reflective.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 R,
_inst_2 : @category_theory.limits.has_limits.{v₁ u₁} C 𝒞,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J
⊢ @category_theory.limits.has_limits_of_shape.{v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113    { has_limit := λ F, monadic_creates_limits F R } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.monadic_creates_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {J : Type v₁} [𝒥 : category_theory.small_category.{v₁} J] (F : @category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 D 𝒟) (R : @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞) [_inst_1 : @category_theory.monadic_right_adjoint.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 R] [_inst_2 : @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ v₁ u₁ u₁} J 𝒥 D 𝒟 C 𝒞 F R)], @category_theory.limits.has_limit.{v₁ u₁} J 𝒥 D 𝒟 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
R : @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞,
_inst_1 : @category_theory.reflective.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 R,
_inst_2 : @category_theory.limits.has_limits.{v₁ u₁} C 𝒞,
J : Type v₁,
𝒥 : category_theory.small_category.{v₁} J
⊢ @category_theory.limits.has_limits_of_shape.{v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  local attribute [instance] has_limits_of_reflective</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.has_limits_of_reflective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 111, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] (R : @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞) [_inst_1 : @category_theory.reflective.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 R] [_inst_2 : @category_theory.limits.has_limits.{v₁ u₁} C 𝒞], @category_theory.limits.has_limits.{v₁ u₁} D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  include 𝒥</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  -- We verify that, even jumping through these monadic hoops,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  -- the limit is actually calculated in the obvious way:</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  example (R : D ⥤ C) [reflective R] [has_limits.{v₁} C] (F : J ⥤ D) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.reflective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/adjunction.lean&#x27;, &#x27;line&#x27;: 62, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 416, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], Type (max u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v₁) [_inst_1 : category_theory.category.{v₁ v₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor is *reflective*, or *a reflective inclusion*, if it is fully faithful and right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`C` has all (small) limits if it has limits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  limit F = (left_adjoint R).obj (limit (F ⋙ R)) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.left_adjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 435, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 435, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v₁} [_inst_1 : category_theory.small_category.{v₁} J] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F : @category_theory.functor.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_limit.{v₁ u₁} J _inst_1 C 𝒞 F], C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] (R : @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞) [_inst_1 : @category_theory.is_right_adjoint.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 R], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v₁} [_inst_1 : category_theory.small_category.{v₁} J] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F : @category_theory.functor.{v₁ v₁ v₁ u₁} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_limit.{v₁ u₁} J _inst_1 C 𝒞 F], C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ v₁ u₁} J 𝒥 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v₁} [𝒞 : category_theory.category.{v₁ v₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ v₁ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u₁} {a : α}, @eq.{u₁+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  end category_theory</code></pre>
</body>