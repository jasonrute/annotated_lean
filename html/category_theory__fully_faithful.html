<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2018 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import logic.function category_theory.isomorphism</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/function.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  universes v₁ v₂ v₃ u₁ u₂ u₃ -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  variables {C : Type u₁} [𝒞 : category.{v₁} C] {D : Type u₂} [𝒟 : category.{v₂} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='category_theory.category.{v₁ u₁} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='category_theory.category.{v₂ u₂} D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  include 𝒞 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  A functor `F : C ⥤ D` is full if for each `X Y : C`, `F.map` is surjective.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  In fact, we use a constructive definition, so the `full F` typeclass contains data,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  specifying a particular preimage of each `f : F.obj X ⟶ F.obj Y`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  class full (F : C ⥤ D) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  (preimage : ∀ {X Y : C} (f : (F.obj X) ⟶ (F.obj Y)), X ⟶ Y)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  (witness&#x27; : ∀ {X Y : C} (f : (F.obj X) ⟶ (F.obj Y)), F.map (preimage f) = f . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  restate_axiom full.witness&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  attribute [simp] full.witness</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.full.witness'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [c : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C} (f : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y (@category_theory.full.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F c X Y f)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  /-- A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.-/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  class faithful (F : C ⥤ D) : Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  (injectivity&#x27; : ∀ {X Y : C}, function.injective (@functor.map _ _ _ _ F X Y) . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  restate_axiom faithful.injectivity&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  namespace functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  lemma injectivity (F : C ⥤ D) [faithful F] {X Y : C} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    function.injective $ @functor.map _ _ _ _ F X Y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  faithful.injectivity F</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.faithful.injectivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [c : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @function.injective.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  /-- The specified preimage of a morphism under a full functor. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  def preimage (F : C ⥤ D) [full F] {X Y : C} (f : F.obj X ⟶ F.obj Y) : X ⟶ Y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.full'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C ⥤ D` is full if for each `X Y : C`, `F.map` is surjective.
In fact, we use a constructive definition, so the `full F` typeclass contains data,
specifying a particular preimage of each `f : F.obj X ⟶ F.obj Y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  full.preimage.{v₁ v₂} f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.full.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} [c : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  @[simp] lemma image_preimage (F : C ⥤ D) [full F] {X Y : C} (f : F.obj X ⟶ F.obj Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.full'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C ⥤ D` is full if for each `X Y : C`, `F.map` is surjective.
In fact, we use a constructive definition, so the `full F` typeclass contains data,
specifying a particular preimage of each `f : F.obj X ⟶ F.obj Y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42    F.map (preimage F f) = f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  by unfold preimage; obviously</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
X Y : C,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y
       (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 X Y f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  end functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  variables {F : C ⥤ D} [full F] [faithful F] {X Y Z : C}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.full'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C ⥤ D` is full if for each `X Y : C`, `F.map` is surjective.
In fact, we use a constructive definition, so the `full F` typeclass contains data,
specifying a particular preimage of each `f : F.obj X ⟶ F.obj Y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  @[simp] lemma preimage_id : F.preimage (𝟙 (F.obj X)) = 𝟙 X :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] (X : obj), @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  F.injectivity (by simp)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.injectivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @function.injective.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X X
       (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 X X
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X X
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  @[simp] lemma preimage_comp (f : F.obj X ⟶ F.obj Y) (g : F.obj Y ⟶ F.obj Z) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51    F.preimage (f ≫ g) = F.preimage f ≫ F.preimage g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  F.injectivity (by simp)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.injectivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @function.injective.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Z)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Z))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Z
       (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 X Z
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Z)
             f
             g)))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Z
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          Y
          Z
          (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 X Y f)
          (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  @[simp] lemma preimage_map (f : X ⟶ Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    F.preimage (F.map f) = f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  F.injectivity (by simp)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.injectivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @function.injective.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y
       (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 X Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  /-- If `F : C ⥤ D` is fully faithful, every isomorphism `F.obj X ≅ F.obj Y` has a preimage. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  def preimage_iso (f : (F.obj X) ≅ (F.obj Y)) : X ≅ Y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C], C → C → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C], C → C → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  { hom := F.preimage f.hom,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {X Y : C}, @category_theory.iso.{v₂ u₂} C _inst_1 X Y → @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    inv := F.preimage f.inv,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {X Y : C}, @category_theory.iso.{v₂ u₂} C _inst_1 X Y → @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61    hom_inv_id&#x27; := F.injectivity (by simp),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.injectivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @function.injective.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
X Y : C,
f :
  @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X X
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          Y
          X
          (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 X Y
             (@category_theory.iso.hom.{v₂ u₂} D 𝒟
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                f))
          (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 Y X
             (@category_theory.iso.inv.{v₂ u₂} D 𝒟
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                f))))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X X
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62    inv_hom_id&#x27; := F.injectivity (by simp), }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.injectivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @function.injective.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
X Y : C,
f :
  @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y Y
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          Y
          X
          Y
          (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 Y X
             (@category_theory.iso.inv.{v₂ u₂} D 𝒟
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                f))
          (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 X Y
             (@category_theory.iso.hom.{v₂ u₂} D 𝒟
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                f))))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y Y
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  @[simp] lemma preimage_iso_hom (f : (F.obj X) ≅ (F.obj Y)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C], C → C → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    (preimage_iso f).hom = F.preimage f.hom := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.preimage_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] [_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.iso.{v₁ u₁} C 𝒞 X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {X Y : C}, @category_theory.iso.{v₁ u₁} C _inst_1 X Y → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {X Y : C}, @category_theory.iso.{v₂ u₂} C _inst_1 X Y → @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v₁} {a : α}, @eq.{v₁+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='If `F : C ⥤ D` is fully faithful, every isomorphism `F.obj X ≅ F.obj Y` has a preimage.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  @[simp] lemma preimage_iso_inv (f : (F.obj X) ≅ (F.obj Y)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C], C → C → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67    (preimage_iso f).inv = F.preimage (f.inv) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.preimage_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] [_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.iso.{v₁ u₁} C 𝒞 X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {X Y : C}, @category_theory.iso.{v₁ u₁} C _inst_1 X Y → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {X Y : C}, @category_theory.iso.{v₂ u₂} C _inst_1 X Y → @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type v₁} {a : α}, @eq.{v₁+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='If `F : C ⥤ D` is fully faithful, every isomorphism `F.obj X ≅ F.obj Y` has a preimage.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  @[simp] lemma preimage_iso_map_iso (f : X ≅ Y) : preimage_iso (F.map_iso f) = f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.preimage_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 241, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C], C → C → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] [_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.iso.{v₁ u₁} C 𝒞 X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {X Y : C}, @category_theory.iso.{v₁ u₁} C 𝒞 X Y → @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{v₁ u₁} C 𝒞 X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{v₁ u₁} C 𝒞 X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='If `F : C ⥤ D` is fully faithful, every isomorphism `F.obj X ≅ F.obj Y` has a preimage.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  by tidy</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
X Y : C,
f : @category_theory.iso.{v₁ u₁} C 𝒞 X Y
⊢ @eq.{v₁+1} (@category_theory.iso.{v₁ u₁} C 𝒞 X Y)
    (@category_theory.preimage_iso.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 _inst_2 X Y
       (@category_theory.functor.map_iso.{v₁ u₁ u₂ v₂} C 𝒞 D 𝒟 F X Y f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
X Y : C,
f : @category_theory.iso.{v₁ u₁} C 𝒞 X Y
⊢ @eq.{v₁+1} (@category_theory.iso.{v₁ u₁} C 𝒞 X Y)
    (@category_theory.preimage_iso.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 _inst_2 X Y
       (@category_theory.functor.map_iso.{v₁ u₁ u₂ v₂} C 𝒞 D 𝒟 F X Y f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  variables (F)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  def is_iso_of_fully_faithful (f : X ⟶ Y) [is_iso (F.map f)] : is_iso f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)) X Y → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  { inv := F.preimage (inv (F.map f)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.is_iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C} (f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y) [c : @category_theory.is_iso.{v u} C 𝒞 X Y f], @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    hom_inv_id&#x27; := F.injectivity (by simp),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.injectivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @function.injective.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
_inst_3 :
  @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X X
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          Y
          X
          f
          (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 Y X
             (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)
                _inst_3))))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X X
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    inv_hom_id&#x27; := F.injectivity (by simp) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.injectivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @function.injective.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F,
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
_inst_3 :
  @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y Y
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          Y
          X
          Y
          (@category_theory.functor.preimage.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F _inst_1 Y X
             (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)
                _inst_3))
          f))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y Y
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  end category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  variables {C : Type u₁} [𝒞 : category.{v₁} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  include 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  instance full.id : full (𝟭 C) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='category_theory.full'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='A functor `F : C ⥤ D` is full if for each `X Y : C`, `F.map` is surjective.
In fact, we use a constructive definition, so the `full F` typeclass contains data,
specifying a particular preimage of each `f : F.obj X ⟶ F.obj Y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  { preimage := λ _ _ f, f }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) _x) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) _x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) _x) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) _x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  instance faithful.id : faithful (𝟭 C) := by obviously</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C
⊢ @category_theory.faithful.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  variables {D : Type u₂} [𝒟 : category.{v₂} D] {E : Type u₃} [ℰ : category.{v₃} E]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  include 𝒟 ℰ</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  variables (F : C ⥤ D) (G : D ⥤ E)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₃) [_inst_2 : category_theory.category.{v₃ u₃} D], Type (max v₂ v₃ u₂ u₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  instance faithful.comp [faithful F] [faithful G] : faithful (F ⋙ G) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  { injectivity&#x27; := λ _ _ _ _ p, F.injectivity (G.injectivity p) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.injectivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.injectivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) _x _x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) _x _x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) _x) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) _x_1)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) _x _x_1 _x_2) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) _x _x_1 _x_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @function.injective.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D] (F : @category_theory.functor.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟) [_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 F] {X Y : C}, @function.injective.{v₂+1 v₃+1} (@category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)) X Y) (@category_theory.has_hom.hom.{v₃ u₃} D (@category_theory.category_struct.to_has_hom.{v₃ u₃} D (@category_theory.category.to_category_struct.{v₃ u₃} D 𝒟)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 F Y)) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 F X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) _x) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) _x_1)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) _x _x_1 _x_2) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) _x _x_1 _x_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  lemma faithful.of_comp [faithful $ F ⋙ G] : faithful F :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  { injectivity&#x27; := λ X Y, (F ⋙ G).injectivity.of_comp }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.injectivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.injective.of_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/function.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D] (F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 D 𝒟) [_inst_1 : @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 D 𝒟 F] {X Y : C}, @function.injective.{v₁+1 v₃+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (@category_theory.has_hom.hom.{v₃ u₃} D (@category_theory.category_struct.to_has_hom.{v₃ u₃} D (@category_theory.category.to_category_struct.{v₃ u₃} D 𝒟)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 D 𝒟 F Y)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 D 𝒟 F X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₃} {f : α → β} {γ : Type v₁} {g : γ → α}, @function.injective.{v₁+1 v₃+1} γ β (@function.comp.{v₁+1 v₂+1 v₃+1} γ α β f g) → @function.injective.{v₁+1 v₂+1} γ α g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  variables {F G}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  lemma faithful.of_comp_eq {H : C ⥤ E} [ℋ : faithful H] (h : F ⋙ G = H) : faithful F :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₃) [_inst_2 : category_theory.category.{v₃ u₃} D], Type (max v₁ v₃ u₁ u₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max v₁ v₃ u₁ u₃)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  @faithful.of_comp _ _ _ _ _ _ F G (h.symm ▸ ℋ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.faithful.of_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ℋ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 96, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) [_inst_1 : @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G)], @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max v₁ v₃ u₁ u₃)} {a b : α}, @eq.{(max v₁ v₃ u₁ u₃)+1} α a b → @eq.{(max v₁ v₃ u₁ u₃)+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type (max v₁ v₃ u₁ u₃)} {P : α → Prop} {a b : α}, @eq.{(max v₁ v₃ u₁ u₃)+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  alias faithful.of_comp_eq ← eq.faithful_of_comp</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  variables (F G)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  /-- “Divide” a functor by a faithful functor. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  protected def faithful.div (F : C ⥤ E) (G : D ⥤ E) [faithful G]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₃) [_inst_2 : category_theory.category.{v₃ u₃} D], Type (max v₁ v₃ u₁ u₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₃) [_inst_2 : category_theory.category.{v₃ u₃} D], Type (max v₂ v₃ u₂ u₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    (obj : C → D) (h_obj : ∀ X, G.obj (obj X) = F.obj X)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [_inst_2 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₂ v₃ u₂ u₃} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u₃}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₃} [_inst_2 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₁ v₃ u₁ u₃} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    (map : Π {X Y}, (X ⟶ Y) → (obj X ⟶ obj Y))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    (h_map : ∀ {X Y} {f : X ⟶ Y}, G.map (map f) == F.map f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='heq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [_inst_2 : category_theory.category.{v₃ u₃} D] (c : @category_theory.functor.{v₂ v₃ u₂ u₃} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₃ u₃} D (@category_theory.category_struct.to_has_hom.{v₃ u₃} D (@category_theory.category.to_category_struct.{v₃ u₃} D _inst_2)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (obj X) (obj Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₃}, α → Π {β : Type v₃}, β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₃} [_inst_2 : category_theory.category.{v₃ u₃} D] (c : @category_theory.functor.{v₁ v₃ u₁ u₃} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₃ u₃} D (@category_theory.category_struct.to_has_hom.{v₃ u₃} D (@category_theory.category.to_category_struct.{v₃ u₃} D _inst_2)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113    C ⥤ D :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  { obj := obj,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    map := @map,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (obj X) (obj Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116    map_id&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
⊢ ∀ (X : C),
    @eq.{v₂+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (obj X)
         (obj X))
      (@map X X
         (@category_theory.category_struct.id.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            X))
      (@category_theory.category_struct.id.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (obj X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118      assume X,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
⊢ ∀ (X : C),
    @eq.{v₂+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (obj X)
         (obj X))
      (@map X X
         (@category_theory.category_struct.id.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            X))
      (@category_theory.category_struct.id.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (obj X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (obj X)
       (obj X))
    (@map X X
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (obj X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119      apply G.injectivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (obj X)
       (obj X))
    (@map X X
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (obj X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @eq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@map X X
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@category_theory.category_struct.id.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120      apply eq_of_heq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='eq_of_heq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 205, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₃} {a a&#x27; : α}, @heq.{v₃+1} α a α a&#x27; → @eq.{v₃+1} α a a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @eq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@map X X
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@category_theory.category_struct.id.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@map X X
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X)))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@category_theory.category_struct.id.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121      transitivity F.map (𝟙 X), from h_map,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {X Y : C} {f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y}, @heq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (map X Y f)) (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@map X X
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X)))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@category_theory.category_struct.id.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@map X X
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X)))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X))
    (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X X
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X))
    (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X X
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@category_theory.category_struct.id.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X))
    (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X X
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@category_theory.category_struct.id.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122      rw [F.map_id, G.map_id, h_obj X]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='h_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X : C), @eq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X X (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X)) (@category_theory.category_struct.id.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X : D), @eq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G X) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G X)) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G X X (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) X)) (@category_theory.category_struct.id.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X : C), @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X))
    (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X X
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@category_theory.category_struct.id.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X))
    (@category_theory.category_struct.id.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@category_theory.category_struct.id.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X))
    (@category_theory.category_struct.id.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.category_struct.id.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X))
    (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X X
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@category_theory.category_struct.id.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123    end,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X : C
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X))
    (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X X
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj X)
       (@category_theory.category_struct.id.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124    map_comp&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
⊢ ∀ {X Y Z : C}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y)
  (g :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Y
      Z),
    @eq.{v₂+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (obj X)
         (obj Z))
      (@map X Z
         (@category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            X
            Y
            Z
            f
            g))
      (@category_theory.category_struct.comp.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (obj X)
         (obj Y)
         (obj Z)
         (@map X Y f)
         (@map Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126      assume X Y Z f g,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
⊢ ∀ {X Y Z : C}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y)
  (g :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Y
      Z),
    @eq.{v₂+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (obj X)
         (obj Z))
      (@map X Z
         (@category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            X
            Y
            Z
            f
            g))
      (@category_theory.category_struct.comp.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (obj X)
         (obj Y)
         (obj Z)
         (@map X Y f)
         (@map Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (obj X)
       (obj Z))
    (@map X Z
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          Y
          Z
          f
          g))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (obj X)
       (obj Y)
       (obj Z)
       (@map X Y f)
       (@map Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127      apply G.injectivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (obj X)
       (obj Z))
    (@map X Z
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          Y
          Z
          f
          g))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (obj X)
       (obj Y)
       (obj Z)
       (@map X Y f)
       (@map Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @eq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z)
       (@map X Z
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             Y
             Z
             f
             g)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)
          (obj Y)
          (obj Z)
          (@map X Y f)
          (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128      apply eq_of_heq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='eq_of_heq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 205, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₃} {a a&#x27; : α}, @heq.{v₃+1} α a α a&#x27; → @eq.{v₃+1} α a a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @eq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z)
       (@map X Z
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             Y
             Z
             f
             g)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)
          (obj Y)
          (obj Z)
          (@map X Y f)
          (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z)
       (@map X Z
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             Y
             Z
             f
             g)))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)
          (obj Y)
          (obj Z)
          (@map X Y f)
          (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129      transitivity F.map (f ≫ g), from h_map,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {X Y : C} {f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y}, @heq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (map X Y f)) (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z)
       (@map X Z
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             Y
             Z
             f
             g)))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)
          (obj Y)
          (obj Z)
          (@map X Y f)
          (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z)
       (@map X Z
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             Y
             Z
             f
             g)))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z))
    (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Z
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          Y
          Z
          f
          g))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z))
    (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Z
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          Y
          Z
          f
          g))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)
          (obj Y)
          (obj Z)
          (@map X Y f)
          (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z))
    (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Z
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          Y
          Z
          f
          g))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)
          (obj Y)
          (obj Z)
          (@map X Y f)
          (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130      rw [F.map_comp, G.map_comp],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Z), @eq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Z (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X Y Z f g)) (@category_theory.category_struct.comp.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (obj X) (obj Y)) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (obj Y) (obj Z)), @eq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z))) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (obj X) (obj Y) (obj Z) f g)) (@category_theory.category_struct.comp.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) f) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y) (obj Z) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z))
    (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Z
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          Y
          Z
          f
          g))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)
          (obj Y)
          (obj Z)
          (@map X Y f)
          (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z))
    (@category_theory.category_struct.comp.{v₃ u₃} E
       (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y Z g))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Z)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (obj X)
          (obj Y)
          (obj Z)
          (@map X Y f)
          (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z))
    (@category_theory.category_struct.comp.{v₃ u₃} E
       (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y Z g))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.category_struct.comp.{v₃ u₃} E
       (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z))
       (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
       (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y) (obj Z) (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131      congr&#x27; 1;</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z))
    (@category_theory.category_struct.comp.{v₃ u₃} E
       (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y Z g))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.category_struct.comp.{v₃ u₃} E
       (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z))
       (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
       (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y) (obj Z) (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132        try { exact (h_obj _).symm };</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='h_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (X : C), @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z))
    (@category_theory.category_struct.comp.{v₃ u₃} E
       (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y Z g))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.category_struct.comp.{v₃ u₃} E
       (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z))
       (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
       (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y) (obj Z) (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @eq.{u₃+1} E (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
    (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z))
    (@category_theory.category_struct.comp.{v₃ u₃} E
       (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y Z g))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.category_struct.comp.{v₃ u₃} E
       (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z))
       (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
       (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y) (obj Z) (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133        exact h_map.symm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='h_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {X Y : C} {f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y}, @heq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (map X Y f)) (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z))
    (@category_theory.category_struct.comp.{v₃ u₃} E
       (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y Z g))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.category_struct.comp.{v₃ u₃} E
       (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z))
       (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
       (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y) (obj Z) (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134    end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Y
    Z
⊢ @heq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z))
    (@category_theory.category_struct.comp.{v₃ u₃} E
       (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Z)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
       (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y Z g))
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z)))
    (@category_theory.category_struct.comp.{v₃ u₃} E
       (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Z))
       (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
       (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y) (obj Z) (@map Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  lemma faithful.div_comp (F : C ⥤ E) [faithful F] (G : D ⥤ E) [faithful G]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₃) [_inst_2 : category_theory.category.{v₃ u₃} D], Type (max v₁ v₃ u₁ u₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₃) [_inst_2 : category_theory.category.{v₃ u₃} D], Type (max v₂ v₃ u₂ u₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137    (obj : C → D) (h_obj : ∀ X, G.obj (obj X) = F.obj X)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [_inst_2 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₂ v₃ u₂ u₃} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u₃}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₃} [_inst_2 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₁ v₃ u₁ u₃} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138    (map : Π {X Y}, (X ⟶ Y) → (obj X ⟶ obj Y))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139    (h_map : ∀ {X Y} {f : X ⟶ Y}, G.map (map f) == F.map f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='heq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [_inst_2 : category_theory.category.{v₃ u₃} D] (c : @category_theory.functor.{v₂ v₃ u₂ u₃} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₃ u₃} D (@category_theory.category_struct.to_has_hom.{v₃ u₃} D (@category_theory.category.to_category_struct.{v₃ u₃} D _inst_2)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (obj X) (obj Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₃}, α → Π {β : Type v₃}, β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₃} [_inst_2 : category_theory.category.{v₃ u₃} D] (c : @category_theory.functor.{v₁ v₃ u₁ u₃} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₃ u₃} D (@category_theory.category_struct.to_has_hom.{v₃ u₃} D (@category_theory.category.to_category_struct.{v₃ u₃} D _inst_2)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140    (faithful.div F G obj @h_obj @map @h_map) ⋙ G = F :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.faithful.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) [_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G] (obj : C → D), (∀ (X : C), @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)) → Π (map : Π {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (obj X) (obj Y)), (∀ {X Y : C} {f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y}, @heq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f)) (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)) → @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (X : C), @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (obj X) (obj Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {X Y : C} {f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y}, @heq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (map X Y f)) (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max v₁ v₃ u₁ u₃)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='“Divide” a functor by a faithful functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
_inst_1 : @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_2 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
⊢ @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ
       (@category_theory.faithful.div.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G _inst_2 obj h_obj map
          h_map)
       G)
    F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142    tactic.unfreeze_local_instances,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tactic.unfreeze_local_instances'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 537, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='By default, Lean only considers local instances in the header of declarations.
   This has two main benefits.
   1- Results produced by the type class resolution procedure can be easily cached.
   2- The set of local instances does not have to be recomputed.

   This approach has the following disadvantages:
   1- Frozen local instances cannot be reverted.
   2- Local instances defined inside of a declaration are not considered during type
      class resolution.

   This tactic resets the set of local instances. After executing this tactic,
   the set of local instances will be recomputed and the cache will be frequently
   reset. Note that, the cache is still used when executing a single tactic that
   may generate many type class resolution problems (e.g., `simp`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
_inst_1 : @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_2 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
⊢ @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ
       (@category_theory.faithful.div.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G _inst_2 obj h_obj map
          h_map)
       G)
    F'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143    cases F with F_obj _ _ _; cases G with G_obj _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ,
_inst_1 : @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F,
G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
_inst_2 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G,
obj : C → D,
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X),
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)
⊢ @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ
       (@category_theory.faithful.div.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G _inst_2 obj h_obj map
          h_map)
       G)
    F'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
F_obj : C → E,
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (F_obj X)
      (F_obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)
            (F_obj Y)
            (F_obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E
      (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
         X),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
         X
         Y
         f)
⊢ @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ
       (@category_theory.faithful.div.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
          _inst_2
          obj
          h_obj
          map
          h_map)
       (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;))
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144    unfold faithful.div functor.comp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
F_obj : C → E,
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (F_obj X)
      (F_obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)
            (F_obj Y)
            (F_obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E
      (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
         X),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
         X
         Y
         f)
⊢ @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ
       (@category_theory.faithful.div.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
          _inst_2
          obj
          h_obj
          map
          h_map)
       (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;))
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
F_obj : C → E,
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (F_obj X)
      (F_obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)
            (F_obj Y)
            (F_obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E
      (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
         X),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
         X
         Y
         f)
⊢ @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (λ (X : C),
          @category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               X))
       (λ (_x _x_1 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x
            _x_1),
          @category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x_1)
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x
               _x_1
               f))
       (@category_theory.functor.comp._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;))
       (@category_theory.functor.comp._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)))
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145    unfold_projs at h_obj,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1374, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_proj_config {to_dsimp_config := {md := tactic.transparency.instances, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic unfolds all structure projections.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold_projs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_proj_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
F_obj : C → E,
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (F_obj X)
      (F_obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)
            (F_obj Y)
            (F_obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
h_obj :
  ∀ (X : C),
    @eq.{u₃+1} E
      (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X))
      (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
         X),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
         X
         Y
         f)
⊢ @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (λ (X : C),
          @category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               X))
       (λ (_x _x_1 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x
            _x_1),
          @category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x_1)
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x
               _x_1
               f))
       (@category_theory.functor.comp._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;))
       (@category_theory.functor.comp._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)))
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
F_obj : C → E,
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (F_obj X)
      (F_obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)
            (F_obj Y)
            (F_obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
         X
         Y
         f),
h_obj : ∀ (X : C), @eq.{u₃+1} E (G_obj (obj X)) (F_obj X)
⊢ @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (λ (X : C),
          @category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               X))
       (λ (_x _x_1 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x
            _x_1),
          @category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x_1)
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x
               _x_1
               f))
       (@category_theory.functor.comp._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;))
       (@category_theory.functor.comp._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)))
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    have: F_obj = G_obj ∘ obj := (funext h_obj).symm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='F_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u₁ u₃)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='D → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u₁} {β : Type u₂} {φ : Type u₃}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u₁} {β : α → Type u₃} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{u₃+1} (β x) (f₁ x) (f₂ x)) → @eq.{(max (u₁+1) (u₃+1))} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X : C), @eq.{u₃+1} E (G_obj (obj X)) (F_obj X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
F_obj : C → E,
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (F_obj X)
      (F_obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)
            (F_obj Y)
            (F_obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
         X
         Y
         f),
h_obj : ∀ (X : C), @eq.{u₃+1} E (G_obj (obj X)) (F_obj X)
⊢ @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (λ (X : C),
          @category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               X))
       (λ (_x _x_1 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x
            _x_1),
          @category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x_1)
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x
               _x_1
               f))
       (@category_theory.functor.comp._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;))
       (@category_theory.functor.comp._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)))
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
F_obj : C → E,
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (F_obj X)
      (F_obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)
            (F_obj Y)
            (F_obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
         X
         Y
         f),
h_obj : ∀ (X : C), @eq.{u₃+1} E (G_obj (obj X)) (F_obj X),
this : @eq.{(max (u₁+1) (u₃+1))} (C → E) F_obj (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
⊢ @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (λ (X : C),
          @category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               X))
       (λ (_x _x_1 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x
            _x_1),
          @category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x_1)
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x
               _x_1
               f))
       (@category_theory.functor.comp._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;))
       (@category_theory.functor.comp._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)))
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147    subst this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u₁+1) (u₃+1))} (C → E) F_obj (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
F_obj : C → E,
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (F_obj X)
      (F_obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (F_obj X)
            (F_obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (F_obj X)
            (F_obj Y)
            (F_obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
         X
         Y
         f),
h_obj : ∀ (X : C), @eq.{u₃+1} E (G_obj (obj X)) (F_obj X),
this : @eq.{(max (u₁+1) (u₃+1))} (C → E) F_obj (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
⊢ @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (λ (X : C),
          @category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               X))
       (λ (_x _x_1 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x
            _x_1),
          @category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x_1)
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x
               _x_1
               f))
       (@category_theory.functor.comp._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;))
       (@category_theory.functor.comp._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)))
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F_obj F_map F_map_id&#x27; F_map_comp&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Y)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
       F_map
       F_map_id&#x27;
       F_map_comp&#x27;),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
               (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
               F_map
               F_map_id&#x27;
               F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
               (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
               F_map
               F_map_id&#x27;
               F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
            F_map
            F_map_id&#x27;
            F_map_comp&#x27;)
         X
         Y
         f),
h_obj : ∀ (X : C), @eq.{u₃+1} E (G_obj (obj X)) (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
⊢ @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (λ (X : C),
          @category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               X))
       (λ (_x _x_1 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x
            _x_1),
          @category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x_1)
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x
               _x_1
               f))
       (@category_theory.functor.comp._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;))
       (@category_theory.functor.comp._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)))
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
       F_map
       F_map_id&#x27;
       F_map_comp&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148    congr,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Y)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
       F_map
       F_map_id&#x27;
       F_map_comp&#x27;),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
               (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
               F_map
               F_map_id&#x27;
               F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
               (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
               F_map
               F_map_id&#x27;
               F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
            F_map
            F_map_id&#x27;
            F_map_comp&#x27;)
         X
         Y
         f),
h_obj : ∀ (X : C), @eq.{u₃+1} E (G_obj (obj X)) (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
⊢ @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (λ (X : C),
          @category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               X))
       (λ (_x _x_1 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x
            _x_1),
          @category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x_1)
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
               (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                  (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map)
                  (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                     (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                        (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                        F_map
                        F_map_id&#x27;
                        F_map_comp&#x27;)
                     (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                     _inst_2
                     obj
                     h_obj
                     map
                     h_map))
               _x
               _x_1
               f))
       (@category_theory.functor.comp._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;))
       (@category_theory.functor.comp._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)))
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
       F_map
       F_map_id&#x27;
       F_map_comp&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Y)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
       F_map
       F_map_id&#x27;
       F_map_comp&#x27;),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
               (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
               F_map
               F_map_id&#x27;
               F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
               (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
               F_map
               F_map_id&#x27;
               F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
            F_map
            F_map_id&#x27;
            F_map_comp&#x27;)
         X
         Y
         f),
h_obj : ∀ (X : C), @eq.{u₃+1} E (G_obj (obj X)) (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
⊢ @eq.{(max (u₁+1) (v₁+1) (v₃+1))}
    (Π {X Y : C},
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y →
       @category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         ((λ (X : C),
             @category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
               (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                  (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                     (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                        (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                           (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                           F_map
                           F_map_id&#x27;
                           F_map_comp&#x27;)
                        (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27;
                           G_map_comp&#x27;)
                        _inst_2
                        obj
                        h_obj
                        map
                        h_map)
                     (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                        (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                           (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                           F_map
                           F_map_id&#x27;
                           F_map_comp&#x27;)
                        (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27;
                           G_map_comp&#x27;)
                        _inst_2
                        obj
                        h_obj
                        map
                        h_map))
                  X))
            X)
         ((λ (X : C),
             @category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
               (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                  (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                     (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                        (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                           (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                           F_map
                           F_map_id&#x27;
                           F_map_comp&#x27;)
                        (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27;
                           G_map_comp&#x27;)
                        _inst_2
                        obj
                        h_obj
                        map
                        h_map)
                     (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                        (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                           (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                           F_map
                           F_map_id&#x27;
                           F_map_comp&#x27;)
                        (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27;
                           G_map_comp&#x27;)
                        _inst_2
                        obj
                        h_obj
                        map
                        h_map))
                  X))
            Y))
    (λ (_x _x_1 : C)
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         _x
         _x_1),
       @category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
               (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                  (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                     (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                     F_map
                     F_map_id&#x27;
                     F_map_comp&#x27;)
                  (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                  _inst_2
                  obj
                  h_obj
                  map
                  h_map)
               (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                  (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                     (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                     F_map
                     F_map_id&#x27;
                     F_map_comp&#x27;)
                  (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                  _inst_2
                  obj
                  h_obj
                  map
                  h_map))
            _x)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
               (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                  (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                     (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                     F_map
                     F_map_id&#x27;
                     F_map_comp&#x27;)
                  (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                  _inst_2
                  obj
                  h_obj
                  map
                  h_map)
               (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                  (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                     (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                     F_map
                     F_map_id&#x27;
                     F_map_comp&#x27;)
                  (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                  _inst_2
                  obj
                  h_obj
                  map
                  h_map))
            _x_1)
         (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
               (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                  (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                     (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                     F_map
                     F_map_id&#x27;
                     F_map_comp&#x27;)
                  (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                  _inst_2
                  obj
                  h_obj
                  map
                  h_map)
               (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                  (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                     (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                     F_map
                     F_map_id&#x27;
                     F_map_comp&#x27;)
                  (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                  _inst_2
                  obj
                  h_obj
                  map
                  h_map))
            _x
            _x_1
            f))
    F_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149    funext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Y)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
       F_map
       F_map_id&#x27;
       F_map_comp&#x27;),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
               (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
               F_map
               F_map_id&#x27;
               F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
               (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
               F_map
               F_map_id&#x27;
               F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
            F_map
            F_map_id&#x27;
            F_map_comp&#x27;)
         X
         Y
         f),
h_obj : ∀ (X : C), @eq.{u₃+1} E (G_obj (obj X)) (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
⊢ @eq.{(max (u₁+1) (v₁+1) (v₃+1))}
    (Π {X Y : C},
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y →
       @category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         ((λ (X : C),
             @category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
               (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                  (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                     (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                        (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                           (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                           F_map
                           F_map_id&#x27;
                           F_map_comp&#x27;)
                        (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27;
                           G_map_comp&#x27;)
                        _inst_2
                        obj
                        h_obj
                        map
                        h_map)
                     (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                        (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                           (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                           F_map
                           F_map_id&#x27;
                           F_map_comp&#x27;)
                        (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27;
                           G_map_comp&#x27;)
                        _inst_2
                        obj
                        h_obj
                        map
                        h_map))
                  X))
            X)
         ((λ (X : C),
             @category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
               (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                  (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                     (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                        (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                           (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                           F_map
                           F_map_id&#x27;
                           F_map_comp&#x27;)
                        (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27;
                           G_map_comp&#x27;)
                        _inst_2
                        obj
                        h_obj
                        map
                        h_map)
                     (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                        (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                           (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                           F_map
                           F_map_id&#x27;
                           F_map_comp&#x27;)
                        (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27;
                           G_map_comp&#x27;)
                        _inst_2
                        obj
                        h_obj
                        map
                        h_map))
                  X))
            Y))
    (λ (_x _x_1 : C)
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         _x
         _x_1),
       @category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
               (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                  (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                     (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                     F_map
                     F_map_id&#x27;
                     F_map_comp&#x27;)
                  (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                  _inst_2
                  obj
                  h_obj
                  map
                  h_map)
               (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                  (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                     (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                     F_map
                     F_map_id&#x27;
                     F_map_comp&#x27;)
                  (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                  _inst_2
                  obj
                  h_obj
                  map
                  h_map))
            _x)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
               (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                  (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                     (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                     F_map
                     F_map_id&#x27;
                     F_map_comp&#x27;)
                  (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                  _inst_2
                  obj
                  h_obj
                  map
                  h_map)
               (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                  (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                     (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                     F_map
                     F_map_id&#x27;
                     F_map_comp&#x27;)
                  (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                  _inst_2
                  obj
                  h_obj
                  map
                  h_map))
            _x_1)
         (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
               (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                  (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                     (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                     F_map
                     F_map_id&#x27;
                     F_map_comp&#x27;)
                  (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                  _inst_2
                  obj
                  h_obj
                  map
                  h_map)
               (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                  (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                     (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                     F_map
                     F_map_id&#x27;
                     F_map_comp&#x27;)
                  (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                  _inst_2
                  obj
                  h_obj
                  map
                  h_map))
            _x
            _x_1
            f))
    F_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Y)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
       F_map
       F_map_id&#x27;
       F_map_comp&#x27;),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
               (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
               F_map
               F_map_id&#x27;
               F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
               (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
               F_map
               F_map_id&#x27;
               F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
            F_map
            F_map_id&#x27;
            F_map_comp&#x27;)
         X
         Y
         f),
h_obj : ∀ (X : C), @eq.{u₃+1} E (G_obj (obj X)) (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X),
_x _x : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    _x
    _x
⊢ @eq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                   (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                      F_map
                      F_map_id&#x27;
                      F_map_comp&#x27;)
                   (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                   _inst_2
                   obj
                   h_obj
                   map
                   h_map)
                (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                   (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                      F_map
                      F_map_id&#x27;
                      F_map_comp&#x27;)
                   (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                   _inst_2
                   obj
                   h_obj
                   map
                   h_map))
             _x))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                   (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                      F_map
                      F_map_id&#x27;
                      F_map_comp&#x27;)
                   (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                   _inst_2
                   obj
                   h_obj
                   map
                   h_map)
                (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                   (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                      F_map
                      F_map_id&#x27;
                      F_map_comp&#x27;)
                   (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                   _inst_2
                   obj
                   h_obj
                   map
                   h_map))
             _x)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
       (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          _x)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          _x)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          _x
          _x
          f))
    (@F_map _x _x f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150    exact eq_of_heq h_map</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='eq_of_heq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 205, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₃} {a a&#x27; : α}, @heq.{v₃+1} α a α a&#x27; → @eq.{v₃+1} α a a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {X Y : C} {f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y}, @heq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;) (obj X)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;) (obj Y))) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;) (obj X) (obj Y) (map X Y f)) (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj) F_map F_map_id&#x27; F_map_comp&#x27;) X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj) F_map F_map_id&#x27; F_map_comp&#x27;) Y)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj) F_map F_map_id&#x27; F_map_comp&#x27;) X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
obj : C → D,
map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (obj X)
      (obj Y),
G_obj : D → E,
G_map :
  Π {X Y : D},
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (G_obj X)
      (G_obj Y),
G_map_id&#x27; :
  auto_param.{0}
    (∀ (X : D),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj X))
         (@G_map X X
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
G_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : D}
     (f :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (G_obj X)
            (G_obj Z))
         (@G_map X Z
            (@category_theory.category_struct.comp.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (G_obj X)
            (G_obj Y)
            (G_obj Z)
            (@G_map X Y f)
            (@G_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_2 :
  @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
    (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;),
F_map :
  Π {X Y : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y →
    @category_theory.has_hom.hom.{v₃ u₃} E
      (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
         (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Y),
F_map_id&#x27; :
  auto_param.{0}
    (∀ (X : C),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X))
         (@F_map X X
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X))
         (@category_theory.category_struct.id.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
F_map_comp&#x27; :
  auto_param.{0}
    (∀ {X Y Z : C}
     (f :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         Y)
     (g :
       @category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Y
         Z),
       @eq.{v₃+1}
         (@category_theory.has_hom.hom.{v₃ u₃} E
            (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
               (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Z))
         (@F_map X Z
            (@category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               X
               Y
               Z
               f
               g))
         (@category_theory.category_struct.comp.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Y)
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj Z)
            (@F_map X Y f)
            (@F_map Y Z g)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous),
_inst_1 :
  @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
    (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
       F_map
       F_map_id&#x27;
       F_map_comp&#x27;),
h_map :
  ∀ {X Y : C}
  {f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y},
    @heq.{v₃+1}
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj X))
         (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
            (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
            (obj Y)))
      (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
         (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
         (obj X)
         (obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{v₃ u₃} E
         (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
            (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
               (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
               F_map
               F_map_id&#x27;
               F_map_comp&#x27;)
            X)
         (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
               (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
               F_map
               F_map_id&#x27;
               F_map_comp&#x27;)
            Y))
      (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
         (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
            (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
            F_map
            F_map_id&#x27;
            F_map_comp&#x27;)
         X
         Y
         f),
h_obj : ∀ (X : C), @eq.{u₃+1} E (G_obj (obj X)) (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj X),
_x _x : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    _x
    _x
⊢ @eq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                   (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                      F_map
                      F_map_id&#x27;
                      F_map_comp&#x27;)
                   (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                   _inst_2
                   obj
                   h_obj
                   map
                   h_map)
                (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                   (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                      F_map
                      F_map_id&#x27;
                      F_map_comp&#x27;)
                   (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                   _inst_2
                   obj
                   h_obj
                   map
                   h_map))
             _x))
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
          (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
                (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                   (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                      F_map
                      F_map_id&#x27;
                      F_map_comp&#x27;)
                   (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                   _inst_2
                   obj
                   h_obj
                   map
                   h_map)
                (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                   (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                      (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                      F_map
                      F_map_id&#x27;
                      F_map_comp&#x27;)
                   (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                   _inst_2
                   obj
                   h_obj
                   map
                   h_map))
             _x)))
    (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ
       (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          _x)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          _x)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.mk.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 obj map
             (@category_theory.faithful.div._proof_1.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map)
             (@category_theory.faithful.div._proof_2.{u₁ u₂ u₃ v₁ v₂ v₃} C 𝒞 D 𝒟 E ℰ
                (@category_theory.functor.mk.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
                   (@function.comp.{u₁+1 u₂+1 u₃+1} C D E G_obj obj)
                   F_map
                   F_map_id&#x27;
                   F_map_comp&#x27;)
                (@category_theory.functor.mk.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G_obj G_map G_map_id&#x27; G_map_comp&#x27;)
                _inst_2
                obj
                h_obj
                map
                h_map))
          _x
          _x
          f))
    (@F_map _x _x f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  lemma faithful.div_faithful (F : C ⥤ E) [faithful F] (G : D ⥤ E) [faithful G]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₃) [_inst_2 : category_theory.category.{v₃ u₃} D], Type (max v₁ v₃ u₁ u₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₃) [_inst_2 : category_theory.category.{v₃ u₃} D], Type (max v₂ v₃ u₂ u₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154    (obj : C → D) (h_obj : ∀ X, G.obj (obj X) = F.obj X)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [_inst_2 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₂ v₃ u₂ u₃} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u₃}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₃} [_inst_2 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₁ v₃ u₁ u₃} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155    (map : Π {X Y}, (X ⟶ Y) → (obj X ⟶ obj Y))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    (h_map : ∀ {X Y} {f : X ⟶ Y}, G.map (map f) == F.map f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='heq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [_inst_2 : category_theory.category.{v₃ u₃} D] (c : @category_theory.functor.{v₂ v₃ u₂ u₃} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₃ u₃} D (@category_theory.category_struct.to_has_hom.{v₃ u₃} D (@category_theory.category.to_category_struct.{v₃ u₃} D _inst_2)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (obj X) (obj Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₃}, α → Π {β : Type v₃}, β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₃} [_inst_2 : category_theory.category.{v₃ u₃} D] (c : @category_theory.functor.{v₁ v₃ u₁ u₃} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₃ u₃} D (@category_theory.category_struct.to_has_hom.{v₃ u₃} D (@category_theory.category.to_category_struct.{v₃ u₃} D _inst_2)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    faithful (faithful.div F G obj @h_obj @map @h_map) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.faithful.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) [_inst_1 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G] (obj : C → D), (∀ (X : C), @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)) → Π (map : Π {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (obj X) (obj Y)), (∀ {X Y : C} {f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y}, @heq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f)) (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)) → @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (X : C), @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (obj X) (obj Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {X Y : C} {f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y}, @heq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (map X Y f)) (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='“Divide” a functor by a faithful functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  (faithful.div_comp F G _ h_obj _ @h_map).faithful_of_comp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.faithful.div_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.faithful_of_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) [_inst_1 : @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F] (G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) [_inst_2 : @category_theory.faithful.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G] (obj : C → D) (h_obj : ∀ (X : C), @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)) (map : Π {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (obj X) (obj Y)) (h_map : ∀ {X Y : C} {f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y}, @heq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (@map X Y f)) (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)), @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ (@category_theory.faithful.div.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G _inst_2 obj h_obj map h_map) G) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (X : C), @eq.{u₃+1} E (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {X Y : C} {f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y}, @heq.{v₃+1} (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj Y))) (@category_theory.functor.map.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ G (obj X) (obj Y) (map X Y f)) (@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F Y)) (@category_theory.functor.map.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ F X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ} {H : @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ} [ℋ : @category_theory.faithful.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ H], @eq.{(max v₁ v₃ u₁ u₃)+1} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) H → @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='**Alias** of `faithful.of_comp_eq`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  instance full.comp [full F] [full G] : full (F ⋙ G) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='category_theory.full'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.full'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.full'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 → Type (max u₂ v₂ v₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A functor `F : C ⥤ D` is full if for each `X Y : C`, `F.map` is surjective.
In fact, we use a constructive definition, so the `full F` typeclass contains data,
specifying a particular preimage of each `f : F.obj X ⟶ F.obj Y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor `F : C ⥤ D` is full if for each `X Y : C`, `F.map` is surjective.
In fact, we use a constructive definition, so the `full F` typeclass contains data,
specifying a particular preimage of each `f : F.obj X ⟶ F.obj Y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A functor `F : C ⥤ D` is full if for each `X Y : C`, `F.map` is surjective.
In fact, we use a constructive definition, so the `full F` typeclass contains data,
specifying a particular preimage of each `f : F.obj X ⟶ F.obj Y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  { preimage := λ _ _ f, F.preimage (G.preimage f) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) _x) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) _x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D] (F : @category_theory.functor.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.has_hom.hom.{v₃ u₃} D (@category_theory.category_struct.to_has_hom.{v₃ u₃} D (@category_theory.category.to_category_struct.{v₃ u₃} D 𝒟)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 F Y) → @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₃ u₃} E (@category_theory.category_struct.to_has_hom.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) _x) (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) _x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The specified preimage of a morphism under a full functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  end category_theory</code></pre>
</body>