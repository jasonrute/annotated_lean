<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Reid Barton. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Reid Barton</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import topology.category.Top.adjunctions</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/adjunctions.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.epi_mono</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/epi_mono.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  universe u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  open Top</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  namespace Top</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  lemma epi_iff_surjective {X Y : Top.{u}} (f : X ⟶ Y) : epi f ↔ function.surjective f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.epi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.surjective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 108, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 69, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Top.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u+1)} [c : category_theory.has_hom.{u u+1} obj], obj → obj → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Top.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} Top.{u} (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u} (@category_theory.category.to_category_struct.{u u+1} Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} Top.{u} (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u} (@category_theory.category.to_category_struct.{u u+1} Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@function.surjective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18    suffices : epi f ↔ epi ((forget Top).map f),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.epi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 108, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {X Y : C}, @category_theory.has_hom.hom.{u u+1} C (@category_theory.category_struct.to_has_hom.{u u+1} C (@category_theory.category.to_category_struct.{u u+1} C 𝒞)) X Y → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} Top.{u} (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u} (@category_theory.category.to_category_struct.{u u+1} Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The forgetful functor from a concrete category to `Type u`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@function.surjective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y,
this :
  iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
⊢ iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@function.surjective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))

X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19    { rw [this, category_theory.epi_iff_surjective], refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.epi_iff_surjective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='iff (@category_theory.epi.{u u+1} Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})) X Y f) (@category_theory.epi.{u u+1} (Type u) category_theory.types.{u} (@category_theory.functor.obj.{u u u+1 u+1} Top.{u} (@category_theory.concrete_category.to_category.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) (Type u) category_theory.types.{u} (@category_theory.forget.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) X) (@category_theory.functor.obj.{u u u+1 u+1} Top.{u} (@category_theory.concrete_category.to_category.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) (Type u) category_theory.types.{u} (@category_theory.forget.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) Y) (@category_theory.functor.map.{u u u+1 u+1} Top.{u} (@category_theory.concrete_category.to_category.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) (Type u) category_theory.types.{u} (@category_theory.forget.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {X Y : Type u} (f : @category_theory.has_hom.hom.{u u+1} (Type u) (@category_theory.category_struct.to_has_hom.{u u+1} (Type u) (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u})) X Y), iff (@category_theory.epi.{u u+1} (Type u) category_theory.types.{u} X Y f) (@function.surjective.{u+1 u+1} X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y,
this :
  iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
⊢ iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@function.surjective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))

X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y,
this :
  iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
⊢ iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@function.surjective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y,
this :
  iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
⊢ iff
    (@category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
    (@function.surjective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y,
this :
  iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
⊢ iff
    (@function.surjective.{u+1 u+1}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
    (@function.surjective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ iff
    (@category_theory.epi.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.epi.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f →
  @category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f)

X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f) →
  @category_theory.epi.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21    { apply left_adjoint_preserves_epi adj₂ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.left_adjoint_preserves_epi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Top.adj₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/epi_mono.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/adjunctions.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {F : @category_theory.functor.{u u u+1 u+1} C 𝒞 D 𝒟} {G : @category_theory.functor.{u u u+1 u+1} D 𝒟 C 𝒞}, @category_theory.adjunction.{u u u+1 u+1} C 𝒞 D 𝒟 F G → ∀ {X Y : C} {f : @category_theory.has_hom.hom.{u u+1} C (@category_theory.category_struct.to_has_hom.{u u+1} C (@category_theory.category.to_category_struct.{u u+1} C 𝒞)) X Y}, @category_theory.epi.{u u+1} C 𝒞 X Y f → @category_theory.epi.{u u+1} D 𝒟 (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 D 𝒟 F Y) (@category_theory.functor.map.{u u u+1 u+1} C 𝒞 D 𝒟 F X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.adjunction.{u u u+1 u+1} Top.{u} (@category_theory.concrete_category.to_category.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) (Type u) category_theory.types.{u} (@category_theory.forget.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) Top.trivial.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Equipping a type with the trivial topology is right adjoint to the forgetful functor `Top ⥤ Type`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.epi.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f →
  @category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f)

X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f) →
  @category_theory.epi.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.epi.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f →
  @category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f) →
  @category_theory.epi.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22    { apply faithful_reflects_epi }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.faithful_reflects_epi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/epi_mono.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] (F : @category_theory.functor.{u u u+1 u+1} C 𝒞 D 𝒟) [_inst_1 : @category_theory.faithful.{u u u+1 u+1} C 𝒞 D 𝒟 F] {X Y : C} {f : @category_theory.has_hom.hom.{u u+1} C (@category_theory.category_struct.to_has_hom.{u u+1} C (@category_theory.category.to_category_struct.{u u+1} C 𝒞)) X Y}, @category_theory.epi.{u u+1} D 𝒟 (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 D 𝒟 F Y) (@category_theory.functor.map.{u u u+1 u+1} C 𝒞 D 𝒟 F X Y f) → @category_theory.epi.{u u+1} C 𝒞 X Y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.epi.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f) →
  @category_theory.epi.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  lemma mono_iff_injective {X Y : Top.{u}} (f : X ⟶ Y) : mono f ↔ function.injective f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Top.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u+1)} [c : category_theory.has_hom.{u u+1} obj], obj → obj → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Top.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} Top.{u} (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u} (@category_theory.category.to_category_struct.{u u+1} Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} Top.{u} (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u} (@category_theory.category.to_category_struct.{u u+1} Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@function.injective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27    suffices : mono f ↔ mono ((forget Top).map f),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {X Y : C}, @category_theory.has_hom.hom.{u u+1} C (@category_theory.category_struct.to_has_hom.{u u+1} C (@category_theory.category.to_category_struct.{u u+1} C 𝒞)) X Y → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} Top.{u} (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u} (@category_theory.category.to_category_struct.{u u+1} Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The forgetful functor from a concrete category to `Type u`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@function.injective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y,
this :
  iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
⊢ iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@function.injective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))

X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28    { rw [this, category_theory.mono_iff_injective], refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.mono_iff_injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='iff (@category_theory.mono.{u u+1} Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})) X Y f) (@category_theory.mono.{u u+1} (Type u) category_theory.types.{u} (@category_theory.functor.obj.{u u u+1 u+1} Top.{u} (@category_theory.concrete_category.to_category.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) (Type u) category_theory.types.{u} (@category_theory.forget.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) X) (@category_theory.functor.obj.{u u u+1 u+1} Top.{u} (@category_theory.concrete_category.to_category.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) (Type u) category_theory.types.{u} (@category_theory.forget.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) Y) (@category_theory.functor.map.{u u u+1 u+1} Top.{u} (@category_theory.concrete_category.to_category.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) (Type u) category_theory.types.{u} (@category_theory.forget.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u}))) X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {X Y : Type u} (f : @category_theory.has_hom.hom.{u u+1} (Type u) (@category_theory.category_struct.to_has_hom.{u u+1} (Type u) (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u})) X Y), iff (@category_theory.mono.{u u+1} (Type u) category_theory.types.{u} X Y f) (@function.injective.{u+1 u+1} X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y,
this :
  iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
⊢ iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@function.injective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))

X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y,
this :
  iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
⊢ iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@function.injective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y,
this :
  iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
⊢ iff
    (@category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
    (@function.injective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y,
this :
  iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
⊢ iff
    (@function.injective.{u+1 u+1}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))
    (@function.injective.{u+1 u+1} (@category_theory.bundled.α.{u u} topological_space.{u} X)
       (@category_theory.bundled.α.{u u} topological_space.{u} Y)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} Top.{u}
             (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
                (@category_theory.category.to_category_struct.{u u+1} Top.{u}
                   (@category_theory.bundled_hom.category.{u} topological_space.{u}
                      (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                         @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                         continuous.{u u}
                         Top.concrete_category_continuous.{u}))))
             X
             Y)
          (Top.hom_has_coe_to_fun.{u} X Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ iff
    (@category_theory.mono.{u u+1} Top.{u}
       (@category_theory.bundled_hom.category.{u} topological_space.{u}
          (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
             @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
             Top.concrete_category_continuous.{u}))
       X
       Y
       f)
    (@category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X)
       (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          Y)
       (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
          (@category_theory.concrete_category.to_category.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          (Type u)
          category_theory.types.{u}
          (@category_theory.forget.{u} Top.{u}
             (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
                (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                   @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                   continuous.{u u}
                   Top.concrete_category_continuous.{u})))
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.mono.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f →
  @category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f)

X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f) →
  @category_theory.mono.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30    { apply right_adjoint_preserves_mono adj₁ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.right_adjoint_preserves_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Top.adj₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/epi_mono.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/adjunctions.lean&#x27;, &#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {F : @category_theory.functor.{u u u+1 u+1} C 𝒞 D 𝒟} {G : @category_theory.functor.{u u u+1 u+1} D 𝒟 C 𝒞}, @category_theory.adjunction.{u u u+1 u+1} C 𝒞 D 𝒟 F G → ∀ {X Y : D} {f : @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D 𝒟)) X Y}, @category_theory.mono.{u u+1} D 𝒟 X Y f → @category_theory.mono.{u u+1} C 𝒞 (@category_theory.functor.obj.{u u u+1 u+1} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{u u u+1 u+1} D 𝒟 C 𝒞 G Y) (@category_theory.functor.map.{u u u+1 u+1} D 𝒟 C 𝒞 G X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.adjunction.{u u u+1 u+1} (Type u) category_theory.types.{u} Top.{u} (@category_theory.bundled_hom.category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})) Top.discrete.{u} (@category_theory.forget.{u} Top.{u} (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u} (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β), @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u} Top.concrete_category_continuous.{u})))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Equipping a type with the discrete topology is left adjoint to the forgetful functor `Top ⥤ Type`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.mono.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f →
  @category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f)

X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f) →
  @category_theory.mono.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.mono.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f →
  @category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f) →
  @category_theory.mono.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31    { apply faithful_reflects_mono }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.faithful_reflects_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/epi_mono.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] (F : @category_theory.functor.{u u u+1 u+1} C 𝒞 D 𝒟) [_inst_1 : @category_theory.faithful.{u u u+1 u+1} C 𝒞 D 𝒟 F] {X Y : C} {f : @category_theory.has_hom.hom.{u u+1} C (@category_theory.category_struct.to_has_hom.{u u+1} C (@category_theory.category.to_category_struct.{u u+1} C 𝒞)) X Y}, @category_theory.mono.{u u+1} D 𝒟 (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 D 𝒟 F Y) (@category_theory.functor.map.{u u u+1 u+1} C 𝒞 D 𝒟 F X Y f) → @category_theory.mono.{u u+1} C 𝒞 X Y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X Y : Top.{u},
f :
  @category_theory.has_hom.hom.{u u+1} Top.{u}
    (@category_theory.category_struct.to_has_hom.{u u+1} Top.{u}
       (@category_theory.category.to_category_struct.{u u+1} Top.{u}
          (@category_theory.bundled_hom.category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u}))))
    X
    Y
⊢ @category_theory.mono.{u u+1} (Type u) category_theory.types.{u}
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X)
    (@category_theory.functor.obj.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       Y)
    (@category_theory.functor.map.{u u u+1 u+1} Top.{u}
       (@category_theory.concrete_category.to_category.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       (Type u)
       category_theory.types.{u}
       (@category_theory.forget.{u} Top.{u}
          (@category_theory.bundled_hom.category_theory.concrete_category.{u} topological_space.{u}
             (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
                @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α)
                continuous.{u u}
                Top.concrete_category_continuous.{u})))
       X
       Y
       f) →
  @category_theory.mono.{u u+1} Top.{u}
    (@category_theory.bundled_hom.category.{u} topological_space.{u}
       (λ (α β : Type u) (Iα : topological_space.{u} α) (Iβ : topological_space.{u} β),
          @subtype.{u+1} (α → β) (@continuous.{u u} α β Iα Iβ))
       (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), topological_space.{u} α) continuous.{u u}
          Top.concrete_category_continuous.{u}))
    X
    Y
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  end Top</code></pre>
</body>