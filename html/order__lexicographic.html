<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Author: Scott Morrison, Minchao Wu</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  Lexicographic preorder / partial_order / linear_order / decidable_linear_order,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  for pairs and dependent pairs.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import tactic.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  import algebra.order</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  def lex (α : Type u) (β : Type v) := α × β</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  variables {α : Type u} {β : Type v}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  instance [decidable_eq α] [decidable_eq β] : decidable_eq (lex α β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Sort u → Sort (max u 1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  prod.decidable_eq</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/prod.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [h₁ : decidable_eq.{u+1} α] [h₂ : decidable_eq.{v+1} β], decidable_eq.{(max (u+1) (v+1))} (prod.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  instance [inhabited α] [inhabited β] : inhabited (lex α β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  prod.inhabited</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/prod.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : inhabited.{u+1} α] [_inst_2 : inhabited.{v+1} β], inhabited.{(max (u+1) (v+1))} (prod.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  /-- Dictionary / lexicographic ordering on pairs.  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  instance lex_has_le [preorder α] [preorder β] : has_le (lex α β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  { le := prod.lex (&lt;) (≤) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='prod.lex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/wf.lean&#x27;, &#x27;line&#x27;: 160, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → α → Prop) → (β → β → Prop) → prod.{u v} α β → prod.{u v} α β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_lt.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v} [c : has_le.{v} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  instance lex_has_lt [preorder α] [preorder β] : has_lt (lex α β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  { lt := prod.lex (&lt;) (&lt;) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='prod.lex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/wf.lean&#x27;, &#x27;line&#x27;: 160, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → α → Prop) → (β → β → Prop) → prod.{u v} α β → prod.{u v} α β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_lt.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v} [c : has_lt.{v} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  /-- Dictionary / lexicographic preorder for pairs. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  instance lex_preorder [preorder α] [preorder β] : preorder (lex α β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  { le_refl := λ ⟨l, r⟩, by { right, apply le_refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='lex.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] (a : α), @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
_x : lex.{u v} α β,
_fun_match :
  ∀ (_a : lex.{u v} α β),
    @prod.lex.{u v} α β (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1))
      (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2))
      _a
      _a,
l : α,
r : β
⊢ @prod.lex.{u v} α β (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1))
    (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2))
    (@prod.mk.{u v} α β l r)
    (@prod.mk.{u v} α β l r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
_x : lex.{u v} α β,
_fun_match :
  ∀ (_a : lex.{u v} α β),
    @prod.lex.{u v} α β (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1))
      (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2))
      _a
      _a,
l : α,
r : β
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) r r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34    le_trans :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β
⊢ ∀ (a b c : lex.{u v} α β),
    @has_le.le.{(max u v)} (lex.{u v} α β)
      (@has_le.mk.{(max u v)} (lex.{u v} α β)
         (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
      a
      b →
    @has_le.le.{(max u v)} (lex.{u v} α β)
      (@has_le.mk.{(max u v)} (lex.{u v} α β)
         (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
      b
      c →
    @has_le.le.{(max u v)} (lex.{u v} α β)
      (@has_le.mk.{(max u v)} (lex.{u v} α β)
         (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
      a
      c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36      rintros ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ ⟨a₃, b₃⟩ ⟨h₁l, h₁r⟩ ⟨h₂l, h₂r⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β
⊢ ∀ (a b c : lex.{u v} α β),
    @has_le.le.{(max u v)} (lex.{u v} α β)
      (@has_le.mk.{(max u v)} (lex.{u v} α β)
         (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
      a
      b →
    @has_le.le.{(max u v)} (lex.{u v} α β)
      (@has_le.mk.{(max u v)} (lex.{u v} α β)
         (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
      b
      c →
    @has_le.le.{(max u v)} (lex.{u v} α β)
      (@has_le.mk.{(max u v)} (lex.{u v} α β)
         (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
      a
      c'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a₃ : α,
b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₃ b₃)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₂ b₂)
    (@prod.mk.{u v} α β a₂ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₃)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a₃ : α,
b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₃ b₃)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37      { left, apply lt_trans, repeat { assumption } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='lt_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b c : α}, @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a b → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) b c → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a₃ : α,
b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₃ b₃)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₂ b₂)
    (@prod.mk.{u v} α β a₂ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₃)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a₃ : α,
b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₃ b₃)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a₃ : α,
b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₃ b₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a₃ : α,
b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a₃ : α,
b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ ?m_1

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a₃ : α,
b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) ?m_1 a₃

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a₃ : α,
b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a₃ : α,
b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a₃ : α,
b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ ?m_1

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a₃ : α,
b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) ?m_1 a₃

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a₃ : α,
b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₂ b₂)
    (@prod.mk.{u v} α β a₂ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₃)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a₃ : α,
b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₃ b₃)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38      { left, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₂ b₂)
    (@prod.mk.{u v} α β a₂ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₃)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a₃ : α,
b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₃ b₃)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₂ b₂)
    (@prod.mk.{u v} α β a₂ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ b₃ : β,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₂ b₂)
    (@prod.mk.{u v} α β a₂ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a₃ : α,
b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₃ b₃)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39      { left, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a₃ : α,
b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₃ b₃)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a₃ : α,
b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₃ b₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a₃ : α,
b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40      { right, apply le_trans, repeat { assumption } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] {a b c : α}, @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a b → @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) b c → @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ ?m_1

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) ?m_1 b₃

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ ?m_1

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) ?m_1 b₃

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ b₃ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₃),
a_2_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₃
⊢ β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42    lt_iff_le_not_le :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β
⊢ ∀ (a b : lex.{u v} α β),
    iff
      (@has_lt.lt.{(max u v)} (lex.{u v} α β)
         (@has_lt.mk.{(max u v)} (lex.{u v} α β)
            (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
         a
         b)
      (and
         (@has_le.le.{(max u v)} (lex.{u v} α β)
            (@has_le.mk.{(max u v)} (lex.{u v} α β)
               (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
            a
            b)
         (not
            (@has_le.le.{(max u v)} (lex.{u v} α β)
               (@has_le.mk.{(max u v)} (lex.{u v} α β)
                  (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
               b
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44      rintros ⟨a₁, b₁⟩ ⟨a₂, b₂⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β
⊢ ∀ (a b : lex.{u v} α β),
    iff
      (@has_lt.lt.{(max u v)} (lex.{u v} α β)
         (@has_lt.mk.{(max u v)} (lex.{u v} α β)
            (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
         a
         b)
      (and
         (@has_le.le.{(max u v)} (lex.{u v} α β)
            (@has_le.mk.{(max u v)} (lex.{u v} α β)
               (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
            a
            b)
         (not
            (@has_le.le.{(max u v)} (lex.{u v} α β)
               (@has_le.mk.{(max u v)} (lex.{u v} α β)
                  (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
               b
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ iff
    (@has_lt.lt.{(max u v)} (lex.{u v} α β)
       (@has_lt.mk.{(max u v)} (lex.{u v} α β)
          (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (and
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂))
       (not
          (@has_le.le.{(max u v)} (lex.{u v} α β)
             (@has_le.mk.{(max u v)} (lex.{u v} α β)
                (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
             (@prod.mk.{u v} α β a₂ b₂)
             (@prod.mk.{u v} α β a₁ b₁))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45      split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ iff
    (@has_lt.lt.{(max u v)} (lex.{u v} α β)
       (@has_lt.mk.{(max u v)} (lex.{u v} α β)
          (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (and
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₁ b₁)
          (@prod.mk.{u v} α β a₂ b₂))
       (not
          (@has_le.le.{(max u v)} (lex.{u v} α β)
             (@has_le.mk.{(max u v)} (lex.{u v} α β)
                (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
             (@prod.mk.{u v} α β a₂ b₂)
             (@prod.mk.{u v} α β a₁ b₁))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂) →
  and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₂ b₂)
          (@prod.mk.{u v} α β a₁ b₁)))

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₂ b₂)
          (@prod.mk.{u v} α β a₁ b₁))) →
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46      { rintros (⟨_, _, _, _, hlt⟩ | ⟨_, _, _, hlt⟩),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂) →
  and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₂ b₂)
          (@prod.mk.{u v} α β a₁ b₁)))

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₂ b₂)
          (@prod.mk.{u v} α β a₁ b₁))) →
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂) →
  and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₂ b₂)
          (@prod.mk.{u v} α β a₁ b₁)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₂ b₂)
          (@prod.mk.{u v} α β a₁ b₁)))

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂
⊢ and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₁ b₂)
          (@prod.mk.{u v} α β a₁ b₁)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47       { split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₂ b₂)
          (@prod.mk.{u v} α β a₁ b₁)))

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂
⊢ and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₁ b₂)
          (@prod.mk.{u v} α β a₁ b₁)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₂ b₂)
          (@prod.mk.{u v} α β a₁ b₁)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48         { left, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49         { rintro ⟨l,r⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₁
⊢ false

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁,
a :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₁),
a_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50           { apply lt_asymm hlt, assumption },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='lt_asymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b : α}, @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a b → not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₁
⊢ false

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁,
a :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₁),
a_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₁
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁,
a :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₁),
a_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51           { apply lt_irrefl _ hlt } } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hlt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁,
a :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₁),
a_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂
⊢ and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₁ b₂)
          (@prod.mk.{u v} α β a₁ b₁)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52       { split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂
⊢ and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₁ b₂)
          (@prod.mk.{u v} α β a₁ b₁)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂
⊢ not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53         { right, rw lt_iff_le_not_le at hlt, exact hlt.1 },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='lt_iff_le_not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hlt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] {a b : α}, iff (@has_lt.lt.{v} α (@preorder.to_has_lt.{v} α _inst_1) a b) (and (@has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a b) (not (@has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂) (not (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂
⊢ not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt :
  and (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂)
    (not (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁))
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂
⊢ not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54         { rintro ⟨l,r⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂
⊢ not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁
⊢ false

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂,
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55           { apply lt_irrefl a₁, assumption },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁
⊢ false

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂,
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂,
a_1_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂,
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56           { rw lt_iff_le_not_le at hlt, apply hlt.2, assumption } } } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='lt_iff_le_not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hlt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] {a b : α}, iff (@has_lt.lt.{v} α (@preorder.to_has_lt.{v} α _inst_1) a b) (and (@has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a b) (not (@has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂) (not (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt : @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂,
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁,
hlt :
  and (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂)
    (not (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a :
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_1_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁,
hlt :
  and (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂)
    (not (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁))
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₂ b₂)
          (@prod.mk.{u v} α β a₁ b₁))) →
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57      { rintros ⟨⟨h₁ll, h₁lr⟩, h₂r⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ and
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (lex.{u v} α β)
          (@has_le.mk.{(max u v)} (lex.{u v} α β)
             (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
          (@prod.mk.{u v} α β a₂ b₂)
          (@prod.mk.{u v} α β a₁ b₁))) →
  @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂
⊢ @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58        { left, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂
⊢ @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂
⊢ @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59        { right, rw lt_iff_le_not_le, split,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='lt_iff_le_not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] {a b : α}, iff (@has_lt.lt.{v} α (@preorder.to_has_lt.{v} α _inst_1) a b) (and (@has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a b) (not (@has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂
⊢ @has_lt.lt.{(max u v)} (lex.{u v} α β)
    (@has_lt.mk.{(max u v)} (lex.{u v} α β)
       (@has_lt.lt.{(max u v)} (lex.{u v} α β) (@lex_has_lt.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂
⊢ @has_lt.lt.{v} β (@preorder.to_has_lt.{v} β _inst_2) b₁ b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂
⊢ and (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂)
    (not (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂
⊢ not (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60          { assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂

α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂
⊢ not (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂
⊢ not (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61          { intro h, apply h₂r, right, exact h } } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂
⊢ not (@has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : preorder.{u} α,
_inst_2 : preorder.{v} β,
a₁ : α,
b₁ b₂ : β,
a_left :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@has_le.mk.{(max u v)} (lex.{u v} α β)
       (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@has_le.mk.{(max u v)} (lex.{u v} α β)
          (@has_le.le.{(max u v)} (lex.{u v} α β) (@lex_has_le.{u v} α β _inst_1 _inst_2)))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁)),
a_left_h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₁ b₂,
h : @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁
⊢ @has_le.le.{v} β (@preorder.to_has_le.{v} β _inst_2) b₂ b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63    .. lex_has_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lex_has_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : preorder.{u} α] [_inst_2 : preorder.{v} β], has_le.{(max u v)} (lex.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Dictionary / lexicographic ordering on pairs.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64    .. lex_has_lt }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lex_has_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : preorder.{u} α] [_inst_2 : preorder.{v} β], has_lt.{(max u v)} (lex.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  /-- Dictionary / lexicographic partial_order for pairs. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  instance lex_partial_order [partial_order α] [partial_order β] : partial_order (lex α β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  { le_antisymm :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β
⊢ ∀ (a b : lex.{u v} α β),
    @has_le.le.{(max u v)} (lex.{u v} α β)
      (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
         (@preorder.mk.{(max u v)} (lex.{u v} α β)
            (@preorder.le.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.lt.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))))
      a
      b →
    @has_le.le.{(max u v)} (lex.{u v} α β)
      (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
         (@preorder.mk.{(max u v)} (lex.{u v} α β)
            (@preorder.le.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.lt.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))))
      b
      a →
    @eq.{(max u v)+1} (lex.{u v} α β) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70      rintros ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ (⟨_, _, _, _, hlt₁⟩ | ⟨_, _, _, hlt₁⟩) (⟨_, _, _, _, hlt₂⟩ | ⟨_, _, _, hlt₂⟩),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β
⊢ ∀ (a b : lex.{u v} α β),
    @has_le.le.{(max u v)} (lex.{u v} α β)
      (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
         (@preorder.mk.{(max u v)} (lex.{u v} α β)
            (@preorder.le.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.lt.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))))
      a
      b →
    @has_le.le.{(max u v)} (lex.{u v} α β)
      (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
         (@preorder.mk.{(max u v)} (lex.{u v} α β)
            (@preorder.le.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.lt.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))
            (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
               (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                  (@partial_order.to_preorder.{v} β _inst_2)))))
      b
      a →
    @eq.{(max u v)+1} (lex.{u v} α β) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₂ a₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₂ b₂)

α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₁),
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)

α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)

α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71      { exfalso, exact lt_irrefl a₁ (lt_trans hlt₁ hlt₂) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lt_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1026, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b c : α}, @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a b → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) b c → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₂ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Replaces the target of the main goal by `false`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exfalso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₂ a₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₂ b₂)

α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₁),
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)

α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)

α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₂ a₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₂ a₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₁),
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)

α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)

α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72      { exfalso, exact lt_irrefl a₁ hlt₁ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1026, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Replaces the target of the main goal by `false`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exfalso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₁),
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)

α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)

α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₁),
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_2 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₁),
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)

α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73      { exfalso, exact lt_irrefl a₁ hlt₂ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1026, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Replaces the target of the main goal by `false`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exfalso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)

α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74      { have := le_antisymm hlt₁ hlt₂, simp [this] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : partial_order.{v} α] {a b : α}, @has_le.le.{v} α (@preorder.to_has_le.{v} α (@partial_order.to_preorder.{v} α _inst_1)) a b → @has_le.le.{v} α (@preorder.to_has_le.{v} α (@partial_order.to_preorder.{v} α _inst_1)) b a → @eq.{v+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β b₁ b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : partial_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_1 :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@preorder.mk.{(max u v)} (lex.{u v} α β)
          (@preorder.le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_refl.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.le_trans.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))
          (@preorder.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
             (@lex_preorder.{u v} α β (@partial_order.to_preorder.{u} α _inst_1)
                (@partial_order.to_preorder.{v} β _inst_2)))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
hlt₁ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₁ b₂,
hlt₂ : @has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β _inst_2)) b₂ b₁,
this : @eq.{v+1} β b₁ b₂
⊢ @eq.{(max u v)+1} (lex.{u v} α β) (@prod.mk.{u v} α β a₁ b₁) (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    .. lex_preorder }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lex_preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : preorder.{u} α] [_inst_2 : preorder.{v} β], preorder.{(max u v)} (lex.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Dictionary / lexicographic preorder for pairs.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  /-- Dictionary / lexicographic linear_order for pairs. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  instance lex_linear_order [linear_order α] [linear_order β] : linear_order (lex α β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  { le_total :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β
⊢ ∀ (a b : lex.{u v} α β),
    or
      (@has_le.le.{(max u v)} (lex.{u v} α β)
         (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
            (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
               (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                  (@partial_order.le.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2))))))
         a
         b)
      (@has_le.le.{(max u v)} (lex.{u v} α β)
         (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
            (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
               (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                  (@partial_order.le.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2))))))
         b
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82      rintros ⟨a₁, b₁⟩ ⟨a₂, b₂⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β
⊢ ∀ (a b : lex.{u v} α β),
    or
      (@has_le.le.{(max u v)} (lex.{u v} α β)
         (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
            (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
               (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                  (@partial_order.le.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2))))))
         a
         b)
      (@has_le.le.{(max u v)} (lex.{u v} α β)
         (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
            (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
               (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                  (@partial_order.le.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2)))
                  (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                     (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                        (@linear_order.to_partial_order.{v} β _inst_2))))))
         b
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83      rcases le_total a₁ a₂ with ha | ha;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='le_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : linear_order.{u} α] (a b : α), or (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) a b) (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84        cases lt_or_eq_of_le ha with a_lt a_eq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='lt_or_eq_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : partial_order.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b → or (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b) (@eq.{u+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
case or.inl
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inl
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85      -- Deal with the two goals with a₁ ≠ a₂</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
case or.inl
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inl
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86      { left, left, exact a_lt },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='a_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
case or.inl
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inl
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
          (@partial_order.mk.{(max u v)} (lex.{u v} α β)
             (@partial_order.le.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2))))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inl
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87      swap,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='opt_param.{1} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Move goal `n` to the front.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;nat?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inl
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inl
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88      { right, left, exact a_lt },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='a_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) a₂ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inl
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
          (@partial_order.mk.{(max u v)} (lex.{u v} α β)
             (@partial_order.le.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2))))))
    (@prod.mk.{u v} α β a₂ b₂)
    (@prod.mk.{u v} α β a₁ b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89      -- Now deal with the two goals with a₁ = a₂</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90      all_goals { subst a_eq, rcases le_total b₁ b₂ with hb | hb },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='a_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : linear_order.{v} α] (a b : α), or (@has_le.le.{v} α (@preorder.to_has_le.{v} α (@partial_order.to_preorder.{v} α (@linear_order.to_partial_order.{v} α _inst_1))) a b) (@has_le.le.{v} α (@preorder.to_has_le.{v} α (@partial_order.to_preorder.{v} α (@linear_order.to_partial_order.{v} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))

α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91      { left, right, exact hb },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2))) b₁ b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))

α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
          (@partial_order.mk.{(max u v)} (lex.{u v} α β)
             (@partial_order.le.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2))))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))

α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92      { right, right, exact hb },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2))) b₂ b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))

α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))

α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₁ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₁ b₂)
       (@prod.mk.{u v} α β a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
          (@partial_order.mk.{(max u v)} (lex.{u v} α β)
             (@partial_order.le.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2))))))
    (@prod.mk.{u v} α β a₁ b₂)
    (@prod.mk.{u v} α β a₁ b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))

α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93      { left, right, exact hb },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2))) b₁ b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))

α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
          (@partial_order.mk.{(max u v)} (lex.{u v} α β)
             (@partial_order.le.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2))))))
    (@prod.mk.{u v} α β a₂ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂
⊢ @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₁
    b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94      { right, right, exact hb },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} β (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2))) b₂ b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@partial_order.mk.{(max u v)} (lex.{u v} α β)
                (@partial_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2)))
                (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                      (@linear_order.to_partial_order.{v} β _inst_2))))))
       (@prod.mk.{u v} α β a₂ b₂)
       (@prod.mk.{u v} α β a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
          (@partial_order.mk.{(max u v)} (lex.{u v} α β)
             (@partial_order.le.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.lt.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_refl.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_trans.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2)))
             (@partial_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                (@lex_partial_order.{u v} α β (@linear_order.to_partial_order.{u} α _inst_1)
                   (@linear_order.to_partial_order.{v} β _inst_2))))))
    (@prod.mk.{u v} α β a₂ b₂)
    (@prod.mk.{u v} α β a₂ b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : linear_order.{v} β,
b₁ : β,
a₂ : α,
b₂ : β,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁
⊢ @has_le.le.{v} β
    (@preorder.to_has_le.{v} β (@partial_order.to_preorder.{v} β (@linear_order.to_partial_order.{v} β _inst_2)))
    b₂
    b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96    .. lex_partial_order }.</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lex_partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 67, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : partial_order.{u} α] [_inst_2 : partial_order.{v} β], partial_order.{(max u v)} (lex.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Dictionary / lexicographic partial_order for pairs.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  /-- Dictionary / lexicographic decidable_linear_order for pairs. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  instance lex_decidable_linear_order [decidable_linear_order α] [decidable_linear_order β] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='decidable_linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    decidable_linear_order (lex α β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='decidable_linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  { decidable_le :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β
⊢ @decidable_rel.{(max u v)+1} (lex.{u v} α β)
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103      rintros ⟨a₁, b₁⟩ ⟨a₂, b₂⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β
⊢ @decidable_rel.{(max u v)+1} (lex.{u v} α β)
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104      rcases decidable_linear_order.decidable_le α a₁ a₂ with a_lt | a_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='decidable_linear_order.decidable_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [c : decidable_linear_order.{u} α], @decidable_rel.{u+1} α (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α c) (@decidable_linear_order.lt.{u} α c) (@decidable_linear_order.le_refl.{u} α c) (@decidable_linear_order.le_trans.{u} α c) (@decidable_linear_order.lt_iff_le_not_le.{u} α c) (@decidable_linear_order.le_antisymm.{u} α c) (@decidable_linear_order.le_total.{u} α c))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  not
    (@has_le.le.{u} α
       (@preorder.to_has_le.{u} α
          (@partial_order.to_preorder.{u} α
             (@linear_order.to_partial_order.{u} α
                (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                   (@decidable_linear_order.lt.{u} α _inst_1)
                   (@decidable_linear_order.le_refl.{u} α _inst_1)
                   (@decidable_linear_order.le_trans.{u} α _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                   (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                   (@decidable_linear_order.le_total.{u} α _inst_1)))))
       a₁
       a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105      { -- a₂ &lt; a₁</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  not
    (@has_le.le.{u} α
       (@preorder.to_has_le.{u} α
          (@partial_order.to_preorder.{u} α
             (@linear_order.to_partial_order.{u} α
                (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                   (@decidable_linear_order.lt.{u} α _inst_1)
                   (@decidable_linear_order.le_refl.{u} α _inst_1)
                   (@decidable_linear_order.le_trans.{u} α _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                   (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                   (@decidable_linear_order.le_total.{u} α _inst_1)))))
       a₁
       a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  not
    (@has_le.le.{u} α
       (@preorder.to_has_le.{u} α
          (@partial_order.to_preorder.{u} α
             (@linear_order.to_partial_order.{u} α
                (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                   (@decidable_linear_order.lt.{u} α _inst_1)
                   (@decidable_linear_order.le_refl.{u} α _inst_1)
                   (@decidable_linear_order.le_trans.{u} α _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                   (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                   (@decidable_linear_order.le_total.{u} α _inst_1)))))
       a₁
       a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106        left, rw not_le at a_lt, rintro ⟨l, r⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : linear_order.{u} α] {a b : α}, iff (not (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) a b)) (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  not
    (@has_le.le.{u} α
       (@preorder.to_has_le.{u} α
          (@partial_order.to_preorder.{u} α
             (@linear_order.to_partial_order.{u} α
                (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                   (@decidable_linear_order.lt.{u} α _inst_1)
                   (@decidable_linear_order.le_refl.{u} α _inst_1)
                   (@decidable_linear_order.le_trans.{u} α _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                   (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                   (@decidable_linear_order.le_total.{u} α _inst_1)))))
       a₁
       a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  not
    (@has_le.le.{u} α
       (@preorder.to_has_le.{u} α
          (@partial_order.to_preorder.{u} α
             (@linear_order.to_partial_order.{u} α
                (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                   (@decidable_linear_order.lt.{u} α _inst_1)
                   (@decidable_linear_order.le_refl.{u} α _inst_1)
                   (@decidable_linear_order.le_trans.{u} α _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                   (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                   (@decidable_linear_order.le_total.{u} α _inst_1)))))
       a₁
       a₂)
⊢ not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁
⊢ not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ false

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁,
a :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
          (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
             (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                (@linear_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107        { apply lt_irrefl a₂, apply lt_trans, repeat { assumption } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lt_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b c : α}, @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a b → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) b c → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ false

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁,
a :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
          (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
             (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                (@linear_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    ?m_1

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    ?m_1
    a₂

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    ?m_1

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    ?m_1
    a₂

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁,
a :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
          (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
             (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                (@linear_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108        { apply lt_irrefl a₁, assumption } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁,
a :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
          (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
             (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                (@linear_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ b₂ : β,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁,
a :
  @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
          (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
             (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                (@linear_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₁ b₂),
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109      { -- a₁ ≤ a₂</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110        by_cases h : a₁ = a₂,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111        { rw h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112          rcases decidable_linear_order.decidable_le _ b₁ b₂ with b_lt | b_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='decidable_linear_order.decidable_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type v) [c : decidable_linear_order.{v} α], @decidable_rel.{v+1} α (@has_le.le.{v} α (@preorder.to_has_le.{v} α (@partial_order.to_preorder.{v} α (@linear_order.to_partial_order.{v} α (@linear_order.mk.{v} α (@decidable_linear_order.le.{v} α c) (@decidable_linear_order.lt.{v} α c) (@decidable_linear_order.le_refl.{v} α c) (@decidable_linear_order.le_trans.{v} α c) (@decidable_linear_order.lt_iff_le_not_le.{v} α c) (@decidable_linear_order.le_antisymm.{v} α c) (@decidable_linear_order.le_total.{v} α c))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  not
    (@has_le.le.{v} β
       (@preorder.to_has_le.{v} β
          (@partial_order.to_preorder.{v} β
             (@linear_order.to_partial_order.{v} β
                (@linear_order.mk.{v} β (@decidable_linear_order.le.{v} β _inst_2)
                   (@decidable_linear_order.lt.{v} β _inst_2)
                   (@decidable_linear_order.le_refl.{v} β _inst_2)
                   (@decidable_linear_order.le_trans.{v} β _inst_2)
                   (@decidable_linear_order.lt_iff_le_not_le.{v} β _inst_2)
                   (@decidable_linear_order.le_antisymm.{v} β _inst_2)
                   (@decidable_linear_order.le_total.{v} β _inst_2)))))
       b₁
       b₂)
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_le :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β
             (@linear_order.mk.{v} β (@decidable_linear_order.le.{v} β _inst_2)
                (@decidable_linear_order.lt.{v} β _inst_2)
                (@decidable_linear_order.le_refl.{v} β _inst_2)
                (@decidable_linear_order.le_trans.{v} β _inst_2)
                (@decidable_linear_order.lt_iff_le_not_le.{v} β _inst_2)
                (@decidable_linear_order.le_antisymm.{v} β _inst_2)
                (@decidable_linear_order.le_total.{v} β _inst_2)))))
    b₁
    b₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113          { -- b₂ &lt; b₁</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  not
    (@has_le.le.{v} β
       (@preorder.to_has_le.{v} β
          (@partial_order.to_preorder.{v} β
             (@linear_order.to_partial_order.{v} β
                (@linear_order.mk.{v} β (@decidable_linear_order.le.{v} β _inst_2)
                   (@decidable_linear_order.lt.{v} β _inst_2)
                   (@decidable_linear_order.le_refl.{v} β _inst_2)
                   (@decidable_linear_order.le_trans.{v} β _inst_2)
                   (@decidable_linear_order.lt_iff_le_not_le.{v} β _inst_2)
                   (@decidable_linear_order.le_antisymm.{v} β _inst_2)
                   (@decidable_linear_order.le_total.{v} β _inst_2)))))
       b₁
       b₂)
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_le :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β
             (@linear_order.mk.{v} β (@decidable_linear_order.le.{v} β _inst_2)
                (@decidable_linear_order.lt.{v} β _inst_2)
                (@decidable_linear_order.le_refl.{v} β _inst_2)
                (@decidable_linear_order.le_trans.{v} β _inst_2)
                (@decidable_linear_order.lt_iff_le_not_le.{v} β _inst_2)
                (@decidable_linear_order.le_antisymm.{v} β _inst_2)
                (@decidable_linear_order.le_total.{v} β _inst_2)))))
    b₁
    b₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  not
    (@has_le.le.{v} β
       (@preorder.to_has_le.{v} β
          (@partial_order.to_preorder.{v} β
             (@linear_order.to_partial_order.{v} β
                (@linear_order.mk.{v} β (@decidable_linear_order.le.{v} β _inst_2)
                   (@decidable_linear_order.lt.{v} β _inst_2)
                   (@decidable_linear_order.le_refl.{v} β _inst_2)
                   (@decidable_linear_order.le_trans.{v} β _inst_2)
                   (@decidable_linear_order.lt_iff_le_not_le.{v} β _inst_2)
                   (@decidable_linear_order.le_antisymm.{v} β _inst_2)
                   (@decidable_linear_order.le_total.{v} β _inst_2)))))
       b₁
       b₂)
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114            left, rw not_le at b_lt, rintro ⟨l, r⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : linear_order.{v} α] {a b : α}, iff (not (@has_le.le.{v} α (@preorder.to_has_le.{v} α (@partial_order.to_preorder.{v} α (@linear_order.to_partial_order.{v} α _inst_1))) a b)) (@has_lt.lt.{v} α (@preorder.to_has_lt.{v} α (@partial_order.to_preorder.{v} α (@linear_order.to_partial_order.{v} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  not
    (@has_le.le.{v} β
       (@preorder.to_has_le.{v} β
          (@partial_order.to_preorder.{v} β
             (@linear_order.to_partial_order.{v} β
                (@linear_order.mk.{v} β (@decidable_linear_order.le.{v} β _inst_2)
                   (@decidable_linear_order.lt.{v} β _inst_2)
                   (@decidable_linear_order.le_refl.{v} β _inst_2)
                   (@decidable_linear_order.le_trans.{v} β _inst_2)
                   (@decidable_linear_order.lt_iff_le_not_le.{v} β _inst_2)
                   (@decidable_linear_order.le_antisymm.{v} β _inst_2)
                   (@decidable_linear_order.le_total.{v} β _inst_2)))))
       b₁
       b₂)
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  not
    (@has_le.le.{v} β
       (@preorder.to_has_le.{v} β
          (@partial_order.to_preorder.{v} β
             (@linear_order.to_partial_order.{v} β
                (@linear_order.mk.{v} β (@decidable_linear_order.le.{v} β _inst_2)
                   (@decidable_linear_order.lt.{v} β _inst_2)
                   (@decidable_linear_order.le_refl.{v} β _inst_2)
                   (@decidable_linear_order.le_trans.{v} β _inst_2)
                   (@decidable_linear_order.lt_iff_le_not_le.{v} β _inst_2)
                   (@decidable_linear_order.le_antisymm.{v} β _inst_2)
                   (@decidable_linear_order.le_total.{v} β _inst_2)))))
       b₁
       b₂)
⊢ not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁
⊢ not
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₂
⊢ false

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115            { apply lt_irrefl a₂, assumption },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₂
⊢ false

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116            { apply lt_irrefl b₂, apply lt_of_lt_of_le, repeat { assumption } } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lt_of_lt_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] (a : α), not (@has_lt.lt.{v} α (@preorder.to_has_lt.{v} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] {a b c : α}, @has_lt.lt.{v} α (@preorder.to_has_lt.{v} α _inst_1) a b → @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) b c → @has_lt.lt.{v} α (@preorder.to_has_lt.{v} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    ?m_1

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    ?m_1
    b₂

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    ?m_1

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    ?m_1
    b₂

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_lt :
  @has_lt.lt.{v} β
    (@preorder.to_has_lt.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₂
    b₁,
a_h :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂
⊢ β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_le :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β
             (@linear_order.mk.{v} β (@decidable_linear_order.le.{v} β _inst_2)
                (@decidable_linear_order.lt.{v} β _inst_2)
                (@decidable_linear_order.le_refl.{v} β _inst_2)
                (@decidable_linear_order.le_trans.{v} β _inst_2)
                (@decidable_linear_order.lt_iff_le_not_le.{v} β _inst_2)
                (@decidable_linear_order.le_antisymm.{v} β _inst_2)
                (@decidable_linear_order.le_total.{v} β _inst_2)))))
    b₁
    b₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117            -- b₁ ≤ b₂</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_le :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β
             (@linear_order.mk.{v} β (@decidable_linear_order.le.{v} β _inst_2)
                (@decidable_linear_order.lt.{v} β _inst_2)
                (@decidable_linear_order.le_refl.{v} β _inst_2)
                (@decidable_linear_order.le_trans.{v} β _inst_2)
                (@decidable_linear_order.lt_iff_le_not_le.{v} β _inst_2)
                (@decidable_linear_order.le_antisymm.{v} β _inst_2)
                (@decidable_linear_order.le_total.{v} β _inst_2)))))
    b₁
    b₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118           { right, right, assumption } },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_le :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β
             (@linear_order.mk.{v} β (@decidable_linear_order.le.{v} β _inst_2)
                (@decidable_linear_order.lt.{v} β _inst_2)
                (@decidable_linear_order.le_refl.{v} β _inst_2)
                (@decidable_linear_order.le_trans.{v} β _inst_2)
                (@decidable_linear_order.lt_iff_le_not_le.{v} β _inst_2)
                (@decidable_linear_order.le_antisymm.{v} β _inst_2)
                (@decidable_linear_order.le_total.{v} β _inst_2)))))
    b₁
    b₂
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₂ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_le :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β
             (@linear_order.mk.{v} β (@decidable_linear_order.le.{v} β _inst_2)
                (@decidable_linear_order.lt.{v} β _inst_2)
                (@decidable_linear_order.le_refl.{v} β _inst_2)
                (@decidable_linear_order.le_trans.{v} β _inst_2)
                (@decidable_linear_order.lt_iff_le_not_le.{v} β _inst_2)
                (@decidable_linear_order.le_antisymm.{v} β _inst_2)
                (@decidable_linear_order.le_total.{v} β _inst_2)))))
    b₁
    b₂
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
          (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
             (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                (@linear_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
    (@prod.mk.{u v} α β a₂ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂,
b_le :
  @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β
             (@linear_order.mk.{v} β (@decidable_linear_order.le.{v} β _inst_2)
                (@decidable_linear_order.lt.{v} β _inst_2)
                (@decidable_linear_order.le_refl.{v} β _inst_2)
                (@decidable_linear_order.le_trans.{v} β _inst_2)
                (@decidable_linear_order.lt_iff_le_not_le.{v} β _inst_2)
                (@decidable_linear_order.le_antisymm.{v} β _inst_2)
                (@decidable_linear_order.le_total.{v} β _inst_2)))))
    b₁
    b₂
⊢ @has_le.le.{v} β
    (@preorder.to_has_le.{v} β
       (@partial_order.to_preorder.{v} β
          (@linear_order.to_partial_order.{v} β (@decidable_linear_order.to_linear_order.{v} β _inst_2))))
    b₁
    b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119        -- a₁ &lt; a₂</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120        { right, left, apply lt_of_le_of_ne, repeat { assumption } } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='lt_of_le_of_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : partial_order.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b → @ne.{u+1} α a b → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (lex.{u v} α β)
       (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
          (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
             (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
                (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                   (@linear_order.le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                   (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                      (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
       (@prod.mk.{u v} α β a₁ b₁)
       (@prod.mk.{u v} α β a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @has_le.le.{(max u v)} (lex.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (lex.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (lex.{u v} α β)
          (@linear_order.to_partial_order.{(max u v)} (lex.{u v} α β)
             (@linear_order.mk.{(max u v)} (lex.{u v} α β)
                (@linear_order.le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_refl.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_trans.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_antisymm.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))
                (@linear_order.le_total.{(max u v)} (lex.{u v} α β)
                   (@lex_linear_order.{u v} α β (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (@decidable_linear_order.to_linear_order.{v} β _inst_2)))))))
    (@prod.mk.{u v} α β a₁ b₁)
    (@prod.mk.{u v} α β a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @ne.{u+1} α a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂

α : Type u,
β : Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : decidable_linear_order.{v} β,
a₁ : α,
b₁ : β,
a₂ : α,
b₂ : β,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @ne.{u+1} α a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122    .. lex_linear_order }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lex_linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 79, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : linear_order.{u} α] [_inst_2 : linear_order.{v} β], linear_order.{(max u v)} (lex.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Dictionary / lexicographic linear_order for pairs.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  variables {Z : α → Type v}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  Dictionary / lexicographic ordering on dependent pairs.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  The &#x27;pointwise&#x27; partial order `prod.has_le` doesn&#x27;t make</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  sense for dependent pairs, so it&#x27;s safe to mark these as</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  instances here.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  instance dlex_has_le [preorder α] [∀ a, preorder (Z a)] : has_le (Σ&#x27; a, Z a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='psigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='psigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  { le := psigma.lex (&lt;) (λ a, (≤)) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='psigma.lex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/sigma/lex.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Sort u} {β : α → Sort v}, (α → α → Prop) → (Π (a : α), β a → β a → Prop) → @psigma.{u v} α β → @psigma.{u v} α β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_lt.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_le.{v} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  instance dlex_has_lt [preorder α] [∀ a, preorder (Z a)] : has_lt (Σ&#x27; a, Z a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='psigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='psigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  { lt := psigma.lex (&lt;) (λ a, (&lt;)) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='psigma.lex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/sigma/lex.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Sort u} {β : α → Sort v}, (α → α → Prop) → (Π (a : α), β a → β a → Prop) → @psigma.{u v} α β → @psigma.{u v} α β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_lt.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_lt.{v} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  /-- Dictionary / lexicographic preorder on dependent pairs. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  instance dlex_preorder [preorder α] [∀ a, preorder (Z a)] : preorder (Σ&#x27; a, Z a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='psigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='psigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  { le_refl := λ ⟨l, r⟩, by { right, apply le_refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@psigma.{u+1 v+1} α (λ (a : α), Z a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] (a : α), @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
_x : @psigma.{u+1 v+1} α (λ (a : α), Z a),
_fun_match :
  ∀ (_a : @psigma.{u+1 v+1} α (λ (a : α), Z a)),
    @psigma.lex.{u+1 v+1} α (λ (a : α), (λ (a : α), Z a) a)
      (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1))
      (λ (a : α), @has_le.le.{v} ((λ (a : α), Z a) a) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a) (_inst_2 a)))
      _a
      _a,
l : α,
r : Z l
⊢ @psigma.lex.{u+1 v+1} α (λ (a : α), (λ (a : α), Z a) a)
    (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1))
    (λ (a : α), @has_le.le.{v} ((λ (a : α), Z a) a) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a) (_inst_2 a)))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) l r)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) l r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
_x : @psigma.{u+1 v+1} α (λ (a : α), Z a),
_fun_match :
  ∀ (_a : @psigma.{u+1 v+1} α (λ (a : α), Z a)),
    @psigma.lex.{u+1 v+1} α (λ (a : α), (λ (a : α), Z a) a)
      (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1))
      (λ (a : α), @has_le.le.{v} ((λ (a : α), Z a) a) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a) (_inst_2 a)))
      _a
      _a,
l : α,
r : Z l
⊢ @has_le.le.{v} ((λ (a : α), Z a) l) (@preorder.to_has_le.{v} ((λ (a : α), Z a) l) (_inst_2 l)) r r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141    le_trans :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a)
⊢ ∀ (a b c : @psigma.{u+1 v+1} α (λ (a : α), Z a)),
    @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
      (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
      a
      b →
    @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
      (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
      b
      c →
    @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
      (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
      a
      c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143      rintros ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ ⟨a₃, b₃⟩ ⟨h₁l, h₁r⟩ ⟨h₂l, h₂r⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a)
⊢ ∀ (a b c : @psigma.{u+1 v+1} α (λ (a : α), Z a)),
    @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
      (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
      a
      b →
    @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
      (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
      b
      c →
    @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
      (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
      a
      c'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a₃ : α,
b₃ : Z a₃,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₃ b₃)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_b₂ : Z a₂,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₂)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₂) ((λ (a : α), _inst_2 a) a₂))
    b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ a_2_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ a_2_b₂)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₃ : α,
b₃ : Z a₃,
a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₃ b₃)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144      { left, apply lt_trans, repeat { assumption } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='lt_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b c : α}, @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a b → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) b c → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a₃ : α,
b₃ : Z a₃,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₃ b₃)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_b₂ : Z a₂,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₂)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₂) ((λ (a : α), _inst_2 a) a₂))
    b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ a_2_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ a_2_b₂)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₃ : α,
b₃ : Z a₃,
a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₃ b₃)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a₃ : α,
b₃ : Z a₃,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₃ b₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a₃ : α,
b₃ : Z a₃,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a₃ : α,
b₃ : Z a₃,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ ?m_1

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a₃ : α,
b₃ : Z a₃,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) ?m_1 a₃

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a₃ : α,
b₃ : Z a₃,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a₃ : α,
b₃ : Z a₃,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a₃ : α,
b₃ : Z a₃,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ ?m_1

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a₃ : α,
b₃ : Z a₃,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) ?m_1 a₃

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a₃ : α,
b₃ : Z a₃,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₃
⊢ α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_b₂ : Z a₂,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₂)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₂) ((λ (a : α), _inst_2 a) a₂))
    b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ a_2_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ a_2_b₂)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₃ : α,
b₃ : Z a₃,
a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₃ b₃)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145      { left, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_b₂ : Z a₂,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₂)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₂) ((λ (a : α), _inst_2 a) a₂))
    b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ a_2_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ a_2_b₂)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₃ : α,
b₃ : Z a₃,
a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₃ b₃)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_b₂ : Z a₂,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₂)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₂) ((λ (a : α), _inst_2 a) a₂))
    b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ a_2_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ a_2_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_2_b₂ : Z a₂,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₂)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₂) ((λ (a : α), _inst_2 a) a₂))
    b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ a_2_b₂)
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₃ : α,
b₃ : Z a₃,
a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₃ b₃)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146      { left, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₃ : α,
b₃ : Z a₃,
a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₃ b₃)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₃ : α,
b₃ : Z a₃,
a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₃ b₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₃ : α,
b₃ : Z a₃,
a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147      { right, apply le_trans, repeat { assumption } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] {a b c : α}, @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a b → @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) b c → @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_2_b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) b₁
    ?m_1

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) ?m_1
    a_2_b₂

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ (λ (a : α), Z a) a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) b₁
    ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) b₁
    ?m_1

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ @has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) ?m_1
    a_2_b₂

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
a_2_b₂ : Z a₁,
a_2_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_1_b₂
    a_2_b₂,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_2_b₂)
⊢ (λ (a : α), Z a) a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149    lt_iff_le_not_le :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a)
⊢ ∀ (a b : @psigma.{u+1 v+1} α (λ (a : α), Z a)),
    iff
      (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
         a
         b)
      (and
         (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                  (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
            a
            b)
         (not
            (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                  (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
               b
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151      rintros ⟨a₁, b₁⟩ ⟨a₂, b₂⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a)
⊢ ∀ (a b : @psigma.{u+1 v+1} α (λ (a : α), Z a)),
    iff
      (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
         a
         b)
      (and
         (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                  (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
            a
            b)
         (not
            (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                  (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
               b
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ iff
    (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (and
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
       (not
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
             (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
             (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152      split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ iff
    (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (and
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
       (not
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
             (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
             (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂) →
  and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)))

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))) →
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153      { rintros (⟨_, _, _, _, hlt⟩ | ⟨_, _, _, hlt⟩),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂) →
  and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)))

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))) →
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂) →
  and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)))

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154       { split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)))

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155         { left, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156         { rintro ⟨l,r⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₁
⊢ false

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁,
a :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁),
a_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₂
    b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157           { apply lt_asymm hlt, assumption },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='lt_asymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b : α}, @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a b → not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₁
⊢ false

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁,
a :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁),
a_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₂
    b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂,
a_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₁
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₂ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁,
a :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁),
a_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₂
    b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158           { apply lt_irrefl _ hlt } } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hlt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
hlt : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁,
a :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁),
a_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₂
    b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159       { split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160         { right, rw lt_iff_le_not_le at hlt, exact hlt.1 },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='lt_iff_le_not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hlt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] {a b : α}, iff (@has_lt.lt.{v} α (@preorder.to_has_lt.{v} α _inst_1) a b) (and (@has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a b) (not (@has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) b₁ a_b₂) (not (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) a_b₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂),
hlt :
  and
    (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) b₁
       a_b₂)
    (not
       (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁))
          a_b₂
          b₁))
⊢ @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161         { rintro ⟨l,r⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂),
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁
⊢ false

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂),
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_b₂
    b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162           { apply lt_irrefl a₁, assumption },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂),
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁
⊢ false

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂),
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_b₂
    b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂),
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂),
a_1_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂),
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_b₂
    b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163           { rw lt_iff_le_not_le at hlt, apply hlt.2, assumption } } } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='lt_iff_le_not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hlt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] {a b : α}, iff (@has_lt.lt.{v} α (@preorder.to_has_lt.{v} α _inst_1) a b) (and (@has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a b) (not (@has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) b₁ a_b₂) (not (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) a_b₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
hlt :
  @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_b₂,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂),
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_b₂
    b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂),
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_b₂
    b₁,
hlt :
  and
    (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) b₁
       a_b₂)
    (not
       (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁))
          a_b₂
          b₁))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
a :
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂),
a_1_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_b₂
    b₁,
hlt :
  and
    (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) b₁
       a_b₂)
    (not
       (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁))
          a_b₂
          b₁))
⊢ @has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) a_b₂
    b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))) →
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164      { rintros ⟨⟨h₁ll, h₁lr⟩, h₂r⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ and
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (not
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
          (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))) →
  @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)),
a_left_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))
⊢ @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165        { left, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)),
a_left_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))
⊢ @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)),
a_left_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)),
a_left_a : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂
⊢ @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))
⊢ @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166        { right, rw lt_iff_le_not_le, split,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='lt_iff_le_not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] {a b : α}, iff (@has_lt.lt.{v} α (@preorder.to_has_lt.{v} α _inst_1) a b) (and (@has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a b) (not (@has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))
⊢ @has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_lt.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_lt.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_lt.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))
⊢ @has_lt.lt.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_lt.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))
⊢ and
    (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) b₁
       a_left_b₂)
    (not
       (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁))
          a_left_b₂
          b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))
⊢ @has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) b₁
    a_left_b₂

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))
⊢ not
    (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁))
       a_left_b₂
       b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167          { assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))
⊢ @has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) b₁
    a_left_b₂

α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))
⊢ not
    (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁))
       a_left_b₂
       b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))
⊢ @has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) b₁
    a_left_b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))
⊢ not
    (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁))
       a_left_b₂
       b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168          { intro h, apply h₂r, right, exact h } } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁)) a_left_b₂ b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))
⊢ not
    (@has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁))
       a_left_b₂
       b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)),
h :
  @has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁))
    a_left_b₂
    b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)),
h :
  @has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁))
    a_left_b₂
    b₁
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : preorder.{u} α,
_inst_2 : Π (a : α), preorder.{v} (Z a),
a₁ : α,
b₁ a_left_b₂ : Z a₁,
a_left_a_1 :
  @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    b₁
    a_left_b₂,
a_left :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂),
h₂r :
  not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@has_le.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_has_le.{u v} α (λ (a : α), Z a) _inst_1 (λ (a : α), _inst_2 a))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_left_b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)),
h :
  @has_le.le.{v} ((λ (a : α), Z a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) (_inst_2 a₁))
    a_left_b₂
    b₁
⊢ @has_le.le.{v} ((λ (a : α), Z a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), Z a) a₁) ((λ (a : α), _inst_2 a) a₁))
    a_left_b₂
    b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170    .. dlex_has_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='dlex_has_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {Z : α → Type v} [_inst_1 : preorder.{u} α] [_inst_2 : Π (a : α), preorder.{v} (Z a)], has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Dictionary / lexicographic ordering on dependent pairs.

The &#x27;pointwise&#x27; partial order `prod.has_le` doesn&#x27;t make
sense for dependent pairs, so it&#x27;s safe to mark these as
instances here.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    .. dlex_has_lt }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='dlex_has_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {Z : α → Type v} [_inst_1 : preorder.{u} α] [_inst_2 : Π (a : α), preorder.{v} (Z a)], has_lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  /-- Dictionary / lexicographic partial_order for dependent pairs. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  instance dlex_partial_order [partial_order α] [∀ a, partial_order (Z a)] : partial_order (Σ&#x27; a, Z a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='psigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='psigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  { le_antisymm :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a)
⊢ ∀ (a b : @psigma.{u+1 v+1} α (λ (a : α), Z a)),
    @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
      (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
      a
      b →
    @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
      (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
      b
      a →
    @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177      rintros ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ (⟨_, _, _, _, hlt₁⟩ | ⟨_, _, _, hlt₁⟩) (⟨_, _, _, _, hlt₂⟩ | ⟨_, _, _, hlt₂⟩),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a)
⊢ ∀ (a b : @psigma.{u+1 v+1} α (λ (a : α), Z a)),
    @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
      (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
      a
      b →
    @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
      (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
            (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                  (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
      b
      a →
    @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₂ a₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)

α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁),
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁,
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₂
    b₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)

α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)

α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    a_1_b₂
    b₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178      { exfalso, exact lt_irrefl a₁ (lt_trans hlt₁ hlt₂) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lt_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1026, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b c : α}, @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a b → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) b c → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₂ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Replaces the target of the main goal by `false`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exfalso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₂ a₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)

α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁),
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁,
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₂
    b₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)

α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)

α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    a_1_b₂
    b₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₂ a₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₂,
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₂ a₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁),
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁,
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₂
    b₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)

α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)

α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    a_1_b₂
    b₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179      { exfalso, exact lt_irrefl a₁ hlt₁ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1026, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Replaces the target of the main goal by `false`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exfalso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁),
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁,
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₂
    b₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)

α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)

α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    a_1_b₂
    b₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁),
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁,
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₂
    b₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_2 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁),
hlt₁ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁,
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₂
    b₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)

α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    a_1_b₂
    b₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180      { exfalso, exact lt_irrefl a₁ hlt₂ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1026, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Replaces the target of the main goal by `false`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exfalso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)

α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    a_1_b₂
    b₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ : @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a₁ a₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    a_1_b₂
    b₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181      { have := le_antisymm hlt₁ hlt₂, simp [this] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : partial_order.{v} α] {a b : α}, @has_le.le.{v} α (@preorder.to_has_le.{v} α (@partial_order.to_preorder.{v} α _inst_1)) a b → @has_le.le.{v} α (@preorder.to_has_le.{v} α (@partial_order.to_preorder.{v} α _inst_1)) b a → @eq.{v+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁) ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁)) b₁ a_1_b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁) (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁) ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁)) a_1_b₂ b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} ((λ (a : α), (λ (a : α), Z a) a) a₁) b₁ a_1_b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    a_1_b₂
    b₁
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : partial_order.{u} α,
_inst_2 : Π (a : α), partial_order.{v} (Z a),
a₁ : α,
b₁ a_1_b₂ : Z a₁,
hlt₁ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    b₁
    a_1_b₂,
a_1 :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@preorder.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))
          (@preorder.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@dlex_preorder.{u v} α (λ (a : α), Z a) (@partial_order.to_preorder.{u} α _inst_1)
                (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂),
hlt₂ :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), Z a) a) a₁)
       ((λ (a : α), (λ (a : α), @partial_order.to_preorder.{v} (Z a) (_inst_2 a)) a) a₁))
    a_1_b₂
    b₁,
this : @eq.{v+1} ((λ (a : α), (λ (a : α), Z a) a) a₁) b₁ a_1_b₂
⊢ @eq.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a)) (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_1_b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182    end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183    .. dlex_preorder }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='dlex_preorder'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {Z : α → Type v} [_inst_1 : preorder.{u} α] [_inst_2 : Π (a : α), preorder.{v} (Z a)], preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Dictionary / lexicographic preorder on dependent pairs.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  /-- Dictionary / lexicographic linear_order for pairs. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  instance dlex_linear_order [linear_order α] [∀ a, linear_order (Z a)] : linear_order (Σ&#x27; a, Z a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='psigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='psigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  { le_total :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a)
⊢ ∀ (a b : @psigma.{u+1 v+1} α (λ (a : α), Z a)),
    or
      (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                  (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
         a
         b)
      (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                  (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
         b
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189      rintros ⟨a₁, b₁⟩ ⟨a₂, b₂⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a)
⊢ ∀ (a b : @psigma.{u+1 v+1} α (λ (a : α), Z a)),
    or
      (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                  (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
         a
         b)
      (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
         (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
            (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
               (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                  (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                  (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                     (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                        (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
         b
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190      rcases le_total a₁ a₂ with ha | ha;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='le_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : linear_order.{u} α] (a b : α), or (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) a b) (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191        cases lt_or_eq_of_le ha with a_lt a_eq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='lt_or_eq_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : partial_order.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b → or (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b) (@eq.{u+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
case or.inl
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inl
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192      -- Deal with the two goals with a₁ ≠ a₂</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
case or.inl
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inl
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193      { left, left, exact a_lt },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='a_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
case or.inl
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inl
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inl
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194      swap,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='opt_param.{1} nat (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Move goal `n` to the front.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;nat?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inl
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inl
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195      { right, left, exact a_lt },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='a_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) a₂ a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inl
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196      -- Now deal with the two goals with a₁ = a₂</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197      all_goals { subst a_eq, rcases le_total b₁ b₂ with hb | hb },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='a_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : linear_order.{v} α] (a b : α), or (@has_le.le.{v} α (@preorder.to_has_le.{v} α (@partial_order.to_preorder.{v} α (@linear_order.to_partial_order.{v} α _inst_1))) a b) (@has_le.le.{v} α (@preorder.to_has_le.{v} α (@partial_order.to_preorder.{v} α (@linear_order.to_partial_order.{v} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₁,
a_eq : @eq.{u+1} α a₂ a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₂,
a_eq : @eq.{u+1} α a₁ a₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))

α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198      { left, right, exact hb },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} (Z a₁) (@preorder.to_has_le.{v} (Z a₁) (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁)))) b₁ b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))

α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₁
    b₂
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₁
    b₂
⊢ @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), Z a) a)
                ((λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)) a))
             a)
          a₁))
    b₁
    b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))

α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199      { right, right, exact hb },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} (Z a₁) (@preorder.to_has_le.{v} (Z a₁) (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁)))) b₂ b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))

α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))

α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₂
    b₁
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₁
    a₁,
hb :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁) (@linear_order.to_partial_order.{v} (Z a₁) (_inst_2 a₁))))
    b₂
    b₁
⊢ @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), Z a) a)
                ((λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)) a))
             a)
          a₁))
    b₂
    b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))

α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200      { left, right, exact hb },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} (Z a₂) (@preorder.to_has_le.{v} (Z a₂) (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂)))) b₁ b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))

α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₁
    b₂
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₁
    b₂
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₁
    b₂
⊢ @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a₂)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a₂)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), Z a) a)
                ((λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)) a))
             a)
          a₂))
    b₁
    b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201      { right, right, exact hb },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{v} (Z a₂) (@preorder.to_has_le.{v} (Z a₂) (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂)))) b₂ b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₂
    b₁
⊢ or
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
                (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                      (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₂
    b₁
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@partial_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a))))
             (@partial_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@dlex_partial_order.{u v} α (λ (a : α), Z a) (@linear_order.to_partial_order.{u} α _inst_1)
                   (λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : linear_order.{u} α,
_inst_2 : Π (a : α), linear_order.{v} (Z a),
a₂ : α,
b₂ b₁ : Z a₂,
ha :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1)))
    a₂
    a₂,
hb :
  @has_le.le.{v} (Z a₂)
    (@preorder.to_has_le.{v} (Z a₂)
       (@partial_order.to_preorder.{v} (Z a₂) (@linear_order.to_partial_order.{v} (Z a₂) (_inst_2 a₂))))
    b₂
    b₁
⊢ @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a₂)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a₂)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), Z a) a)
                ((λ (a : α), @linear_order.to_partial_order.{v} (Z a) (_inst_2 a)) a))
             a)
          a₂))
    b₂
    b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202    end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203    .. dlex_partial_order }.</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='dlex_partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {Z : α → Type v} [_inst_1 : partial_order.{u} α] [_inst_2 : Π (a : α), partial_order.{v} (Z a)], partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Dictionary / lexicographic partial_order for dependent pairs.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  /-- Dictionary / lexicographic decidable_linear_order for dependent pairs. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  instance dlex_decidable_linear_order [decidable_linear_order α] [∀ a, decidable_linear_order (Z a)] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='decidable_linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='decidable_linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207    decidable_linear_order (Σ&#x27; a, Z a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='decidable_linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='psigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='psigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  { decidable_le :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a)
⊢ @decidable_rel.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210      rintros ⟨a₁, b₁⟩ ⟨a₂, b₂⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a)
⊢ @decidable_rel.{(max u v)+1} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211      rcases decidable_linear_order.decidable_le α a₁ a₂ with a_lt | a_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='decidable_linear_order.decidable_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [c : decidable_linear_order.{u} α], @decidable_rel.{u+1} α (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α c) (@decidable_linear_order.lt.{u} α c) (@decidable_linear_order.le_refl.{u} α c) (@decidable_linear_order.le_trans.{u} α c) (@decidable_linear_order.lt_iff_le_not_le.{u} α c) (@decidable_linear_order.le_antisymm.{u} α c) (@decidable_linear_order.le_total.{u} α c))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  not
    (@has_le.le.{u} α
       (@preorder.to_has_le.{u} α
          (@partial_order.to_preorder.{u} α
             (@linear_order.to_partial_order.{u} α
                (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                   (@decidable_linear_order.lt.{u} α _inst_1)
                   (@decidable_linear_order.le_refl.{u} α _inst_1)
                   (@decidable_linear_order.le_trans.{u} α _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                   (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                   (@decidable_linear_order.le_total.{u} α _inst_1)))))
       a₁
       a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212      { -- a₂ &lt; a₁</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  not
    (@has_le.le.{u} α
       (@preorder.to_has_le.{u} α
          (@partial_order.to_preorder.{u} α
             (@linear_order.to_partial_order.{u} α
                (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                   (@decidable_linear_order.lt.{u} α _inst_1)
                   (@decidable_linear_order.le_refl.{u} α _inst_1)
                   (@decidable_linear_order.le_trans.{u} α _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                   (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                   (@decidable_linear_order.le_total.{u} α _inst_1)))))
       a₁
       a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  not
    (@has_le.le.{u} α
       (@preorder.to_has_le.{u} α
          (@partial_order.to_preorder.{u} α
             (@linear_order.to_partial_order.{u} α
                (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                   (@decidable_linear_order.lt.{u} α _inst_1)
                   (@decidable_linear_order.le_refl.{u} α _inst_1)
                   (@decidable_linear_order.le_trans.{u} α _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                   (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                   (@decidable_linear_order.le_total.{u} α _inst_1)))))
       a₁
       a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213        left, rw not_le at a_lt, rintro ⟨l, r⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : linear_order.{u} α] {a b : α}, iff (not (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) a b)) (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α (@linear_order.to_partial_order.{u} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  not
    (@has_le.le.{u} α
       (@preorder.to_has_le.{u} α
          (@partial_order.to_preorder.{u} α
             (@linear_order.to_partial_order.{u} α
                (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                   (@decidable_linear_order.lt.{u} α _inst_1)
                   (@decidable_linear_order.le_refl.{u} α _inst_1)
                   (@decidable_linear_order.le_trans.{u} α _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                   (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                   (@decidable_linear_order.le_total.{u} α _inst_1)))))
       a₁
       a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  not
    (@has_le.le.{u} α
       (@preorder.to_has_le.{u} α
          (@partial_order.to_preorder.{u} α
             (@linear_order.to_partial_order.{u} α
                (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                   (@decidable_linear_order.lt.{u} α _inst_1)
                   (@decidable_linear_order.le_refl.{u} α _inst_1)
                   (@decidable_linear_order.le_trans.{u} α _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                   (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                   (@decidable_linear_order.le_total.{u} α _inst_1)))))
       a₁
       a₂)
⊢ not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁
⊢ not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ false

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    a_b₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁,
a :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214        { apply lt_irrefl a₂, apply lt_trans, repeat { assumption } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lt_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b c : α}, @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a b → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) b c → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ false

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    a_b₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁,
a :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    ?m_1

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    ?m_1
    a₂

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    ?m_1

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    ?m_1
    a₂

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₂
    a₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂
⊢ α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    a_b₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁,
a :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215        { apply lt_irrefl a₁, assumption } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    a_b₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁,
a :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ a_b₂ : Z a₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    a_b₂,
a_lt :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁,
a :
  @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ a_b₂)
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216      { -- a₁ ≤ a₂</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217        by_cases h : a₁ = a₂,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218        { subst h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : @eq.{u+1} α a₁ a₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219          rcases decidable_linear_order.decidable_le _ b₁ b₂ with b_lt | b_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='decidable_linear_order.decidable_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type v) [c : decidable_linear_order.{v} α], @decidable_rel.{v+1} α (@has_le.le.{v} α (@preorder.to_has_le.{v} α (@partial_order.to_preorder.{v} α (@linear_order.to_partial_order.{v} α (@linear_order.mk.{v} α (@decidable_linear_order.le.{v} α c) (@decidable_linear_order.lt.{v} α c) (@decidable_linear_order.le_refl.{v} α c) (@decidable_linear_order.le_trans.{v} α c) (@decidable_linear_order.lt_iff_le_not_le.{v} α c) (@decidable_linear_order.le_antisymm.{v} α c) (@decidable_linear_order.le_total.{v} α c))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  not
    (@has_le.le.{v} (Z a₁)
       (@preorder.to_has_le.{v} (Z a₁)
          (@partial_order.to_preorder.{v} (Z a₁)
             (@linear_order.to_partial_order.{v} (Z a₁)
                (@linear_order.mk.{v} (Z a₁) (@decidable_linear_order.le.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.lt.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_refl.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_trans.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.lt_iff_le_not_le.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_antisymm.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_total.{v} (Z a₁) (_inst_2 a₁))))))
       b₁
       b₂)
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_le :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@linear_order.mk.{v} (Z a₁) (@decidable_linear_order.le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_refl.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_trans.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt_iff_le_not_le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_antisymm.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_total.{v} (Z a₁) (_inst_2 a₁))))))
    b₁
    b₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220          { -- b₂ &lt; b₁</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  not
    (@has_le.le.{v} (Z a₁)
       (@preorder.to_has_le.{v} (Z a₁)
          (@partial_order.to_preorder.{v} (Z a₁)
             (@linear_order.to_partial_order.{v} (Z a₁)
                (@linear_order.mk.{v} (Z a₁) (@decidable_linear_order.le.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.lt.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_refl.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_trans.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.lt_iff_le_not_le.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_antisymm.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_total.{v} (Z a₁) (_inst_2 a₁))))))
       b₁
       b₂)
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_le :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@linear_order.mk.{v} (Z a₁) (@decidable_linear_order.le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_refl.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_trans.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt_iff_le_not_le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_antisymm.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_total.{v} (Z a₁) (_inst_2 a₁))))))
    b₁
    b₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  not
    (@has_le.le.{v} (Z a₁)
       (@preorder.to_has_le.{v} (Z a₁)
          (@partial_order.to_preorder.{v} (Z a₁)
             (@linear_order.to_partial_order.{v} (Z a₁)
                (@linear_order.mk.{v} (Z a₁) (@decidable_linear_order.le.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.lt.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_refl.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_trans.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.lt_iff_le_not_le.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_antisymm.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_total.{v} (Z a₁) (_inst_2 a₁))))))
       b₁
       b₂)
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221            left, rw not_le at b_lt, rintro ⟨l, r⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : linear_order.{v} α] {a b : α}, iff (not (@has_le.le.{v} α (@preorder.to_has_le.{v} α (@partial_order.to_preorder.{v} α (@linear_order.to_partial_order.{v} α _inst_1))) a b)) (@has_lt.lt.{v} α (@preorder.to_has_lt.{v} α (@partial_order.to_preorder.{v} α (@linear_order.to_partial_order.{v} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  not
    (@has_le.le.{v} (Z a₁)
       (@preorder.to_has_le.{v} (Z a₁)
          (@partial_order.to_preorder.{v} (Z a₁)
             (@linear_order.to_partial_order.{v} (Z a₁)
                (@linear_order.mk.{v} (Z a₁) (@decidable_linear_order.le.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.lt.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_refl.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_trans.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.lt_iff_le_not_le.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_antisymm.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_total.{v} (Z a₁) (_inst_2 a₁))))))
       b₁
       b₂)
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  not
    (@has_le.le.{v} (Z a₁)
       (@preorder.to_has_le.{v} (Z a₁)
          (@partial_order.to_preorder.{v} (Z a₁)
             (@linear_order.to_partial_order.{v} (Z a₁)
                (@linear_order.mk.{v} (Z a₁) (@decidable_linear_order.le.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.lt.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_refl.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_trans.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.lt_iff_le_not_le.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_antisymm.{v} (Z a₁) (_inst_2 a₁))
                   (@decidable_linear_order.le_total.{v} (Z a₁) (_inst_2 a₁))))))
       b₁
       b₂)
⊢ not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁
⊢ not
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁
⊢ false

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    b₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222            { apply lt_irrefl a₁, assumption },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), not (@has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁
⊢ false

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    b₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a :
  @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    b₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223            { apply lt_irrefl b₂, apply lt_of_lt_of_le, repeat { assumption } } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='lt_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lt_of_lt_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] (a : α), not (@has_lt.lt.{v} α (@preorder.to_has_lt.{v} α _inst_1) a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] {a b c : α}, @has_lt.lt.{v} α (@preorder.to_has_lt.{v} α _inst_1) a b → @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) b c → @has_lt.lt.{v} α (@preorder.to_has_lt.{v} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    b₂
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    b₂
⊢ @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    b₂
⊢ @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    ?m_1

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    b₂
⊢ @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    ?m_1
    b₂

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    b₂
⊢ Z a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    b₂
⊢ @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    b₂
⊢ @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    ?m_1

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    b₂
⊢ @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    ?m_1
    b₂

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_lt :
  @has_lt.lt.{v} (Z a₁)
    (@preorder.to_has_lt.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@decidable_linear_order.to_linear_order.{v} (Z a₁) (_inst_2 a₁)))))
    b₂
    b₁,
a_a_1 :
  @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    b₂
⊢ Z a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_le :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@linear_order.mk.{v} (Z a₁) (@decidable_linear_order.le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_refl.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_trans.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt_iff_le_not_le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_antisymm.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_total.{v} (Z a₁) (_inst_2 a₁))))))
    b₁
    b₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224            -- b₁ ≤ b₂</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_le :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@linear_order.mk.{v} (Z a₁) (@decidable_linear_order.le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_refl.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_trans.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt_iff_le_not_le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_antisymm.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_total.{v} (Z a₁) (_inst_2 a₁))))))
    b₁
    b₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225           { right, right, assumption } },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_le :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@linear_order.mk.{v} (Z a₁) (@decidable_linear_order.le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_refl.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_trans.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt_iff_le_not_le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_antisymm.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_total.{v} (Z a₁) (_inst_2 a₁))))))
    b₁
    b₂
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_le :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@linear_order.mk.{v} (Z a₁) (@decidable_linear_order.le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_refl.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_trans.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt_iff_le_not_le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_antisymm.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_total.{v} (Z a₁) (_inst_2 a₁))))))
    b₁
    b₂
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ b₂ : Z a₁,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₁,
b_le :
  @has_le.le.{v} (Z a₁)
    (@preorder.to_has_le.{v} (Z a₁)
       (@partial_order.to_preorder.{v} (Z a₁)
          (@linear_order.to_partial_order.{v} (Z a₁)
             (@linear_order.mk.{v} (Z a₁) (@decidable_linear_order.le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_refl.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_trans.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.lt_iff_le_not_le.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_antisymm.{v} (Z a₁) (_inst_2 a₁))
                (@decidable_linear_order.le_total.{v} (Z a₁) (_inst_2 a₁))))))
    b₁
    b₂
⊢ @has_le.le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
    (@preorder.to_has_le.{v} ((λ (a : α), (λ (a : α), (λ (a : α), (λ (a : α), Z a) a) a) a) a₁)
       ((λ (a : α),
           (λ (a : α),
              @partial_order.to_preorder.{v} ((λ (a : α), (λ (a : α), Z a) a) a)
                ((λ (a : α),
                    @linear_order.to_partial_order.{v} ((λ (a : α), Z a) a)
                      ((λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a)) a))
                   a))
             a)
          a₁))
    b₁
    b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226        -- a₁ &lt; a₂</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227        { right, left, apply lt_of_le_of_ne, repeat { assumption } } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='lt_of_le_of_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : partial_order.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b → @ne.{u+1} α a b → @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`repeat { t }` applies `t` to each goal. If the application succeeds,
the tactic is applied recursively to all the generated subgoals until it eventually fails.
The recursion stops in a subgoal when the tactic has failed to make progress.
The tactic `repeat { t }` never fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='repeat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ decidable
    (@has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                   (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                      (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                         (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                         (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
       (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @has_le.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
    (@preorder.to_has_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
       (@partial_order.to_preorder.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
          (@linear_order.to_partial_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
             (@linear_order.mk.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                (@linear_order.le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_refl.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_trans.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.lt_iff_le_not_le.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_antisymm.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))
                (@linear_order.le_total.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))
                   (@dlex_linear_order.{u v} α (λ (a : α), Z a)
                      (@decidable_linear_order.to_linear_order.{u} α _inst_1)
                      (λ (a : α), @decidable_linear_order.to_linear_order.{v} (Z a) (_inst_2 a))))))))
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₁ b₁)
    (@psigma.mk.{u+1 v+1} α (λ (a : α), Z a) a₂ b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @has_lt.lt.{u} α
    (@preorder.to_has_lt.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @ne.{u+1} α a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α (@decidable_linear_order.to_linear_order.{u} α _inst_1))))
    a₁
    a₂

α : Type u,
Z : α → Type v,
_inst_1 : decidable_linear_order.{u} α,
_inst_2 : Π (a : α), decidable_linear_order.{v} (Z a),
a₁ : α,
b₁ : Z a₁,
a₂ : α,
b₂ : Z a₂,
a_le :
  @has_le.le.{u} α
    (@preorder.to_has_le.{u} α
       (@partial_order.to_preorder.{u} α
          (@linear_order.to_partial_order.{u} α
             (@linear_order.mk.{u} α (@decidable_linear_order.le.{u} α _inst_1)
                (@decidable_linear_order.lt.{u} α _inst_1)
                (@decidable_linear_order.le_refl.{u} α _inst_1)
                (@decidable_linear_order.le_trans.{u} α _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u} α _inst_1)
                (@decidable_linear_order.le_antisymm.{u} α _inst_1)
                (@decidable_linear_order.le_total.{u} α _inst_1)))))
    a₁
    a₂,
h : not (@eq.{u+1} α a₁ a₂)
⊢ @ne.{u+1} α a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229    .. dlex_linear_order }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='dlex_linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {Z : α → Type v} [_inst_1 : linear_order.{u} α] [_inst_2 : Π (a : α), linear_order.{v} (Z a)], linear_order.{(max u v)} (@psigma.{u+1 v+1} α (λ (a : α), Z a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Dictionary / lexicographic linear_order for pairs.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font></pre>
</body>